<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backends Overview on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/v1.4/backends/</link><description>Recent content in Backends Overview on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/v1.4/backends/index.xml" rel="self" type="application/rss+xml"/><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v1.4/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v1.4/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v1.4/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v1.4/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/v1.4/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v1.4/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v1.4/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item></channel></rss>