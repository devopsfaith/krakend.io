<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Creating API endpoints on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/enterprise/endpoints/</link><description>Recent content in Creating API endpoints on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 26 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/enterprise/endpoints/index.xml" rel="self" type="application/rss+xml"/><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send responses back to the client in a different format than what your services provide.</description></item><item><title>Response manipulation with query language</title><link>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>Validating the responses with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/openapi/</guid><description>The OpenAPI or Swagger documentation is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item></channel></rss>