<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Declaring and connecting to backends on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/</link><description>Recent content in Declaring and connecting to backends on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/enterprise/v2.3/backends/index.xml" rel="self" type="application/rss+xml"/><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>gRPC backend client</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/grpc/</guid><description>Consuming content from a gRPC upstream service becomes straightforward through KrakenD and hides all the complexity to consumers.
gRPC is a protocol that creates a channel connection between a client and a server and allows calling methods to send and receive payloads serialized with protocol buffers. With the gRPC integration, KrakenD acts as the gRPC client.
KrakenD supports Unary RPCs requests as a backend but not streaming connections (server, client, or bidirectional streaming), as we don&amp;rsquo;t see fit in the context of an API Gateway.</description></item><item><title>Body manipulation and generation</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>SOAP integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>HTTP Logger to dump requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>Per backend HTTP client settings</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item></channel></rss>