<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KrakenD API Gateway Documentation on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/</link><description>Recent content in KrakenD API Gateway Documentation on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 12 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/enterprise/v2.7/index.xml" rel="self" type="application/rss+xml"/><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.7/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.7/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item></channel></rss>