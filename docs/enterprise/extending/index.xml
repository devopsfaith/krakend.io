<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction to custom plugins and middlewares on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/enterprise/extending/</link><description>Recent content in Introduction to custom plugins and middlewares on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 25 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/enterprise/extending/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. To start using your own plugins make sure to write them implementing the right interface and compile them respecting the requirements.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins for understanding the different types of plugins you can use. Plugin requirements Plugin binaries are not cross-platform compatible You must compile the plugin with the same architecture/platform where it will be run.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</guid><description>Your plugin is already developed and ready to use, and now you want to use it. There are two phases:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/enterprise/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, you should spend a few minutes understanding the big pieces of the system, how they work, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very, very important) Failing fast is better than succeeding slow The simpler, the better Everything is pluggable Each request must be processed in its request-scoped context KrakenD internal states When you start KrakenD, the system goes through two different internal states: building and working.</description></item></channel></rss>