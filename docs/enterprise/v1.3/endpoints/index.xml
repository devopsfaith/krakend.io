<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>How to create KrakenD endpoints on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/</link><description>Recent content in How to create KrakenD endpoints on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 26 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/enterprise/v1.3/endpoints/index.xml" rel="self" type="application/rss+xml"/><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>The `/__debug` endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</guid><description>The /__debug endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always return a response in JSON format to the client.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</guid><description>The krakend-wildcard plugin allows you that URLs starting with known patterns are forwarded to a common endpoint, without needing to declare all possible routes. For instance, you want to forward all traffic to /foo/* (with any nesting levels) to a specific backend.
Adding wildcard routes Let&amp;rsquo;s say you define the wildcard pattern /foo. It could match with URLs like the ones below:
/foo /foo/a?x=1 /foo/a/b/c/d /foo/* Wildcard paths are not regexp patterns, but literal matches of an URL and all its subresources.</description></item><item><title>Serving or using static content</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</guid><description>The krakend-static-live plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http server handler, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http client executor, the KrakenD endpoints use static content as if it were a backend.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (payment and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration.
Configuration for GeoIP Add the following extra_config in the root to your configuration file:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</guid><description>The OpenAPI or Swagger generator is a component provided by the KrakenD Studio, offering the automatic generation of API documentation through a static Swagger file. Even KrakenD is the gateway and lacks all the knowledge of your API backends, KrakenD Studio is capable of providing in-depth detail of backend responses in the documentation documentation:inspection of live requests.
Generating the OpenAPI spec When you run the KrakenD configuration through KrakenD Studio you can enable the Swagger generation from the UI, or by adding the configuration snippet in your krakend.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration On KrakenD EE the virtual host plugin usually lives inside the /plugins folder.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat krakend.</description></item></channel></rss>