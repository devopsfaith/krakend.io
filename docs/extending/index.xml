<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Extending KrakenD with your code on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/extending/</link><description>Recent content in Extending KrakenD with your code on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 23 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/extending/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend check-plugin command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item></channel></rss>