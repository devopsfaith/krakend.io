<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Extending KrakenD API Gateway - Plugin Development on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/</link><description>Recent content in Extending KrakenD API Gateway - Plugin Development on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 27 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/v2.6/extending/index.xml" rel="self" type="application/rss+xml"/><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/v2.6/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.6/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.6/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.6/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item></channel></rss>