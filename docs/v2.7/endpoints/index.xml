<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Endpoint Configuration on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/v2.7/endpoints/</link><description>Recent content in Endpoint Configuration on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 03 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/v2.7/endpoints/index.xml" rel="self" type="application/rss+xml"/><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.7/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.7/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.7/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.7/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.7/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.7/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.7/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.7/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.7/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.7/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.7/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.7/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.7/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.7/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item></channel></rss>