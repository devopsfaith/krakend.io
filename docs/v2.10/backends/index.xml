<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backend Configuration on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/v2.10/backends/</link><description>Recent content in Backend Configuration on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 31 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/v2.10/backends/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.10/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.10/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.10/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.10/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.10/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.10/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/v2.10/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.10/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.10/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.10/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.10/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.10/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.10/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.10/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors We do not recommend you to change the default behavior to have a secure and decoupled gateway.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/v2.10/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.10/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item></channel></rss>