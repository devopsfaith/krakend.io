<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Declaring and connecting to backends on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/backends/</link><description>Recent content in Declaring and connecting to backends on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/backends/index.xml" rel="self" type="application/rss+xml"/><item><title>Data manipulation</title><link>https://www.krakend.io/docs/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/service-discovery/</guid><description>Service discovery (sd) is an attribute in the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the qos/httpcache middleware.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item></channel></rss>