<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Declaring and connecting to backends on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/docs/backends/</link><description>Recent content in Declaring and connecting to backends on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/docs/backends/index.xml" rel="self" type="application/rss+xml"/><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item></channel></rss>