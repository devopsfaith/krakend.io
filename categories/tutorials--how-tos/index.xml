<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials &amp; How-Tos on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/categories/tutorials--how-tos/</link><description>Recent content in Tutorials &amp; How-Tos on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 25 Sep 2023 13:25:33 +0200</lastBuildDate><atom:link href="https://www.krakend.io/categories/tutorials--how-tos/index.xml" rel="self" type="application/rss+xml"/><item><title>Mastering API Rate Limiting with KrakenD: A Comprehensive Guide</title><link>https://www.krakend.io/blog/api-rate-limit/</link><pubDate>Mon, 25 Sep 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/api-rate-limit/</guid><description>&lt;p&gt;When it comes to managing APIs effectively with KrakenD, understanding the intricacies of rate limiting is essential. This guide provides a deep dive into rate limiting within KrakenD, covering its importance, types, best practices, and future trends.&lt;/p&gt;
&lt;h2 id="understanding-rate-limiting-in-krakend-types-and-roles"&gt;Understanding Rate Limiting in KrakenD: Types and Roles&lt;/h2&gt;
&lt;p&gt;Rate limiting serves multiple functions, from resource allocation and security to ensuring API availability. KrakenD offers a variety of rate limiting options to suit different needs:&lt;/p&gt;</description></item><item><title>Automating the Software Bill of Materials (SBOM)</title><link>https://www.krakend.io/blog/generating-a-sbom/</link><pubDate>Wed, 13 Sep 2023 11:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/generating-a-sbom/</guid><description>&lt;p&gt;We can define a &lt;strong&gt;Software Bill of Materials (SBOM)&lt;/strong&gt; as a comprehensive &lt;strong&gt;inventory&lt;/strong&gt; of open-source and third-party components within a codebase.&lt;/p&gt;
&lt;p&gt;It includes component licenses, versions, and patch status to assess security and license risks. This concept draws inspiration from manufacturing, where product inventory lists are vital. Like an automotive Bill of Materials, an SBOM helps identify and address issues in software components efficiently.&lt;/p&gt;
&lt;p&gt;Organizations need SBOMs due to security breaches, prompting cybersecurity guidelines. While initially &lt;strong&gt;aimed at government entities&lt;/strong&gt;, the &lt;a href="https://www.federalregister.gov/documents/2021/05/17/2021-10460/improving-the-nations-cybersecurity"&gt;Executive Order on Improving the Nation&amp;rsquo;s Cybersecurity &lt;/a&gt; briefed on 2021 emphasized securing the US government, but &lt;strong&gt;influenced later on all types of organizations&lt;/strong&gt;. The key directives include developing new security standards, maturing SBOMs, and formalizing code testing.&lt;/p&gt;</description></item><item><title>Securing Your Microservices and APIs: The KrakenD Way</title><link>https://www.krakend.io/blog/securing-your-microservices/</link><pubDate>Wed, 26 Jul 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/securing-your-microservices/</guid><description>&lt;p&gt;In today&amp;rsquo;s world, where everything is going digital, we can&amp;rsquo;t overemphasize the importance of keeping your APIs and microservices safe. Cyber threats are an everyday reality, and they don&amp;rsquo;t care how big or complex your infrastructure is. They just want a way in. This is where KrakenD, a leading &lt;a href="https://www.krakend.io/"&gt;API gateway&lt;/a&gt; company, steps in. We&amp;rsquo;ve got your back with our robust solution, built around a &lt;a href="https://www.krakend.io/docs/design/zero-trust/"&gt;zero-trust policy&lt;/a&gt;, OWASP guidelines, and a bunch of other cool stuff to bolster your API security.&lt;/p&gt;</description></item><item><title>Canary releases with KrakenD: Safely roll out API changes</title><link>https://www.krakend.io/blog/canary-releases/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/canary-releases/</guid><description>&lt;p&gt;Canary release is a powerful technique that helps organizations &lt;strong&gt;deploy changes to their APIs in a controlled and gradual manner&lt;/strong&gt;. Instead of publishing changes to receive the impact of all traffic when going live, you expose the changes to a small subset of the traffic. The Canary Release allows for thorough monitoring and validation, reducing the risk of potential issues affecting the entire system.&lt;/p&gt;
&lt;p&gt;This blog post will explore &lt;strong&gt;three ways of implementing Canary Releases&lt;/strong&gt; on KrakenD, ensuring smoother deployments and enhanced reliability.&lt;/p&gt;</description></item><item><title>Traffic mirroring: test APIs without tests</title><link>https://www.krakend.io/blog/krakend-shadow-testing/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-shadow-testing/</guid><description>&lt;p&gt;Integration and load testing are in the list of best practices in our sector, but synthesizing good inputs for such tests and analyzing the results are usually two hard things to achieve. This post will show you how we suggest our customers set up a shadow testing system with minimal impact on the production environment and proper harness.&lt;/p&gt;
&lt;h2 id="quick-overview"&gt;Quick overview&lt;/h2&gt;
&lt;p&gt;As pointed out at &lt;a href="https://cloud.google.com/architecture/application-deployment-and-testing-strategies"&gt;https://cloud.google.com/architecture/application-deployment-and-testing-strategies&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Testing new backend features by using the production load.&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>How to write a simple gRPC-gateway as a KrakenD plugin</title><link>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</link><pubDate>Sun, 09 Jun 2019 18:26:10 +0100</pubDate><guid>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</guid><description>The gRPC protocol is becoming trendy in the era of microservices. Its compactness and backward-compatibility make it very attractive. However, it requires custom code to work with it. In this article, we&amp;rsquo;ll show you how to get all the benefits from the gRPC protocol and the gRPC-gateway without coding any business logic to use your gRPC services as regular backends. Moreover, avoiding the extra network hop!</description></item><item><title>How we run KrakenD on Javascript with WebAssembly</title><link>https://www.krakend.io/blog/krakend-wasm/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-wasm/</guid><description>&lt;p&gt;&lt;a href="https://www.krakend.io"&gt;KrakenD&lt;/a&gt; is an API Gateway written in Go that uses a single configuration file to define its whole behavior. As the configuration file might be complicated, the &lt;a href="https://designer.krakend.io"&gt;KrakenDesigner&lt;/a&gt; is a javascript-based user interface to edit this file, and we were missing the capability of reproducing directly on javascript the existing gateway pipes so that users could run manual tests over the editing configuration.&lt;/p&gt;
&lt;p&gt;In this post, we are going to explain how we included KrakenD framework components in a &lt;code&gt;.wasm&lt;/code&gt; file and how we integrated it into our existing SPA. This is our go code running on javascript.&lt;/p&gt;</description></item><item><title>Reloading the config with Reflex and Docker</title><link>https://www.krakend.io/blog/reloading-the-krakend-configuration/</link><pubDate>Fri, 22 Jun 2018 11:06:53 +0200</pubDate><guid>https://www.krakend.io/blog/reloading-the-krakend-configuration/</guid><description>&lt;div class="rounded-lg border border-brand-blue overflow-auto"&gt;
 &lt;div class="note-brand-blue flex gap-2.5 items-center text-sm text-brand-blue bg-brand-blue/15 px-3 py-2"&gt;
 
 &lt;svg width="21" height="21" xmlns="http://www.w3.org/2000/svg"&gt;
 &lt;g stroke="currentColor" stroke-width="1.25" fill="none" fill-rule="evenodd"&gt;
 &lt;path stroke-linecap="round" stroke-linejoin="round" d="M10.815 14.371V8.418" /&gt;
 &lt;path d="M10.815 5.71a.27.27 0 0 0 0 .542M10.815 5.71a.27.27 0 0 1 0 .542" /&gt;
 &lt;path d="M10.815 1.918a8.125 8.125 0 1 1 0 16.25 8.125 8.125 0 0 1 0-16.25z" /&gt;
 &lt;/g&gt;
 &lt;/svg&gt;
 
 &lt;span&gt;
 Read the new documentation
 &lt;/span&gt;
 &lt;/div&gt;
 &lt;div class="border-t border-brand-blue p-3 pl-10 dark:text-white note text-sm"&gt;This is an article from 2018. You might want to see the &lt;a href="https://www.krakend.io/docs/developer/hot-reload/"&gt;Hot reload documentation&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;A recurrent question when we go around is if KrakenD configuration can be hot-reloaded, this is changing endpoints, backends, or any other configuration of the gateway while it&amp;rsquo;s running. The short answer is: No, you can&amp;rsquo;t. You must restart the server. And although we might have something to alleviate this, let us explain first why we don&amp;rsquo;t support such a feature:&lt;/p&gt;</description></item><item><title>KrakenD API Gateway on Kubernetes - Deployment Guide</title><link>https://www.krakend.io/blog/krakend-on-kubernetes/</link><pubDate>Wed, 06 Jun 2018 18:47:03 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-kubernetes/</guid><description>&lt;p&gt;In this article we are going to show how to configure and deploy the KrakenD API Gateway in a kubernetes environment.&lt;/p&gt;
&lt;p&gt;We will use for the demonstration &lt;a href="https://github.com/kubernetes/minikube"&gt;Minikube&lt;/a&gt; so you cant test it in your own local machine.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s get started!&lt;/p&gt;
&lt;h2 id="setting-up-a-local-kubernetes"&gt;Setting up a local Kubernetes&lt;/h2&gt;
&lt;p&gt;We will run Kubernetes locally thanks to Minikube. Just follow the &lt;a href="https://github.com/kubernetes/minikube"&gt;README&lt;/a&gt; in the project for the installation and the &lt;em&gt;Quickstart&lt;/em&gt; section. Installing minikube it&amp;rsquo;s quick and easy.&lt;/p&gt;</description></item><item><title>Edge computing - A story of buses, IoT, and API gateways</title><link>https://www.krakend.io/blog/krakend-on-raspberry/</link><pubDate>Tue, 01 May 2018 21:25:00 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-raspberry/</guid><description>&lt;p&gt;The IoT industry has been running for some years now adding millions of devices into the network. The range of devices and capabilities is very wide and heterogeneous, from small devices powered with a 9-volt battery to track the location of freight shippings traveling the oceans (using platforms like &lt;a href="https://www.sigfox.com"&gt;Sigfox&lt;/a&gt;) to permanently plugged devices with more powerful computing like a &lt;a href="https://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; where computation cycles are not a problem.&lt;/p&gt;
&lt;p&gt;Generally speaking, all these devices collect raw data and send it to the cloud where big data centers process it. In some cases it will trigger events back in the devices that are subscribed to a service. All devices are pretty dumb as they are quite passive and don&amp;rsquo;t process much data, they just send raw data and some even wait for a single service to provide feedback (the smartest devices) and trigger some action.&lt;/p&gt;</description></item></channel></rss>