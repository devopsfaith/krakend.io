<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KrakenD API Gateway</title>
    <link>https://www.krakend.io/</link>
    <description>Recent content on KrakenD API Gateway</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Oct 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.krakend.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to KrakenD</title>
      <link>https://www.krakend.io/docs/overview/introduction/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/introduction/</guid>
      <description>What is KrakenD? KrakenD is a high-performance open source API Gateway.
Its core functionality is to create an API that acts as an aggregator of many microservices into single endpoints, doing the heavy-lifting automatically for you: aggregate, transform, filter, decode, throttle, auth and more.
KrakenD needs no programming as it offers a declarative way to create the endpoints. It is well structured and layered and open to extending its functionality using plug-and-play middleware developed by the community or in-house.</description>
    </item>
    
    <item>
      <title>Extending KrakenD, the big picture.</title>
      <link>https://www.krakend.io/docs/extending/the-big-picture/</link>
      <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/extending/the-big-picture/</guid>
      <description>Before starting to dive into the KrakenD framework code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD, as they answer to architectural design questions:
 Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description>
    </item>
    
    <item>
      <title>Backends Overview</title>
      <link>https://www.krakend.io/docs/backends/overview/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/overview/</guid>
      <description>The concept of &amp;ldquo;backend&amp;rdquo; references to the origin servers providing the necessary data to populate your endpoints.
A backend can be any server inside our outside your networks as long it is reachable by KrakenD. For instance, you can create endpoints that are fetching data from your internal servers and enrich them by adding third-party data from an external API like Github, Facebook or any other service.
The backends are declared inside every endpoint using the backend key.</description>
    </item>
    
    <item>
      <title>Service Discovery overview</title>
      <link>https://www.krakend.io/docs/service-discovery/overview/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/service-discovery/overview/</guid>
      <description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description>
    </item>
    
    <item>
      <title>KrakenD&#39;s configuration file overview</title>
      <link>https://www.krakend.io/docs/configuration/overview/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/configuration/overview/</guid>
      <description>When the KrakenD service is about to be started, the run command requires passing the flag -c which states the path to the configuration file. We refer through the documentation to this file as the krakend.json, but it can be stored or named according to your preferences.
If your configuration file is too large or repetitive, it can be split into multiple files using a templating system, where ENV vars can also be injected as dynamic values.</description>
    </item>
    
    <item>
      <title>Throttling overview</title>
      <link>https://www.krakend.io/docs/throttling/overview/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/throttling/overview/</guid>
      <description>KrakenD offers several ways to protect the usage of your infrastructure that might act at very different levels.
The most significant type of throttling is the rate limit that allows you to restrict the traffic of end-users or the traffic of KrakenD against your backend services. The rate limits mainly cover the following purposes:
 Avoid stressing or flooding your backend services with massive requests (proxy rate limit) Establish a quota of usage for your exposed API (router rate limit) Create a simple QoS strategy for your API  The rate limits are complementary to the Circuit Breaker feature.</description>
    </item>
    
    <item>
      <title>High-availability cluster</title>
      <link>https://www.krakend.io/docs/cluster/cluster-overview/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/cluster/cluster-overview/</guid>
      <description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
 Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description>
    </item>
    
    <item>
      <title>Benchmarks Overview</title>
      <link>https://www.krakend.io/docs/benchmarks/overview/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/benchmarks/overview/</guid>
      <description>KrakenD, the ultra performer API Gateway An API Gateway is a component that needs to deliver really fast, as it is an added layer in the infrastructure. KrakenD was built with performance in mind. In this page and inner pages, you&amp;rsquo;ll find several tests we did to measure the performance. We also invite you to do them for yourself!
TL;DR: Benchmark results ~18,000 requests/second on an ordinary laptop.
The following table summarizes different performance tests using Amazon EC2 virtual instances and an example with a laptop.</description>
    </item>
    
    <item>
      <title>Running KrakenD server. The `krakend run` command</title>
      <link>https://www.krakend.io/docs/commands/run/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/commands/run/</guid>
      <description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
krakend run -c krakend.json # or krakend run --config /path/to/krakend.json # or krakend run --config /path/to/krakend.json -p 8080  The krakend run command with no flags will remind you that you need the path to the configuration file:
$ krakend run Please, provide the path to your config file  Show the help:</description>
    </item>
    
    <item>
      <title>JSON Web Tokens overview</title>
      <link>https://www.krakend.io/docs/authorization/jwt-overview/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/authorization/jwt-overview/</guid>
      <description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description>
    </item>
    
    <item>
      <title>Logging - Syslog, stdout and GELF</title>
      <link>https://www.krakend.io/docs/logging-metrics-tracing/logging/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/logging-metrics-tracing/logging/</guid>
      <description>When the service starts, if no logging configuration is set, all the log events are sent to the standard output using the basic logger capabilities of the KrakenD framework. The reporting level, in that case, is DEBUG and adds no prefix to the logs.
Extending the logging capabilities Different logging components allow you to extend the logging functionality, such as sending the events to the syslog, choosing the verbosity level or use the Graylog Extended Log Format (GELF).</description>
    </item>
    
    <item>
      <title>Rate-limiting backends</title>
      <link>https://www.krakend.io/docs/backends/rate-limit/</link>
      <pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/rate-limit/</guid>
      <description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows:
... { &amp;quot;endpoint&amp;quot;: &amp;quot;/products/{cat_id}&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;host&amp;quot;: [ &amp;quot;http://some.api.com/&amp;quot; ], &amp;quot;url_pattern&amp;quot;: &amp;quot;/catalog/category/{cat_id}.</description>
    </item>
    
    <item>
      <title>Understanding the configuration file</title>
      <link>https://www.krakend.io/docs/configuration/structure/</link>
      <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/configuration/structure/</guid>
      <description>All KrakenD behavior depends on the krakend.json file, so being familiar with the structure of this file it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file, let&amp;rsquo;s focus now only on the structure:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;endpoints&amp;quot;: [...] &amp;quot;extra_config&amp;quot;: {...} ... }   version: The KrakenD file format. Current version is 2, use 1 only for old KrakenD releases (0.</description>
    </item>
    
    <item>
      <title>Deployment best practices</title>
      <link>https://www.krakend.io/docs/deploying/best-practices/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/deploying/best-practices/</guid>
      <description>This document is a draft
Setting up a cluster of KrakenD instances is a straightforward process but here are some recommendations to get a good start.
Use HTTP2 Enable HTTP2 between your balancer and KrakenD API gateway for the best performance.
SSL Add your SSL certificate in the load balancer and use internal certificates between the load balancer and KrakenD.
Enable metrics and logging Make sure you have visibility of what is going on.</description>
    </item>
    
    <item>
      <title>Developer Tools</title>
      <link>https://www.krakend.io/docs/developer/overview/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/developer/overview/</guid>
      <description>This document is a draft
There are some resources that make your life easier when developing with KrakenD. These tools are ment to be used only in development and never in production
Hot reload the configuration A Docker image using Reflex watches the configuration directory and reloads KrakenD when the configuration changes. This is very convenient while you are developing as it allows you to test new changes without having to restart manually and making the process less tedious.</description>
    </item>
    
    <item>
      <title>Setting up a cluster</title>
      <link>https://www.krakend.io/docs/cluster/configuration/</link>
      <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/cluster/configuration/</guid>
      <description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description>
    </item>
    
    <item>
      <title>Commands - check</title>
      <link>https://www.krakend.io/docs/commands/check/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/commands/check/</guid>
      <description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage $ krakend check -h `7MMF&#39; `YMM&#39; `7MM `7MM&amp;quot;&amp;quot;&amp;quot;Yb. MM .M&#39; MM MM `Yb. MM .d&amp;quot; `7Mb,od8 ,6&amp;quot;Yb. MM ,MP&#39;.gP&amp;quot;Ya `7MMpMMMb. MM `Mb MMMMM. MM&#39; &amp;quot;&#39;8) MM MM ;Y ,M&#39; Yb MM MM MM MM MM VMA MM ,pm9MM MM;Mm 8M&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot; MM MM MM ,MP MM `MM.</description>
    </item>
    
    <item>
      <title>Comparison of KrakenD vs other products in the market (Benchmark)</title>
      <link>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</guid>
      <description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
 Kong Vulcand Tyk KrakenD  For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
TLDR; Check out the generated graphs (throughput and responses) or the summary</description>
    </item>
    
    <item>
      <title>KrakenD Benchmarks on AWS</title>
      <link>https://www.krakend.io/docs/benchmarks/aws/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/benchmarks/aws/</guid>
      <description>TL;DR Check out the generated graphs or the conclusions
The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
 A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description>
    </item>
    
    <item>
      <title>SD with DNS SRV (e.g. Consul)</title>
      <link>https://www.krakend.io/docs/service-discovery/dns-srv/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/service-discovery/dns-srv/</guid>
      <description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
 &amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution  These keys need to be added in the backend section of your configuration.</description>
    </item>
    
    <item>
      <title>Response manipulation</title>
      <link>https://www.krakend.io/docs/endpoints/response-manipulation/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/response-manipulation/</guid>
      <description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description>
    </item>
    
    <item>
      <title>Endpoint rate limiting</title>
      <link>https://www.krakend.io/docs/endpoints/rate-limit/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/rate-limit/</guid>
      <description>Limiting endpoints is responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint is going to accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description>
    </item>
    
    <item>
      <title>Local Benchmarks</title>
      <link>https://www.krakend.io/docs/benchmarks/local/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/benchmarks/local/</guid>
      <description>TL;DR Check out the generated graphs or the summary
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz  Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; }  And we started the KrakenD with this cmd:</description>
    </item>
    
    <item>
      <title>Metrics middleware</title>
      <link>https://www.krakend.io/docs/logging-metrics-tracing/metrics/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/logging-metrics-tracing/metrics/</guid>
      <description>The metrics middleware offers a new service in a different port and exposes a /__stats/ endpoint with the collection of all the KrakenD metrics.
Enabling metrics In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.g.:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-metrics&amp;#34;: { &amp;#34;collection_time&amp;#34;: &amp;#34;60s&amp;#34;, &amp;#34;proxy_disabled&amp;#34;: false, &amp;#34;router_disabled&amp;#34;: false, &amp;#34;backend_disabled&amp;#34;: false, &amp;#34;endpoint_disabled&amp;#34;: false, &amp;#34;listen_address&amp;#34;: &amp;#34;:8090&amp;#34; },  .</description>
    </item>
    
    <item>
      <title>JWT Validation</title>
      <link>https://www.krakend.io/docs/authorization/jwt-validation/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/authorization/jwt-validation/</guid>
      <description>The JWT validation shields any amount of desired endpoints, forcing requests to the API gateway to provide a token issued by a third party. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.
The JOSE component is responsible for validating the tokens.
A typical request requiring JWT validation includes in the Authorization header a bearer with the token:</description>
    </item>
    
    <item>
      <title>Service Discovery with etcd</title>
      <link>https://www.krakend.io/docs/service-discovery/etcd/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/service-discovery/etcd/</guid>
      <description>The etcd Service Discovery integration allows you to perform the host resolution using your existing etcd setup.
The integration etcd is controlled by the krakend-etcd component and adds client and subscriber capabilities for etcd.
Enabling etcd To enable the integration add in the root of your configuration file the necessary settings:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-etcd&amp;#34;: { &amp;#34;machines&amp;#34;: [ &amp;#34;https://192.168.1.100:4001&amp;#34;, &amp;#34;https://192.168.1.101:4001&amp;#34; ], &amp;#34;dial_timeout&amp;#34;: &amp;#34;5s&amp;#34;, &amp;#34;dial_keepalive&amp;#34;: &amp;#34;30s&amp;#34;, &amp;#34;header_timeout&amp;#34;: &amp;#34;1s&amp;#34;, &amp;#34;cert&amp;#34;: &amp;#34;/path/to/cert&amp;#34;, &amp;#34;key&amp;#34;: &amp;#34;/path/to/cert-private-key&amp;#34;, &amp;#34;cacert&amp;#34;: &amp;#34;/path/to/CA-cert&amp;#34; }  }, .</description>
    </item>
    
    <item>
      <title>The Circuit Breaker</title>
      <link>https://www.krakend.io/docs/backends/circuit-breaker/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/circuit-breaker/</guid>
      <description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several points of the processing pipe. Thanks to this component, when KrakenD demands more throughput than your actual API stack is able to deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems, by preventing too many requests to fail due to timeouts, etc.</description>
    </item>
    
    <item>
      <title>Installing KrakenD</title>
      <link>https://www.krakend.io/docs/overview/installing/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/installing/</guid>
      <description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
 Download KrakenD and  Generate the configuration file
Just exploring?
Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API. Everything is ready to start playing, just do a docker-compose up!</description>
    </item>
    
    <item>
      <title>KrakenD file supported formats</title>
      <link>https://www.krakend.io/docs/configuration/supported-formats/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/configuration/supported-formats/</guid>
      <description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following extensions is found:
 .json .toml .yaml .yml .properties .props .prop .hcl  Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description>
    </item>
    
    <item>
      <title>JWT Signing</title>
      <link>https://www.krakend.io/docs/authorization/jwt-signing/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/authorization/jwt-signing/</guid>
      <description>The JWT signing component is meant to create an endpoint wrapper that returns signed tokens when your application returns plain text tokens. The tokens return to the user signed with your secret key, that can be kept in the gateway or a trusted machine. With the token signing, you are in control of the private key, and you don&amp;rsquo;t need to trust an external source to keep it for you.</description>
    </item>
    
    <item>
      <title>Parameter forwarding</title>
      <link>https://www.krakend.io/docs/endpoints/parameter-forwarding/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/parameter-forwarding/</guid>
      <description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
 No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded  You can change this behavior according to your needs, and define which elements are allowed to pass.</description>
    </item>
    
    <item>
      <title>Using KrakenD</title>
      <link>https://www.krakend.io/docs/overview/usage/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/usage/</guid>
      <description>From an operations point of view KrakenD, is very simple to use. It only requires you to pass the path the configuration file (which defines behaviors and endpoints). Additionally, you can enable the debug with the -d flag, and that&amp;rsquo;s pretty much everything.
TL;DR  Generate a configuration file with your endpoints definition. The easier way to generate it is using the designer Check the syntax of your krakend.json is good</description>
    </item>
    
    <item>
      <title>Concurrent Requests</title>
      <link>https://www.krakend.io/docs/backends/concurrent-requests/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/concurrent-requests/</guid>
      <description>The concurrent requests is an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description>
    </item>
    
    <item>
      <title>Service Discovery with Eureka</title>
      <link>https://www.krakend.io/docs/service-discovery/eureka/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/service-discovery/eureka/</guid>
      <description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
 schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by Jo√£o Alves  </description>
    </item>
    
    <item>
      <title>The `/__debug` endpoint</title>
      <link>https://www.krakend.io/docs/endpoints/debug-endpoint/</link>
      <pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/debug-endpoint/</guid>
      <description>The /__debug endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description>
    </item>
    
    <item>
      <title>Revoking valid tokens</title>
      <link>https://www.krakend.io/docs/authorization/revoking-tokens/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/authorization/revoking-tokens/</guid>
      <description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke tokens that are supposed to be still valid.
Examples of revoking a valid token could be that an administrator of your application decides that a user can&amp;rsquo;t longer login into the system, or you want to force the renegotiation of the tokens for a subset or all the users because you are not going to wait for the expiration.</description>
    </item>
    
    <item>
      <title>Timeouts</title>
      <link>https://www.krakend.io/docs/throttling/timeouts/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/throttling/timeouts/</guid>
      <description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
 The duration of the whole pipe (from user request to user response) The HTTP request related timeouts  Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description>
    </item>
    
    <item>
      <title>Security</title>
      <link>https://www.krakend.io/docs/endpoints/security/</link>
      <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/security/</guid>
      <description>KrakenD has implemented some security strategies
General security Restrict connections by host Define a whitelist of hosts the KrakenD should accept requests to.
When a request hits KrakenD, it will confirm if the value of the Host HTTP header is in the whitelist. If so, it will further process the request. If the host is not in the whitelist, KrakenD will simply reject the request.
Clickjacking protection KrakenD follow the OWASP&amp;rsquo;s recommendations by adding a frame-breaking strategy.</description>
    </item>
    
    <item>
      <title>Supported backend encodings</title>
      <link>https://www.krakend.io/docs/backends/supported-encodings/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/supported-encodings/</guid>
      <description>KrakenD can parse responses from mixed backends that are using several content types or encodings, such as:
 JSON XML RSS Treat as string  Each backend declaration can set a different encoder to process the responses, and still, KrakenD can transparently work with the mixed content returning a unified encoding in the endpoint.
The following example demonstrates how an endpoint /abc is feeding on three different services and urls /a, /b, and /c and aggregates their responses:</description>
    </item>
    
    <item>
      <title>Caching backend responses</title>
      <link>https://www.krakend.io/docs/backends/caching/</link>
      <pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/backends/caching/</guid>
      <description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description>
    </item>
    
    <item>
      <title>Response content types</title>
      <link>https://www.krakend.io/docs/endpoints/content-types/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/content-types/</guid>
      <description>KrakenD supports sending responses back to the client using content types other than JSON (v0.5 or greater. The list of supported content types depends on the selected router package.
Each endpoint declaration is able to define which encoder should be used, as shown in this example. By default, the KrakenD router will fall back to JSON:
... &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/a&amp;quot;, &amp;quot;output_encoding&amp;quot;: &amp;quot;negotiate&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/a&amp;quot; } ] }, { &amp;quot;endpoint&amp;quot;: &amp;quot;/b&amp;quot;, &amp;quot;output_encoding&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/b&amp;quot; } ] }, { &amp;quot;endpoint&amp;quot;: &amp;quot;/c&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/c&amp;quot; } ] } .</description>
    </item>
    
    <item>
      <title>Sequential Proxy</title>
      <link>https://www.krakend.io/docs/endpoints/sequential-proxy/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/endpoints/sequential-proxy/</guid>
      <description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description>
    </item>
    
    <item>
      <title>Maximum IDLE connections</title>
      <link>https://www.krakend.io/docs/throttling/max-idle-connections/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/throttling/max-idle-connections/</guid>
      <description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... }  KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.</description>
    </item>
    
    <item>
      <title>Flexible configuration</title>
      <link>https://www.krakend.io/docs/configuration/flexible-config/</link>
      <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/configuration/flexible-config/</guid>
      <description>The Flexible Configuration component (source code) is included in the KrakenD API Gateway and allows you to split the configuration file into several pieces for a more natural organization.
When the Flexible Configuration is enabled, KrakenD assumes that your configuration file is a template that needs compilation during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.</description>
    </item>
    
    <item>
      <title>KrakenD vs. KrakenD-CE</title>
      <link>https://www.krakend.io/docs/overview/krakend-vs-krakend-ce/</link>
      <pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/krakend-vs-krakend-ce/</guid>
      <description>If you had a quick look at our git repositories, you might be confused at first, as we have a repository named krakend and another one named krakend-ce.
Difference between KrakenD, KrakenD-CE, and Enterprise TL;DR;
 KrakenD is a framework KrakenD-CE is an API Gateway ready to use KrakenD Enterprise are our professional services to businesses  KrakenD framework KrakenD (repo) is an open-source project created by @devopsfaith to accelerate the creation of custom API Gateways.</description>
    </item>
    
    <item>
      <title>The KrakenD Playground</title>
      <link>https://www.krakend.io/docs/overview/playground/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/playground/</guid>
      <description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description>
    </item>
    
    <item>
      <title>How we run KrakenD on Javascript with WebAssembly</title>
      <link>https://www.krakend.io/blog/krakend-wasm/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-wasm/</guid>
      <description>KrakenD is an API Gateway written in Go that uses a single configuration file to define its whole behavior. As the configuration file might be complicated, the KrakenDesigner is a javascript-based user interface to edit this file, and we were missing the capability of reproducing directly on javascript the existing gateway pipes so that users could run manual tests over the editing configuration.
In this post, we are going to explain how we included KrakenD framework components in a .</description>
    </item>
    
    <item>
      <title>KrakenD 0.7 released</title>
      <link>https://www.krakend.io/blog/krakend-0.7-release-notes/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-0.7-release-notes/</guid>
      <description>The most relevant features for the 0.7 release are increased metrics and tracing options, and functionality that has been requested by many, the sequential proxy merger. During this release, we also updated the KrakenD brand with a new logo, and we added more documentation.
On the metrics side, we can now send structured events using GELF to your Graylog Cluster. Opencensus middleware adds new functionality to push metrics to your Google StackDriver account.</description>
    </item>
    
    <item>
      <title>KrakenD Enterprise</title>
      <link>https://www.krakend.io/enterprise/</link>
      <pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/enterprise/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Krakend 0.6.1 release notes</title>
      <link>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</link>
      <pubDate>Thu, 04 Oct 2018 09:15:49 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</guid>
      <description>The 0.6.1 release adds TLS and enables HTTP2 and HTTPS.
TL;DR This release brings HTTP2 and HTTPS to KrakenD. It also upgrades Go from 1.10 to 1.11 and fixes forwarded query string parameters to backends that are using arrays and repeated variables.
The KrakenDesigner (UI) is also updated to reflect these changes.
KrakenD framework The KrakenD framework has the following relevant changes:
 NEW: Added support for HTTP2/HTTPS FIX: query string parameters works now with arrays and repeated variables (e.</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>https://www.krakend.io/privacy-policy/</link>
      <pubDate>Fri, 14 Sep 2018 20:11:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/privacy-policy/</guid>
      <description>Brutale Engineering S.L. (&amp;ldquo;us&amp;rdquo;, &amp;ldquo;we&amp;rdquo;, or &amp;ldquo;our&amp;rdquo;) operates the http://www.krakend.io website (the &amp;ldquo;Service&amp;rdquo;).
This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data.
We use your data to provide and improve the Service. By using the Service, you agree to the collection and use of information in accordance with this policy.</description>
    </item>
    
    <item>
      <title>KrakenD 0.6 autumn release</title>
      <link>https://www.krakend.io/blog/krakend-0.6-release-notes/</link>
      <pubDate>Fri, 07 Sep 2018 09:18:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-0.6-release-notes/</guid>
      <description>As if we were an agrarian society, our releases keep revolving around the weather calendar seasons. Autumn is around the corner (northern hemisphere), so our release is ready for a cool autumn.
TL;DR This release adds two interesting components: the JOSE component responsible for the JWT signing and validation, and the Cross-origin resource sharing (CORS) component. There is also a Consul client available.
The Krakend Playground and the KrakenDesigner (UI) is also updated.</description>
    </item>
    
    <item>
      <title>Reloading the Krakend configuration with Reflex and Docker</title>
      <link>https://www.krakend.io/blog/reloading-the-krakend-configuration/</link>
      <pubDate>Fri, 22 Jun 2018 11:06:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/reloading-the-krakend-configuration/</guid>
      <description>A recurrent question when we go around is if KrakenD configuration can be hot-reloaded, this is changing endpoints, backends, or any other configuration of the gateway while it&amp;rsquo;s running. The short answer is: No, you can&amp;rsquo;t. You must restart the server. And although we might have something to alleviate this, let us explain first why we don&amp;rsquo;t support such a feature:
 Performance: This is the #1 reason, and strong enough.</description>
    </item>
    
    <item>
      <title>KrakenD 0.5 summer release</title>
      <link>https://www.krakend.io/blog/krakend-0.5-release-notes/</link>
      <pubDate>Fri, 08 Jun 2018 14:50:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-0.5-release-notes/</guid>
      <description>KrakenD 0.5 is out and we want to share some of the cool stuff this release is bringing.
This release focuses heavily on metrics and its export options to different backend systems such as Zipkin, InfluxDB, Prometheus or Jaeger. It also adds the NoOp logger and exposes all the advanced settings of the http client and server, giving all the power to the user. On the middlware side it extends even more the ecosystem with multiple components.</description>
    </item>
    
    <item>
      <title>Running the KrakenD API Gateway on Kubernetes</title>
      <link>https://www.krakend.io/blog/krakend-on-kubernetes/</link>
      <pubDate>Wed, 06 Jun 2018 18:47:03 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-on-kubernetes/</guid>
      <description>In this article we are going to show how to configure and deploy the KrakenD API Gateway in a kubernetes environment.
We will use for the demonstration Minikube so you cant test it in your own local machine.
Let&amp;rsquo;s get started!
Setting up a local Kubernetes We will run Kubernetes locally thanks to Minikube. Just follow the README in the project for the installation and the Quickstart section. Installing minikube it&amp;rsquo;s quick and easy.</description>
    </item>
    
    <item>
      <title>Website development as a sysadmin</title>
      <link>https://www.krakend.io/blog/website-development-as-a-sysadmin/</link>
      <pubDate>Thu, 10 May 2018 16:18:25 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/website-development-as-a-sysadmin/</guid>
      <description>As a systems administrator for the past 15 years, I&amp;rsquo;m not very used to web development as this kind of work has been usually done by other colleagues in every company I&amp;rsquo;ve worked for. I wanted to create a web application myself using an external API, as an exercise to go out my comfort zone.
Some time ago I found that Marvel Comics has a REST API where you can get a lot of information about comics, characters, authors and other interesting information.</description>
    </item>
    
    <item>
      <title>Edge computing - A story of buses, raspberries, IoT and API gateways</title>
      <link>https://www.krakend.io/blog/krakend-on-raspberry/</link>
      <pubDate>Tue, 01 May 2018 21:25:00 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-on-raspberry/</guid>
      <description>The IoT industry has been running for some years now adding millions of devices into the network. The range of devices and capabilities is very wide and heterogeneous, from small devices powered with a 9-volt battery to track the location of freight shippings traveling the oceans (using platforms like Sigfox) to permanently plugged devices with more powerful computing like a Raspberry Pi where computation cycles are not a problem.</description>
    </item>
    
    <item>
      <title>How to work with Golang plugins and KrakenD</title>
      <link>https://www.krakend.io/blog/krakend-golang-plugins/</link>
      <pubDate>Thu, 12 Apr 2018 22:07:03 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-golang-plugins/</guid>
      <description>The release of golang 1.8 more than a year ago opened the door to loading dynamic linked components in run time, and we were keen to find out if we could include this great feature in our KrakenD toolbox.
We&amp;rsquo;d like to share our experience and details on how we enhanced our products to support golang plugins.
Why would anyone use plugins in Go? The plugin concept is widely known and supported in several programming languages and environments.</description>
    </item>
    
    <item>
      <title>Deploying and versioning an API Gateway</title>
      <link>https://www.krakend.io/blog/deploying-an-api-gateway/</link>
      <pubDate>Fri, 06 Apr 2018 23:46:25 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/deploying-an-api-gateway/</guid>
      <description>When it comes to maintaining and deploying an API Gateway within an organization, you should always be aware of best practice. A gateway is an extra step between the client and the servers with the power to define a whole new interface, yet it&amp;rsquo;s so flexible and easy to implement that you might be tempted to start creating API interfaces without thinking about it - and end up creating problems for the future.</description>
    </item>
    
    <item>
      <title>KrakenD 0.4 release notes</title>
      <link>https://www.krakend.io/blog/krakend-0.4-release-notes/</link>
      <pubDate>Sun, 21 Jan 2018 14:50:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/krakend-0.4-release-notes/</guid>
      <description>KrakenD 0.4 materializes the announcement we did 3 months ago by going full open source and public releasing the former enterprise-only components.
This release note comprehends both the KrakenD framework and the KrakenD Community Edition binary distribution.
KrakenD framework The KrakenD framework, engine of the KrakenD API Gateway. The summary of changes introduced in the 0.4 are:
 Removed ALL external dependencies and placed to krakend-contrib repositories Decoder and Service Discovery register system Response metadata Response decoder and formatter exposed Custom status code handler Minor handler optimizations Config version upgraded Server configuration extended (with timeouts and limits) Now non strict REST urls are allowed Request and response manipulation optimized func version for all the interfaces  Link to 0.</description>
    </item>
    
    <item>
      <title>An API Gateway is not the new Unicorn</title>
      <link>https://www.krakend.io/blog/what-is-an-api-gateway/</link>
      <pubDate>Fri, 19 Jan 2018 10:10:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/what-is-an-api-gateway/</guid>
      <description>The more we talk to people about API gateways, the more we have come to realize that the term means different things to different people, and more specifically we see a growing trend where developers (but mostly managers) expect an API gateway to be able to perform miracles, usually a long way away from its intended use.
It&amp;rsquo;s as if the API Gateway is the new unicorn that will solve all problems and make everything wonderful in the microservices scene.</description>
    </item>
    
    <item>
      <title>Road to KrakenD 0.4</title>
      <link>https://www.krakend.io/blog/road-to-0.4/</link>
      <pubDate>Sun, 12 Nov 2017 12:10:53 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/road-to-0.4/</guid>
      <description>The next iteration of KrakenD is right around the corner and the Devops Faith team and the rest of the community we are working together to launch the 0.4 release before end of year. The jump from the 0.3.9 of the binary and the 0.3 of the framework to the 0.4 will bring a lot of interesting stuff but we also need to do a remarkable change in the code for a brighter future: kill external dependencies with fire.</description>
    </item>
    
    <item>
      <title>How we automated our RPM and DEB packaging with Docker</title>
      <link>https://www.krakend.io/blog/automating-linux-packaging/</link>
      <pubDate>Mon, 06 Nov 2017 12:43:33 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/automating-linux-packaging/</guid>
      <description>Everyone loves reaching the maximum number of available platforms for their software but this usually comes at a cost. In this article we will explain how we generated our packaging for Linux in an automated fashion, being faithful to our DevOps dogma.
Dockerize all the things! Our team uses both Ubuntu and MacOS X in desktop machines and KrakenD has been running and behaving in the same way in all the platforms because from day one we decided to run everything on Docker.</description>
    </item>
    
    <item>
      <title>Open sourcing all enterprise components</title>
      <link>https://www.krakend.io/blog/open-sourcing-enterprise-features/</link>
      <pubDate>Sun, 22 Oct 2017 19:01:33 +0200</pubDate>
      
      <guid>https://www.krakend.io/blog/open-sourcing-enterprise-features/</guid>
      <description>What are known today as the KrakenD Enterprise components will be disclosed in the form of open source repositories in the following weeks, and the action has already started, don&amp;rsquo;t miss it! In this post we will explain the reasons behind this decision that might sound crazy from a business perspective in the first place. Why anyone would publish the paid software increment bits of an existing free software?</description>
    </item>
    
    <item>
      <title>Download KrakenD</title>
      <link>https://www.krakend.io/download/</link>
      <pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/download/</guid>
      <description></description>
    </item>
    
    <item>
      <title>KrakenD API Gateway features</title>
      <link>https://www.krakend.io/features/</link>
      <pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/features/</guid>
      <description></description>
    </item>
    
    <item>
      <title>KrakenD support - Have questions?</title>
      <link>https://www.krakend.io/support/</link>
      <pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/support/</guid>
      <description></description>
    </item>
    
    <item>
      <title>KrakenDesigner</title>
      <link>https://www.krakend.io/designer/</link>
      <pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate>
      
      <guid>https://www.krakend.io/designer/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Frequently Asked Questions</title>
      <link>https://www.krakend.io/docs/faq/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/faq/</guid>
      <description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users  Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description>
    </item>
    
    <item>
      <title>Verifying packages (PGP and SHA256)</title>
      <link>https://www.krakend.io/docs/overview/verifying-packages/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/overview/verifying-packages/</guid>
      <description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_0.7.1_amd64.tar.gz.asc krakend_0.7.1_amd64.tar.gz gpg: Signature made vie 02 dic 2016 19:07:49 CET using RSA key ID AB39BEA1 gpg: Can&#39;t check signature: public key not found  We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.krakend.io/docs/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.krakend.io/docs/readme/</guid>
      <description>KrakenD Documentation All the documentation uses Markdown syntax and the site is generated using Hugo. After your contribution this repository will be used to compile all the documentation.
If you want to use a server to browse this pages, although not necessary, you can copy the folder inside the content directory in any Hugo installation.
Contribute! Feel free to fork this repository and contribute to a better KrakenD documentation.</description>
    </item>
    
  </channel>
</rss>