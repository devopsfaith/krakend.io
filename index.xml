<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>High-performance Open Source API Gateway | KrakenD on KrakenD - Open source API Gateway</title><link>https://www.krakend.io/</link><description>Recent content in High-performance Open Source API Gateway | KrakenD on KrakenD - Open source API Gateway</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 30 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v1.3/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v1.4/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/v1.3/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/v1.4/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/v2.1/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/v2.2/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/v2.3/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/v2.4/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.0/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.1/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.2/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.3/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.4/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. To start using your own plugins make sure to write them implementing the right interface and compile them respecting the requirements.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins for understanding the different types of plugins you can use. Plugin requirements Plugin binaries are not cross-platform compatible You must compile the plugin with the same architecture/platform where it will be run.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.0/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. To start using your own plugins make sure to write them implementing the right interface and compile them respecting the requirements.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins for understanding the different types of plugins you can use. Plugin requirements Plugin binaries are not cross-platform compatible You must compile the plugin with the same architecture/platform where it will be run.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.1/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.2/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.4/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v1.3/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v1.3/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v1.4/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.1/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.10/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.2/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.3/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.4/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.5/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.6/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.7/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.8/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/enterprise/v2.9/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.0/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.1/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.10/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.2/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.3/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.4/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.5/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.6/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.7/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.8/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Clustering Deployment Guide</title><link>https://www.krakend.io/docs/v2.9/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD and the hardware or software that will balance the connections.</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend run -c krakend.json # or krakend run --config /path/to/krakend.json # or krakend run --config /path/to/krakend.json -p 8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend run Please, provide the path to your config file Show the help: Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v1.</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/v1.3/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend run -c krakend.json # or krakend run --config /path/to/krakend.json # or krakend run --config /path/to/krakend.json -p 8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend run Please, provide the path to your config file Show the help: Run command help&amp;nbsp; $krakend run -h `7MMF&amp;#39; `YMM&amp;#39; `7MM `7MM&amp;#34;&amp;#34;&amp;#34;Yb.</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/v1.4/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend run -c krakend.json # or krakend run --config /path/to/krakend.json # or krakend run --config /path/to/krakend.json -p 8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend run Please, provide the path to your config file Show the help: Run command help&amp;nbsp; $krakend run -h `7MMF&amp;#39; `YMM&amp;#39; `7MM `7MM&amp;#34;&amp;#34;&amp;#34;Yb.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/injecting-plugins/</guid><description>Your plugin is already developed and ready to use, and now you want to use it. There are two phases:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.0/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/injecting-plugins/</guid><description>Your plugin is already developed and ready to use, and now you want to use it. There are two phases:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.1/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.2/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.3/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.4/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.4/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Designer: The UI configuration editor</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
Combined with a :watch container, you can administer and apply configuration changes automatically in a development environment.
Start a configuration now Automatically applying changes to KrakenD Suppose you have a Chrome, Edge, or Opera desktop browser.</description></item><item><title>Designer: The UI configuration editor</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
Combined with a :watch container, you can administer and apply configuration changes automatically in a development environment.
Start a configuration now Automatically applying changes to KrakenD Suppose you have a Chrome, Edge, or Opera desktop browser.</description></item><item><title>Designer: The UI configuration editor</title><link>https://www.krakend.io/docs/v2.3/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
Combined with a :watch container, you can administer and apply configuration changes automatically in a development environment.
Start a configuration now Automatically applying changes to KrakenD Suppose you have a Chrome, Edge, or Opera desktop browser.</description></item><item><title>Designer: The UI configuration editor</title><link>https://www.krakend.io/docs/v2.4/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
Combined with a :watch container, you can administer and apply configuration changes automatically in a development environment.
Start a configuration now Automatically applying changes to KrakenD Suppose you have a Chrome, Edge, or Opera desktop browser.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Backend data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v2.0/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v2.1/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v2.2/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v2.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Backend data manipulation</title><link>https://www.krakend.io/docs/v2.4/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/v2.2/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/v2.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Flatmap: Array manipulation, object flattening</title><link>https://www.krakend.io/docs/v2.4/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.5/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.6/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.7/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.8/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>API Analytics and Monetization with Moesif</title><link>https://www.krakend.io/docs/enterprise/v2.9/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>gRPC backend client</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/grpc/</guid><description>Consuming content from a gRPC upstream service becomes straightforward through KrakenD and hides all the complexity to consumers.
gRPC is a protocol that creates a channel connection between a client and a server and allows calling methods to send and receive payloads serialized with protocol buffers. With the gRPC integration, KrakenD acts as the gRPC client.
KrakenD supports Unary RPCs requests as a backend but not streaming connections (server, client, or bidirectional streaming), as we don&amp;rsquo;t see fit in the context of an API Gateway.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.10/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero-trust security</title><link>https://www.krakend.io/docs/enterprise/v2.3/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero-trust security</title><link>https://www.krakend.io/docs/enterprise/v2.4/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.5/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.6/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.7/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.8/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/enterprise/v2.9/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.10/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero-trust security</title><link>https://www.krakend.io/docs/v2.3/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero-trust security</title><link>https://www.krakend.io/docs/v2.4/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.5/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.6/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.7/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.8/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Zero Trust Design: Secure API Architecture</title><link>https://www.krakend.io/docs/v2.9/design/zero-trust/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/design/zero-trust/</guid><description>Real-world API deployments suffer daily attacks, even if you don&amp;rsquo;t notice them. It doesn&amp;rsquo;t matter if you have your infrastructure behind a delimited perimeter. Where there is a point of access, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default unless specifically allowed. In zero trust, you verify all requests, regardless of origin, and prove you can trust them. KrakenD both evaluates and enforces rules.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.10/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/enterprise/v2.2/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/enterprise/v2.3/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/enterprise/v2.4/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.5/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.6/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.7/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.8/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.9/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.10/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/v2.2/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/v2.3/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>The Backend For Frontend pattern</title><link>https://www.krakend.io/docs/v2.4/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.5/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.6/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.7/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.8/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Backend-for-Frontend (BFF) Design Pattern</title><link>https://www.krakend.io/docs/v2.9/design/backend-for-frontend/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/design/backend-for-frontend/</guid><description>One of the main differences between KrakenD and any other API gateway in the market is that all your endpoints can offer a ready-to-use Backend For Frontend experience by simply declaring the backend sources and the fields your client needs. But why and when do you need to use a BFF?
The problem a BFF solves When developers of APIs create new endpoints, whether in a microservices pattern or a monolith, using an intermediate gateway or directly connecting to backends, they must provide general-purpose responses.</description></item><item><title>Zero-trust policy</title><link>https://www.krakend.io/docs/v2.2/design/zero-trust/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/design/zero-trust/</guid><description>Real-world API deployments suffer attacks every day, even if you don&amp;rsquo;t notice it. Where there is an accessible server, there is malicious activity.
The Zero Trust security is a software architecture design choice to deny by default any activity unless specifically allowed. This type of policy is very secure, but usually adds a lot of burden on infrastructure administrators. KrakenD offers a balance of tools and default secure choices to ease the administration while keeping the software secure.</description></item><item><title>Body manipulation and generation</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates, and enables injecting other values from the user request such as the original body, headers, querystrings or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Body manipulation and generation</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
To change the router behavior, add the namespace router under the global extra_config. The following example shows how to return the error to the client:</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.0/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
To change the router behavior, add the namespace router under the global extra_config. The following example shows how to return the error to the client:</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.1/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.2/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.3/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case, there is an exception, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.4/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, or remove the requests from the logs, to name a few examples.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.0/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.1/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.2/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.3/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.4/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/api-keys/</guid><description>API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users who do not provide a valid key, users trying to access a resource with insufficient permissions for their role, or exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key authentication using RBAC</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) mechanism by reading the Authorization header of incoming requests. For all your desired endpoints, KrakenD rejects requests from users that do not provide a valid key or are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints and private endpoints in the same configuration.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/v2.1/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/api-keys/</guid><description>API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users who do not provide a valid key, users trying to access a resource with insufficient permissions for their role, or exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/v2.2/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/api-keys/</guid><description>API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users who do not provide a valid key, users trying to access a resource with insufficient permissions for their role, or exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key Authentication in KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/api-keys/</guid><description>API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users who do not provide a valid key, users trying to access a resource with insufficient permissions for their role, or exceeding the defined quota.
The authentication is granular and works per endpoint, meaning you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Analytics</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide krakend-basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v2.1/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v2.2/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Basic Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/basic-authentication/</guid><description>The Basic Authentication functionality protects access to selected endpoints using basic username and password credentials. The functionality works at the router level, and the backend is never hit when the authentication fails.
The plugin version is now deprecated Prior to v2.2, the basic authentication was provided by a plugin. The plugin&amp;rsquo;s usage is still supported for backward compatibility but is considered deprecated. Please follow the steps at the end of this document to upgrade.</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To use any Enterprise binaries, check your inbox and find our license activation email with the license details to activate the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version.
Managing the License Ask for a trial Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v1.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v1.4/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.1/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.2/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.4/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v1.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v1.4/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.5/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Building custom plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v1.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v1.4/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that, when running in conjunction with KrakenD, can participate in the processing. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/v2.10/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/v2.7/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that, when running in conjunction with KrakenD, can participate in the processing. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/v2.8/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that, when running in conjunction with KrakenD, can participate in the processing. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Writing and building custom plugins</title><link>https://www.krakend.io/docs/v2.9/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/writing-plugins/</guid><description>Plugins are soft-linked libraries, thus a separated .so file that can participate in the processing when running in conjunction with KrakenD. When we talk about plugins, we refer to Go plugins. You can create custom code, inject it into different parts of KrakenD processing, and still use the official KrakenD software without forking the code.
Do I need a plugin? In most cases, you don&amp;rsquo;t need a custom plugin. The combination of different functionalities offered by the built-in functionality might help you solve a myriad of scenarios, with special mention to CEL, Martian, or even Lua scripting.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.1/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.10/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.2/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.4/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.5/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.6/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.7/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.8/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JWT Overview - Authorization</title><link>https://www.krakend.io/docs/v2.9/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v1.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v1.4/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.0/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.1/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.2/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.4/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file. Although the configuration supports formats other than JSON and it can be described by multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure:
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v1.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file. Although the configuration supports formats other than JSON and it can be described by multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v1.4/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.0/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.1/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure:
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.10/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.2/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.4/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.5/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.6/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.7/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.8/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Configuration Structure</title><link>https://www.krakend.io/docs/v2.9/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). You&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json, although the configuration supports formats other than JSON and it can be described using multiple files and templates. Being familiar with its structure it&amp;rsquo;s essential.
The correctness of a configuration file is determined by the check and audit commands using different perspectives.
Configuration file structure There are a large number of options you can put in this file.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.2/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.4/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.0/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.1/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.1/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.10/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.2/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.3/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.4/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.5/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.6/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.7/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.8/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/enterprise/v2.9/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.0/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.1/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.10/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.2/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.3/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.4/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.5/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.6/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.7/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.8/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Server Dimensioning for KrakenD API Gateway Deployment</title><link>https://www.krakend.io/docs/v2.9/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/enterprise/v1.3/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/v1.3/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/v1.4/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend check -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v1.</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/v1.3/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend check -h `7MMF&amp;#39; `YMM&amp;#39; `7MM `7MM&amp;#34;&amp;#34;&amp;#34;Yb. MM .M&amp;#39; MM MM `Yb. MM .d&amp;#34; `7Mb,od8 ,6&amp;#34;Yb. MM ,MP&amp;#39;.gP&amp;#34;Ya `7MMpMMMb. MM `Mb MMMMM. MM&amp;#39; &amp;#34;&amp;#39;8) MM MM ;Y ,M&amp;#39; Yb MM MM MM MM MM VMA MM ,pm9MM MM;Mm 8M&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; MM MM MM ,MP MM `MM.</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/v1.4/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend check -h `7MMF&amp;#39; `YMM&amp;#39; `7MM `7MM&amp;#34;&amp;#34;&amp;#34;Yb. MM .M&amp;#39; MM MM `Yb. MM .d&amp;#34; `7Mb,od8 ,6&amp;#34;Yb. MM ,MP&amp;#39;.gP&amp;#34;Ya `7MMpMMMb. MM `Mb MMMMM. MM&amp;#39; &amp;#34;&amp;#39;8) MM MM ;Y ,M&amp;#39; Yb MM MM MM MM MM VMA MM ,pm9MM MM;Mm 8M&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34; MM MM MM ,MP MM `MM.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v1.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v1.4/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v2.0/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/v2.1/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.10/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/v2.2/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/v2.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs others</title><link>https://www.krakend.io/docs/v2.4/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.5/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.6/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.7/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.8/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>API Gateway Benchmarking with KrakenD</title><link>https://www.krakend.io/docs/v2.9/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v1.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v1.4/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.0/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.1/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.10/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.2/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.4/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.5/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.6/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.7/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.8/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Benchmarking KrakenD API Gateway on AWS</title><link>https://www.krakend.io/docs/v2.9/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.10/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.5/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.6/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.7/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.8/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>API Composition and aggregation</title><link>https://www.krakend.io/docs/v2.9/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v1.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/dns-srv/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/v1.3/service-discovery/dns-srv/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/v1.4/service-discovery/dns-srv/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v1.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v1.4/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.0/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.1/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.2/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.4/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/service-discovery/</guid><description>Service discovery (sd) is an attribute in the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.0/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/service-discovery/</guid><description>Service discovery (sd) is an attribute in the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.1/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.2/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.3/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.4/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.10/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.5/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.6/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.7/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.8/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.9/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set a number of maximum requests per second a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/v1.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/v1.4/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.0/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set a number of maximum requests per second a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.1/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.2/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.4/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.0/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.1/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.2/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.3/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.4/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send responses back to the client in a different format than what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/v2.1/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send responses back to the client in a different format than what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/v2.2/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/v2.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/v2.4/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats to what your services provide.</description></item><item><title>Dynamic routing based on headers and query strings</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write directly in the url_pattern the variables that inject the content provided by the user.</description></item><item><title>Dynamic routing by headers and query strings</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write directly in the url_pattern the variables that inject the content provided by the user.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write directly in the url_pattern the variables that inject the content provided by the user.</description></item><item><title>Advanced manipulation with JMESPath</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v1.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v1.4/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.0/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.1/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.10/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.2/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.4/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.5/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.6/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.7/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.8/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>Benchmarking KrakenD API Gateway on a local machine</title><link>https://www.krakend.io/docs/v2.9/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:
$ .</description></item><item><title>API Governance using Quota</title><link>https://www.krakend.io/docs/enterprise/governance/quota/</link><pubDate>Fri, 09 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/governance/quota/</guid><description>The Quota feature allows teams to enforce quota limits by tier, enabling API monetization strategies such as freemium plans, usage-based tiers, and differentiated service levels, but also helps you contain the expenses when using external APIs or AI providers.
The Quota system is equally powerful in egress and ingress scenarios:
On the egress side, organizations can enforce internal consumption controls. For instance, when KrakenD acts as an AI Gateway proxying to LLM models or metered third-party APIs.</description></item><item><title>API Governance using Quota</title><link>https://www.krakend.io/docs/enterprise/v2.10/governance/quota/</link><pubDate>Fri, 09 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/governance/quota/</guid><description>The Quota feature allows teams to enforce quota limits by tier, enabling API monetization strategies such as freemium plans, usage-based tiers, and differentiated service levels, but also helps you contain the expenses when using external APIs or AI providers.
The Quota system is equally powerful in egress and ingress scenarios:
On the egress side, organizations can enforce internal consumption controls. For instance, when KrakenD acts as an AI Gateway proxying to LLM models or metered third-party APIs.</description></item><item><title>Automatically generate boilerplate for Go plugins</title><link>https://www.krakend.io/docs/enterprise/extending/generating-plugins/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/generating-plugins/</guid><description>The command krakend plugin init generates the necessary boilerplate code to start working with plugins. This command provides a structured starting point for plugin development, ensuring that the required interfaces are included from the outset.
By using this command, you can focus on writing the plugin logic without manually creating the files for each possible interface or setting up the build environment. The recommended workflow involves running KrakenD inside a container while mounting the directory where the plugin code will be generated.</description></item><item><title>Automatically generate boilerplate for Go plugins</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/generating-plugins/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/generating-plugins/</guid><description>The command krakend plugin init generates the necessary boilerplate code to start working with plugins. This command provides a structured starting point for plugin development, ensuring that the required interfaces are included from the outset.
By using this command, you can focus on writing the plugin logic without manually creating the files for each possible interface or setting up the build environment. The recommended workflow involves running KrakenD inside a container while mounting the directory where the plugin code will be generated.</description></item><item><title>Automatically generate boilerplate for Go plugins</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/generating-plugins/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/generating-plugins/</guid><description>The command krakend plugin init generates the necessary boilerplate code to start working with plugins. This command provides a structured starting point for plugin development, ensuring that the required interfaces are included from the outset.
By using this command, you can focus on writing the plugin logic without manually creating the files for each possible interface or setting up the build environment. The recommended workflow involves running KrakenD inside a container while mounting the directory where the plugin code will be generated.</description></item><item><title>Redis connection pools for stateful functionality</title><link>https://www.krakend.io/docs/enterprise/service-settings/redis-connection-pools/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/redis-connection-pools/</guid><description>KrakenD&amp;rsquo;s architecture allows developers to define all Redis connections in a single redis namespace, so you can reuse the definitions in other components across the configuration.
You can configure both connection pools and clusters. Whether you use one option or both, each pool and cluster is identified by a unique name that must not clash (make sure of it), which is then referenced by the components requiring a connection. This approach eliminates the need to repeatedly specify Redis connection details in every component configuration.</description></item><item><title>Redis connection pools for stateful functionality</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/redis-connection-pools/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/redis-connection-pools/</guid><description>KrakenD&amp;rsquo;s architecture allows developers to define all Redis connections in a single redis namespace, so you can reuse the definitions in other components across the configuration.
You can configure both connection pools and clusters. Whether you use one option or both, each pool and cluster is identified by a unique name that must not clash (make sure of it), which is then referenced by the components requiring a connection. This approach eliminates the need to repeatedly specify Redis connection details in every component configuration.</description></item><item><title>Redis connection pools for stateful functionality</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/redis-connection-pools/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/redis-connection-pools/</guid><description>KrakenD&amp;rsquo;s architecture allows developers to define all Redis connection pools in a single redis namespace. Each pool is identified by a unique name (make sure of it), which is then referenced by the components requiring a connection. This approach eliminates the need to repeatedly specify Redis connection details in every component configuration.
For example, a Redis connection pool configuration might look like this:
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/v2.8/krakend.json&amp;#34;, &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;redis&amp;#34;: { &amp;#34;connection_pools&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;shared_redis_pool&amp;#34;, &amp;#34;address&amp;#34;: &amp;#34;192.</description></item><item><title>Redis connection pools for stateful functionality</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/redis-connection-pools/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/redis-connection-pools/</guid><description>KrakenD&amp;rsquo;s architecture allows developers to define all Redis connections in a single redis namespace, so you can reuse the definitions in other components across the configuration.
You can configure both connection pools and clusters. Whether you use one option or both, each pool and cluster is identified by a unique name that must not clash (make sure of it), which is then referenced by the components requiring a connection. This approach eliminates the need to repeatedly specify Redis connection details in every component configuration.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/v2.6/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/v2.7/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Telemetry and Monitoring through OpenTelemetry</title><link>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry/</guid><description>OpenTelemetry (for short OTEL) offers a comprehensive, unified, and vendor-neutral approach to collecting and managing telemetry data, providing enhanced observability and deeper insights into application performance and behavior. It&amp;rsquo;s particularly beneficial in complex, distributed, and cloud-native environments.
OpenTelemetry captures detailed, contextual information about the operation of your applications. This includes not only metrics but also tracing data that shows the full lifecycle of requests as they flow through your systems, providing insights into performance bottlenecks, latency issues, and error diagnostics.</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.10/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.3/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.4/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.5/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.6/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.7/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.8/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.9/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.10/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.3/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.4/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.5/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.6/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.7/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.8/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Switching to Community or Enterprise</title><link>https://www.krakend.io/docs/v2.9/faq/switch-versions/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/faq/switch-versions/</guid><description>If you are considering upgrading to KrakenD Enterprise or downgrading to KrakenD Community, these are the things you should have in mind.
Downgrade to Community If you are a KrakenD Enterprise Edition user and you want to switch to the Community Edition, these are the guidelines you should follow to keep your installation working.
Obtain the Community Edition and replace it by the Enterprise one Make the configuration migration as described below Start the server with the modified (if necessary) configuration Configuration migration You can run a configuration file designed for the KrakenD Enterprise in a Community Edition straight away, except if you have one of the following options that you should remove and will make your server panic during startup:</description></item><item><title>Integration with gRPC backends</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/grpc/</guid><description>Consuming content from a gRPC upstream service becomes straightforward through KrakenD and hides all the complexity to consumers.
gRPC is a protocol that creates a channel connection between a client and a server and allows calling methods to send and receive payloads serialized with protocol buffers. With the gRPC integration, KrakenD acts as the gRPC client.
KrakenD supports Unary RPCs requests as a backend but not streaming connections (server, client, or bidirectional streaming), as we don&amp;rsquo;t see fit in the context of an API Gateway.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.2/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.3/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.4/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Guide to check custom KrakenD plugins</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Guide to check custom KrakenD plugins</title><link>https://www.krakend.io/docs/v2.5/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.0/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.1/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.2/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.3/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.4/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.0/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.1/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.2/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.3/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.4/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.0/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.1/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.2/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.3/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.4/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.1/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.2/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.3/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.4/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure ther are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.8/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.9/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.0/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.1/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.10/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.2/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.3/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.4/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.5/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.6/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.7/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.8/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>CI/CD Deployment on the API Gateway</title><link>https://www.krakend.io/docs/v2.9/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safer KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Ensure there are no severe security problems using the audit command.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.11 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.11 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be: FROM krakend/krakend-ee:2.0 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE
Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.1/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.1 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.10/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.10 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.2/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.2 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.3/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.3 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.4/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.4 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.5/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.5 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.6/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.6 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.7/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.7 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.8/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.8 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/enterprise/v2.9/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend/krakend-ee:2.9 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.0/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be: FROM krakend:v2.0 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE
Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.1/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:v2.1 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.10/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.10 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.2/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.2 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.3/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.3 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.4/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.4 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.5/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.5 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.6/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.6 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.7/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.7 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.8/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.8 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Deploying KrakenD API Gateway with Docker</title><link>https://www.krakend.io/docs/v2.9/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROM krakend:2.9 COPY krakend.json /etc/krakend/krakend.json # Uncomment with Enterprise image: # COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.11.1-ee KrakenD is a high-performance API gateway that helps you publish, secure, control, and monitor your services Usage: krakend [command] Available Commands: audit Audits a KrakenD configuration.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.10-ee KrakenD is a high-performance API gateway that helps you publish, secure, control, and monitor your services Usage: krakend [command] Available Commands: audit Audits a KrakenD configuration.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.5 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.6 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.7 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.8 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.9-ee KrakenD is a high-performance API gateway that helps you publish, secure, control, and monitor your services Usage: krakend [command] Available Commands: audit Audits a KrakenD configuration.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.0/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.1/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.2/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.3/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.4/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract. On the other hand, the OpenCensus exporter for InfluxDB is more generalistic and abstract, but implements a collector with less data.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract. On the other hand, the OpenCensus exporter for InfluxDB is more generalistic and abstract, but implements a collector with less data.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract. On the other hand, the OpenCensus exporter for InfluxDB is more generalistic and abstract, but implements a collector with less data.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.0/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Google Analytics</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>Google Analytics</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>Google Analytics</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://domain-a.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/v1.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://domain-a.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v1.4/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.0/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.1/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.10/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.2/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/v2.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.4/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.5/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.6/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.7/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.8/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Cross-Origin Resource Sharing (CORS) Configuration</title><link>https://www.krakend.io/docs/v2.9/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you should enable the Cross-Origin Resource Sharing (CORS) module, as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client and a backend host through the API gateway. This technology aims to provide a mechanism for applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD can work with Websockets using two different strategies:
Using multiplexing (default and recommended) Using direct communication Multiplexing When using multiplexing (the default behavior), each end client (e.</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>KrakenD Enterprise Installation Guide</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the certificates to access the Enterprise content. Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image from Azure or AWS. As the repositories are private, you need to provide the credentials we sent.</description></item><item><title>KrakenD Enterprise Installation Guide</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the certificates to access the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Pre-requisites Part of the private content you will need to run KrakenD Enterprise is stored in AWS or Azure.</description></item><item><title>KrakenD Enterprise Installation Guide</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>KrakenD Enterprise Installation Guide</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>KrakenD Enterprise Installation Guide</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of krakend-metrics with the native krakend-influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard can feed from here and provide you a useful.
InfluxDB configuration Notice that there are two different implementations of InfluxDB in KrakenD that are described in this document:</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.0/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of krakend-metrics with the native krakend-influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard can feed from here and provide you a useful.
InfluxDB configuration Notice that there are two different implementations of InfluxDB in KrakenD that are described in this document:</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.1/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.2/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.4/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/v1.3/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/v1.4/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.10/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.5/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.6/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.7/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.8/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>Debug Endpoint</title><link>https://www.krakend.io/docs/v2.9/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-validation/</guid><description>The component krakend-jose is responsible for the JWT validation and protects endpoints from public usage, requiring end-users to provide a valid token to access its contents.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-validation/</guid><description>The component krakend-jose is responsible for the JWT validation and protects endpoints from public usage, requiring end-users to provide a valid token to access its contents.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.1/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.10/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.2/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP. KrakenD validates every incoming call&amp;rsquo;s signature and it doesn&amp;rsquo;t make token introspection (asking the IdP data about the token owner).</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/v2.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.4/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.5/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.6/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.7/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.8/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Identity Platorm/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v2.9/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, here are some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Descope, Google Identity Platform/Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v2.0/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v2.1/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration file into several pieces for a more natural organization.
When the Flexible Configuration is enabled, KrakenD assumes that your configuration file is a template that needs compilation during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v1.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration file into several pieces for a more natural organization.
When the Flexible Configuration is enabled, KrakenD assumes that your configuration file is a template that needs compilation during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v1.4/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.0/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.1/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.2/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.3/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.4/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v1.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v1.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v1.4/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.10/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.2/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.3/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.4/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.5/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.6/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.7/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.8/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.9/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema (repo) to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.10/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.5/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.6/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.7/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.8/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.9/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.0/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.1/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.10/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.5/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.6/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.7/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.8/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/enterprise/v2.9/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.10/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.10/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.5/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.5/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.6/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.6/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.7/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.7/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.8/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.8/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Data Manipulation</title><link>https://www.krakend.io/docs/v2.9/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the &lt;code>backend&lt;/code> before delivering it to the endpoint to &lt;a href="https://www.krakend.io/docs/v2.9/endpoints/response-manipulation/#aggregation-and-merging">aggregate data from all backends&lt;/a>.&lt;/p></description></item><item><title>Service Discovery with etcd (deprecated)</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/etcd/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/etcd/</guid><description>Deprecated Since KrakenD 1.3.0 etcd is not longer supported. The documentation is left here for reference. The etcd Service Discovery integration allows you to perform the host resolution using your existing etcd setup.
The integration etcd is controlled by the krakend-etcd component and adds client and subscriber capabilities for etcd.
Enabling etcd To enable the integration add in the root of your configuration file the necessary settings:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-etcd&amp;#34;: { &amp;#34;machines&amp;#34;: [ &amp;#34;https://192.</description></item><item><title>Service Discovery with etcd (deprecated)</title><link>https://www.krakend.io/docs/v1.3/service-discovery/etcd/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/etcd/</guid><description>Deprecated Since KrakenD 1.3.0 etcd is not longer supported. The documentation is left here for reference. The etcd Service Discovery integration allows you to perform the host resolution using your existing etcd setup.
The integration etcd is controlled by the krakend-etcd component and adds client and subscriber capabilities for etcd.
Enabling etcd To enable the integration add in the root of your configuration file the necessary settings:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-etcd&amp;#34;: { &amp;#34;machines&amp;#34;: [ &amp;#34;https://192.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v1.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.0/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.1/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.2/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.4/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v1.3/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download KrakenD and Generate the configuration file
Just exploring?
Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API. Everything is ready to start playing, just do a docker compose up!</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v1.4/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download KrakenD and Generate the configuration file
Just exploring?
Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API. Everything is ready to start playing, just do a docker compose up!</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.0/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.1/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.2/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.3/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD API Gateway Installation Guide</title><link>https://www.krakend.io/docs/v2.4/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/v2.6/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/v2.7/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Understanding OpenTelemetry layers and metrics</title><link>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry-layers-metrics/</link><pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry-layers-metrics/</guid><description>You can add several exporters to your OpenTelemetry configuration (the more, the hungrier the gateway will be), and KrakenD will send data to all the declared exporters and layers by default.
While exporters define where you will have the metrics, the layers define which metrics you want to have. The layers contain the traces and metrics for a subset of the execution flow. These are the layers you can use:</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK caching</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK caching</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.10/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK caching</title><link>https://www.krakend.io/docs/v2.3/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK caching</title><link>https://www.krakend.io/docs/v2.4/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.5/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.6/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.7/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.8/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Shared JWK Caching for Authorization</title><link>https://www.krakend.io/docs/v2.9/authorization/jwk-caching/</link><pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/jwk-caching/</guid><description>The JWT validation and JWT signing components do not apply cache by default.
Validating tokens in a high-throughput scenario can be a consuming operation. To refrain the gateway from downloading on each request the signing keys, you can enable caching. It&amp;rsquo;s usually a bad idea to not cache the content of the JWK URL as your identity provider would receive a huge amount of traffic.
Caching does not apply to jwk_local_path When instead of using jwk_url you have the keys on disk and you use jwk_local_path, then you don&amp;rsquo;t need to set any cache at all.</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.10/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/v2.2/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/v2.3/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Security audit of your configuration</title><link>https://www.krakend.io/docs/v2.4/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.5/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.6/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.7/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.8/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Auditing KrakenD API Gateway Configurations</title><link>https://www.krakend.io/docs/v2.9/configuration/audit/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/audit/</guid><description>The krakend audit command is a rule evaluation tool that checks configuration files written in any of its supported formats and returns practical security recommendations. It is designed to raise basic red flags and provide essential advice on your configuration. The output of the configuration and classification is inspired by the CIS Benchmarks.
Security disclaimer If the audit command passes, it does not mean that your API is necessarily secure but that the evaluated rules have passed (find them as recommendations below).</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/telemetry/opentelemetry-by-endpoint/</link><pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but you can override metrics and traces per endpoint and per backend as follows.
Endpoint override of metrics and traces The following example overrides properties that could be declared at the service level.
{ &amp;#34;endpoints&amp;#34;: [ { &amp;#34;endpoint&amp;#34;: &amp;#34;/example&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [ &amp;#34;example.com&amp;#34; ], &amp;#34;url_pattern&amp;#34;: &amp;#34;/example&amp;#34; } ], &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;proxy&amp;#34;: { &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false, &amp;#34;report_headers&amp;#34;: true, &amp;#34;traces_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ], &amp;#34;metrics_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ] } } } } ] } The full list of options is:</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry-by-endpoint/</link><pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but you can override metrics and traces per endpoint and per backend as follows.
Endpoint override of metrics and traces The following example overrides properties that could be declared at the service level.
{ &amp;#34;endpoints&amp;#34;: [ { &amp;#34;endpoint&amp;#34;: &amp;#34;/example&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [ &amp;#34;example.com&amp;#34; ], &amp;#34;url_pattern&amp;#34;: &amp;#34;/example&amp;#34; } ], &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;proxy&amp;#34;: { &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false, &amp;#34;report_headers&amp;#34;: true, &amp;#34;traces_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ], &amp;#34;metrics_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ] } } } } ] } The full list of options is:</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry-by-endpoint/</link><pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but you can override metrics and traces per endpoint and per backend as follows.
Endpoint override of metrics and traces The following example overrides properties that could be declared at the service level.
{ &amp;#34;endpoints&amp;#34;: [ { &amp;#34;endpoint&amp;#34;: &amp;#34;/example&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [ &amp;#34;example.com&amp;#34; ], &amp;#34;url_pattern&amp;#34;: &amp;#34;/example&amp;#34; } ], &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;proxy&amp;#34;: { &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false, &amp;#34;report_headers&amp;#34;: true, &amp;#34;traces_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ], &amp;#34;metrics_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ] } } } } ] } The full list of options is:</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry-by-endpoint/</link><pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but you can override metrics and traces per endpoint and per backend as follows.
Endpoint override of metrics and traces The following example overrides properties that could be declared at the service level.
{ &amp;#34;endpoints&amp;#34;: [ { &amp;#34;endpoint&amp;#34;: &amp;#34;/example&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [ &amp;#34;example.com&amp;#34; ], &amp;#34;url_pattern&amp;#34;: &amp;#34;/example&amp;#34; } ], &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;proxy&amp;#34;: { &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false, &amp;#34;report_headers&amp;#34;: true, &amp;#34;traces_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ], &amp;#34;metrics_static_attributes&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;owner&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;team-charlie&amp;#34; } ] } } } } ] } The full list of options is:</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides some properties that could be declared at the service level, and changes the exporters defined there to use a different set.
While the proxy section can be defined in the Community edition, the exporters_override and backend sections are Enterprise only.</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides some properties that could be declared at the service level, and changes the exporters defined there to use a different set.
While the proxy section can be defined in the Community edition, the exporters_override and backend sections are Enterprise only.</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides properties that could be declared at the service level.
{ &amp;#34;endpoints&amp;#34;: [ { &amp;#34;endpoint&amp;#34;: &amp;#34;/example&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [ &amp;#34;example.com&amp;#34; ], &amp;#34;url_pattern&amp;#34;: &amp;#34;/example&amp;#34; } ], &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;proxy&amp;#34;: { &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false }, &amp;#34;exporters_override&amp;#34;: { &amp;#34;metric_reporting_period&amp;#34;: 10, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;metric_exporters&amp;#34;: [ &amp;#34;local_prometheus&amp;#34; ], &amp;#34;trace_exporters&amp;#34;: [ &amp;#34;debug_jaeger&amp;#34;, &amp;#34;newrelic&amp;#34;, &amp;#34;local_tempo&amp;#34; ] } } } } ] } Exporter names must be typed exactly as in the service level.</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides some properties that could be declared at the service level, and changes the exporters defined there to use a different set.
While the proxy section can be defined in the Community edition, the exporters_override and backend sections are Enterprise only.</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides some properties that could be declared at the service level, and changes the exporters defined there to use a different set.
While the proxy section can be defined in the Community edition, the exporters_override and backend sections are Enterprise only.</description></item><item><title>Granular OpenTelemetry by endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-by-endpoint/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-by-endpoint/</guid><description>The OpenTelemetry configuration is declared at the service level, but in the Enterprise edition you have more granularity and you can override metrics and traces per endpoint and per backend as follows.
Endpoint Override of metrics and traces The following example overrides some properties that could be declared at the service level, and changes the exporters defined there to use a different set.
While the proxy section can be defined in the Community edition, the exporters_override and backend sections are Enterprise only.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>Authenticated metrics to SaaS providers using OTEL</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-security/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opentelemetry-security/</guid><description>The OpenTelemetry Security component allows your KrakenD nodes to push data to a remote collector over the Internet that needs authentication, usually adding a token header.
It allows you to run KrakenD without installing a collector in your infrastructure and push data directly to a SaaS provider, saving time by simplifying the infrastructure needed to monitor the activity.
It combines with the telemetry/opentelemetry configuration and separates the authentication data into a new namespace: telemetry/opentelemetry-security.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v1.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v1.4/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.0/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.1/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.2/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.4/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.5/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and introduces a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable than its open source alternative, but it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref is replaced by the content of the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Extended Flexible Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/flexible-config/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/flexible-config/</guid><description>The Extended Flexible Configuration allows you to express your KrakenD configuration using multiple files, reusing code blocks, and injecting external data through a templates system. It is called &amp;ldquo;Extended&amp;rdquo; because it uses an engine more capable and easier to use than its open source alternative, while it remains 100% compatible.
In its simplest form, you can do things like:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;$ref&amp;#34;: &amp;#34;./service/extra_config.json&amp;#34; } } As you can guess, in the example above, the $ref entry is replaced by the object declared in the external file, much like it works in the JSON Schema specification.</description></item><item><title>Integration with gRPC backends</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/grpc/</guid><description>Consuming content from a gRPC upstream service becomes straightforward through KrakenD and hides all the complexity to consumers.
gRPC is a protocol that creates a channel connection between a client and a server and allows calling methods to send and receive payloads serialized with protocol buffers. With the gRPC integration, KrakenD acts as the gRPC client.
KrakenD supports Unary RPCs requests as a backend but not streaming connections (server, client, or bidirectional streaming), as we don&amp;rsquo;t see fit in the context of an API Gateway.</description></item><item><title>CEL built-in functions and macros</title><link>https://www.krakend.io/docs/enterprise/v2.2/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your security policies or CEL validations.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL built-in functions and macros</title><link>https://www.krakend.io/docs/enterprise/v2.3/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your security policies or CEL validations.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.4/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your security policies or CEL validations.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>Replace content with regular expressions and other functions</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</guid><description>The modifier/response-body allows you to change the content of any desired fields using several modifiers, from regular expression replacement to simpler modifiers like trimming characters or converting the case.
It works by declaring an array of modifiers that KrakenD executes sequentially. You can add multiple modifiers to get the desired output.
The modifiers declare an explicit field where you want to apply the modifications, and the value of these fields must be a string in all cases.</description></item><item><title>Replace content with regular expressions and other functions</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/content-replacer/</guid><description>The modifier/response-body allows you to change the content of any desired fields using several modifiers, from regular expression replacement to simpler modifiers like trimming characters or converting the case.
It works by declaring an array of modifiers that KrakenD executes sequentially. You can add multiple modifiers to get the desired output.
The modifiers declare an explicit field where you want to apply the modifications, and the value of these fields must be a string in all cases.</description></item><item><title>Replace content with regular expressions and other functions</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/content-replacer/</guid><description>The modifier/response-body allows you to change the content of any desired fields using several modifiers, from regular expression replacement to simpler modifiers like trimming characters or converting the case.
It works by declaring an array of modifiers that KrakenD executes sequentially. You can add multiple modifiers to get the desired output.
The modifiers declare an explicit field where you want to apply the modifications, and the value of these fields must be a string in all cases.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file is included in an email with the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start. If KrakenD is running and the license expires, the service shuts down.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE (no extension), and you need to copy it or mount it where KrakenD expects.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.
License file requirements To start KrakenD Enterprise without seeing an error, make sure that:</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/license-file/</guid><description>To run the Enterprise software, you must provide a valid license. The license file comes in an email containing the download link. The file is named LICENSE by default (no extension), although you can change its location and name as long as you let KrakenD know.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
You can run krakend license to see if the installed LICENSE file is valid.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend plugin check command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend plugin check command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend plugin check command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend check-plugin command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/v2.10/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend check-plugin command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/v2.6/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/v2.7/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Check dependencies of plugins</title><link>https://www.krakend.io/docs/v2.8/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/check-plugin/</guid><description>Plugins rely on specific versions of Go, libraries, or system architecture and can face compatibility issues following updates or modifications.
The krakend check-plugin command helps you validate the dependencies used by your plugins, which will determine whether the plugin is compatible, and because of this, you can use the command without providing access to the source code other than the go.sum file.
To get started writing your plugins, see:
Introduction to custom plugins Writing custom plugins Usage of check-plugin The command compares your plugin&amp;rsquo;s go.</description></item><item><title>Checking dependencies of plugins</title><link>https://www.krakend.io/docs/v2.9/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/check-plugin/</guid><description>The Go plugin system requires you to compile the main application and its plugins using the same ecosystem. This means that KrakenD and your plugins must use the same Go version, the same version of any imported libraries, the same system architecture, and the same GLIBC/MUSL libraries. Therefore, knowing in advance that you are using libraries that are incompatible with KrakenD when writing custom plugins is key.
The krakend check-plugin command helps you validate the part of the dependencies used by your plugins, which will determine whether the plugin is compatible.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.10/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.6/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.7/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.8/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Test plugins after compiling them</title><link>https://www.krakend.io/docs/v2.9/extending/test-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/test-plugin/</guid><description>Plugins are essential extensions to the KrakenD gateway, enhancing functionality without modifying the core codebase. Due to their reliance on specific versions of KrakenD, libraries, or system architecture, plugins can face compatibility issues following updates or modifications. So, when you have written a new plugin, and compiled it you still need to see that is loadable into KrakenD.
Recompile plugins when you upgrade KrakenD When you upgrade KrakenD to another version you must recompile your plugins using the builder matching the version.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command starts a a gateway with the provided configuration, and launches all the integration tests in the specs folder. You have a real server running locally that is able to make test in battery and analyze real responses.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command starts a a gateway with the provided configuration, and launches all the integration tests in the specs folder. You have a real server running locally that is able to make test in battery and analyze real responses.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command launches the integration tests.
Creating e2e test files In essence, all you need to do is create a specs folder and place the test files inside.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command launches the integration tests.
Creating e2e test files In essence, you must create a specs folder and place the test files inside.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command launches the integration tests.
Creating e2e test files In essence, you must create a specs folder and place the test files inside.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.0/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.1/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.10/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.2/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.3/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.4/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.5/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.6/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.7/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.8/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.9/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/usage/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/usage/</guid><description>From an operations point of view, KrakenD is very simple to use. It only requires you to pass the path to the configuration file(s) which define behaviors and endpoints.
Make sure KrakenD can find a krakend.json and a LICENSE file. You can create an initial krakend.json with the following content:
Create a minimal configuration file&amp;nbsp; $echo &amp;#39;{ &amp;#34;version&amp;#34;: 2 }&amp;#39; &amp;gt; krakend.json And then run the container (AWS example):
Running KrakenD using the Docker container&amp;nbsp; $docker run -p 8080:8080 -v &amp;#34;$PWD:/etc/krakend/&amp;#34; krakend/krakend-ee:2.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/run/</guid><description>After installing KrakenD, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v2.0 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: check Validates that the configuration file is valid.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/run/</guid><description>After installing KrakenD, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: check Validates that the configuration file is valid.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/run/</guid><description>After installing KrakenD, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.2 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.3 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Running KrakenD Enterprise: Available commands</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/run/</guid><description>After installing KrakenD Enterprise, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.4 KrakenD is a declarative high-performance API gateway that helps you effortlessly adopt microservices Usage: krakend [command] Available Commands: audit Checks the integrity of the config and returns security recommendations.</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.0/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.1/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.2/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.3/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.4/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Telemetry and Monitoring with Grafana in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.1/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.2/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.3/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.4/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.5/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.0/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.1/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.2/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.4/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/v2.10/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/v2.6/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/v2.7/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/v2.8/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>Prometheus' metrics endpoint</title><link>https://www.krakend.io/docs/v2.9/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/prometheus/</guid><description>Prometheus is an open-source system monitoring and alerting toolkit that you can use to scrape a /metrics endpoint on KrakenD in the selected port. For instance, you could have an endpoint like http://localhost:9091/metrics.
When using Prometheus with OpenTelemetry, you can use a ready-to-use Grafana dashboard to visualize metrics, as shown in the image above.
The mechanics are simple: you add the telemetry/opentelemetry integration with a prometheus exporter, and then you add a Prometheus job to scrape from your KrakenD instances the metrics.</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) If you want to enable TLS, add a tls key at the service level (configuration&amp;rsquo;s file root) with at least the public and private keys. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.0/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.1/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.10/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.2/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) If you want to enable TLS, add a tls key at the service level (configuration&amp;rsquo;s file root) with at least the public and private keys. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.4/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.5/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.6/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.7/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.8/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properies tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>TLS Configuration</title><link>https://www.krakend.io/docs/v2.9/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/tls/</guid><description>The TLS settings define the parameters that the gateway takes into account to handle incoming and outgoing HTTPS traffic. We refer to this as:
tls: TLS settings, or how the gateway handles incoming traffic as a server. client_tls: Client TLS settings, or how the gateway connects to your upstream services Independent properties The properties tls and client_tls are independent of each other. You can declare one, both, or none. TLS server settings There are two different strategies when using TLS over KrakenD:</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.5/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.10/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.5/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.6/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.7/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.8/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Echo Endpoint Configuration</title><link>https://www.krakend.io/docs/v2.9/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/v2.1/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.10/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/v2.2/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/v2.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/v2.4/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.5/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.6/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.7/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.8/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.9/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: template-based config</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: template-based config</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.10/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: template-based config</title><link>https://www.krakend.io/docs/v2.2/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: template-based config</title><link>https://www.krakend.io/docs/v2.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration</title><link>https://www.krakend.io/docs/v2.4/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.5/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.6/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.7/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.8/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Flexible Configuration: A template-based config for API Gateway</title><link>https://www.krakend.io/docs/v2.9/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/flexible-config/</guid><description>The Flexible Configuration allows you to declare the configuration using multiple files and use a templates system, opening the door to multi-environment configurations and code reuse.
The Flexible Configuration enables a template processor based on Go templates and is enriched with Sprig functions and KrakenD functions.
You can encode your configuration files in any of the supported formats (json, yaml, toml, etc.), as the template is agnostic of its contents.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy. You need to define what is allowed because KrakenD does not forward any unexpected query string, headers, or cookies. See below for instructions on how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends. To do that, add the following configuration options under your endpoint definition:</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy. You need to define what is allowed because KrakenD does not forward any unexpected query string, headers, or cookies. See below for instructions on how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends. To do that, add the following configuration options under your endpoint definition:</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy. You need to define what is allowed because KrakenD does not forward any unexpected query string, headers, or cookies. See below for instructions on how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends. To do that, add the following configuration options under your endpoint definition:</description></item><item><title>Parameter Forwarding in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.10/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy. You need to define what is allowed because KrakenD does not forward any unexpected query string, headers, or cookies. See below for instructions on how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends. To do that, add the following configuration options under your endpoint definition:</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.5/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.6/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.7/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.8/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter Forwarding</title><link>https://www.krakend.io/docs/v2.9/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust security policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/v1.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/v1.4/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.1/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.10/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.2/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.4/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.5/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.6/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.7/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.8/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.9/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.0/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.1/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.10/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.2/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion: apps/v1 kind: Deployment metadata: name: krakend-deployment spec: selector: matchLabels: app: krakend replicas: 2 template: metadata: labels: app: krakend spec: containers: - name: krakend image: YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.4/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.5/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.6/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.7/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.8/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/docs/v2.9/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Run as user 1000 Whether you run KrakenD on Kubernetes, OpenShift, or any other platform with the capability to run the container as a specific user UID, make sure you use the UID 1000 Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.0/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.1/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.2/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.3/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.4/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend run -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Using KrakenD</title><link>https://www.krakend.io/docs/v1.3/overview/usage/</link><pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/usage/</guid><description>From an operations point of view KrakenD, is very simple to use. It only requires you to pass the path the configuration file (which defines behaviors and endpoints). Additionally, you can enable the debug with the -d flag, and that&amp;rsquo;s pretty much everything.
TL;DR Generate a configuration file with your endpoints definition. The easier way to generate it is using the designer Check the syntax of your krakend.json is good Syntax checking&amp;nbsp; $krakend check --config krakend.</description></item><item><title>Using KrakenD</title><link>https://www.krakend.io/docs/v1.4/overview/usage/</link><pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/usage/</guid><description>From an operations point of view KrakenD, is very simple to use. It only requires you to pass the path the configuration file (which defines behaviors and endpoints). Additionally, you can enable the debug with the -d flag, and that&amp;rsquo;s pretty much everything.
TL;DR Generate a configuration file with your endpoints definition. The easier way to generate it is using the designer Check the syntax of your krakend.json is good Syntax checking&amp;nbsp; $krakend check --config krakend.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v1.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v1.4/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.0/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.1/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.2/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.4/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/v1.3/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/v1.4/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v1.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v1.4/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.0/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.1/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.2/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.10/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.5/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.6/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.7/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.8/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Introduction to Templates</title><link>https://www.krakend.io/docs/v2.9/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Templates</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Templates</title><link>https://www.krakend.io/docs/v2.4/configuration/templates/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/templates/</guid><description>There are several components and features in KrakenD that allow you to define configurations or content manipulations using templates.
Whether you are using templates with flexible configuration, a Request generator or Response manipulation the syntax you use is the same, and it&amp;rsquo;s based on Go templates (as Helm, Kubernetes, and many other systems).
Our convention for saving templates, is using the .tmpl extension, although this is not enforced. This document provides a few direction to use templates.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will start anyway.
The message you will see when the server starts with an invalid or missing license file is:
Term&amp;nbsp; $krakend run -dec krakend.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will start anyway.
The message you will see when the server starts with an invalid or missing license file is:
Term&amp;nbsp; $krakend run -dec krakend.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will start anyway.
The message you will see when the server starts with an invalid or missing license file is:
Term&amp;nbsp; $krakend run -dec krakend.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will try to start anyway using the open source engine, and without loading any Enterprise functionality.
The message you will see when the server starts with an invalid or missing license file is:</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is expired, incorrect, or missing, KrakenD won&amp;rsquo;t start.
License file requirements To start KrakenD Enterprise without seeing the message above, make sure that:
The file /etc/krakend/LICENSE exists The LICENSE file is a plain text file with no extension It contains the certificate we gave you (it looks like a PEM file) The file includes the surrounding -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----, and you have not deleted any dash or character accidentally, neither you have deleted the line breaks.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/plugins/</guid><description>Some of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. Although functionality offered as plugins is decreasing, it&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them. For each functionality of Enterprise offered as a plugin, you will see in its documentation how to use it.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.</description></item><item><title>The `/__debug` endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</guid><description>The /__debug endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v1.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v1.4/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.0/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.1/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.2/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.4/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend if you use as host KrakenD itself, and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:</description></item><item><title>The `/__echo/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>The `/__echo/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>The `/__echo/` endpoint</title><link>https://www.krakend.io/docs/v2.3/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>The `/__echo/` endpoint</title><link>https://www.krakend.io/docs/v2.4/endpoints/echo-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/echo-endpoint/</guid><description>The /__echo/ endpoint is a developer tool to help you debug configurations. It works similarly to the /__debug/ endpoint, but instead of printing the requests in the log and returning a {&amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;}, they are printed in the response. It replies with an object containing all the request details, and you can use it as an endpoint or backend. As KrakenD has a zero-trust approach, you will find out the exact information that passes through in this endpoint.</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.10/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.4/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.5/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.6/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.7/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.8/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>Supported Configuration Formats</title><link>https://www.krakend.io/docs/v2.9/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse any of these file formats:
.json (recommended) .toml .yaml .yml .properties .props .prop .hcl You can validate the syntax of any of these with krakend check
Why is JSON recommended? You are free to choose json, yaml, toml or any of the other formats listed above at your best convenience. But have in mind the following limitations when choosing a file format that is not json:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>gRPC client and gRPC to REST conversion</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/grpc/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/grpc/</guid><description>The gRPC client integration allows KrakenD to connect to upstream services using gRPC. If you haven&amp;rsquo;t enabled the gRPC server functionality, then the content is automatically transformed to a regular REST API, as shown in the picture.
If, on the other hand, you enable a gRPC server, then you can have a gRPC-to-gRPC communication.
gRPC client configuration To use the gRPC client, you must declare two extra configuration entries in the settings:</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.10/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.5/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.6/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.7/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.8/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>API Configuration Designer</title><link>https://www.krakend.io/docs/v2.9/configuration/designer/</link><pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/designer/</guid><description>The Designer is a UI that allows you to create KrakenD configurations from scratch or resume editing an existing one. It is a tool very useful in your early contact with KrakenD, as it helps you try functionalities without having to learn the different attributes of the configuration.
The designer is a learning tool more than an administration one. KrakenD configuration and administration is designed with GitOps in mind (under the version control system and released through CI/CD).</description></item><item><title>Advanced macros</title><link>https://www.krakend.io/docs/enterprise/v2.2/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced macros</title><link>https://www.krakend.io/docs/enterprise/v2.3/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.4/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.2/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.3/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.4/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language (JMESPath)</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.10/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.6/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.7/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.8/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashbaord using Prometheus as data source:</description></item><item><title>Telemetry and Monitoring with Grafana</title><link>https://www.krakend.io/docs/v2.9/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Latencies Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera The following video makes a quick tour of the information you can find on our Grafana Dashboard using Prometheus as data source:</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables must have the prefix KRAKEND_ and declared in uppercase. The variable name after the prefix must match the property in the configuration value.
For instance, take the following krakend.json configuration as an example:</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override existing values in the configuration. There are two different ways of injecting environment vars.
The key to override must exist in the configuration The environment variables are meant to replace existing attributes in the configuration. Therefore, you cannot set new parameters that do not exist in the configuration. First level properties You can override its value with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env}} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env}} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Environment Variables in KrakenD API Gateway Configuration</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v1.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables must have the prefix KRAKEND_ and declared in uppercase. The variable name after the prefix must match the property in the configuration value.
For instance, take the following krakend.json configuration as an example:</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v1.4/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables you can inject a value in the configuration when the server starts. There are two different ways of injecting environment vars.
First level properties For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables that you want to set using environment variables, pass them with a prefix KRAKEND_.</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v2.0/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override existing values in the configuration. There are two different ways of injecting environment vars.
The key to override must exist in the configuration The environment variables are meant to replace existing attributes in the configuration. Therefore, you cannot set new parameters that do not exist in the configuration. First level properties You can override its value with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/v2.1/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.10/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/v2.2/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/v2.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env}} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/v2.4/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env}} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.5/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.6/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.7/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.8/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Environment variables in the configuration</title><link>https://www.krakend.io/docs/v2.9/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/environment-vars/</guid><description>When KrakenD runs (whether with run or check), all the behavior is loaded from the configuration file. Through environment variables, you can also set values. There are two different ways of injecting environment vars:
Use a KRAKEND_-like reserved environment variable: To override values set in the configuration. Set your own environment variables when using the {{env}} function in flexible configuration templates. Use a reserved environment variable There are a group of reserved environment variables that are automatically recognized by KrakenD when set.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v1.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.0/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.1/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.2/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.4/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v1.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v1.4/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.0/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.1/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.2/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.4/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.10/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.5/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.6/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.7/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.8/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.9/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.10/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.6/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.7/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.8/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Injecting Plugins into KrakenD API Gateway - Extensibility Guide</title><link>https://www.krakend.io/docs/v2.9/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v1.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v1.4/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.0/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.1/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.10/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.2/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.4/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.5/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.6/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.7/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.8/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>Token Revocation</title><link>https://www.krakend.io/docs/v2.9/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
Revoke tokens via API The Enterprise version offers a Revoke Server that coordinates token revokes in a cluster using a REST API. When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Global timeout The timeout key in the krakend.json at the root level is used in the first place to apply a default timeout for the whole duration of the pipe (and not only the connection to the backends).</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v1.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v1.4/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.0/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Global timeout The timeout key in the krakend.json at the root level is used in the first place to apply a default timeout for the whole duration of the pipe (and not only the connection to the backends).</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.1/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.2/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.4/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.0/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.1/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.10/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.2/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.4/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.5/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.6/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.7/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.8/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security Considerations</title><link>https://www.krakend.io/docs/v2.9/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via the security/http component. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/v1.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/v1.4/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v1.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.0/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case. Unknown values for encoding or no value at all, is treated as json.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.1/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.2/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.4/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Revoke Server for cluster-wide management of token revocations</title><link>https://www.krakend.io/docs/enterprise/v2.1/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Revoke Server for cluster-wide management of token revocations</title><link>https://www.krakend.io/docs/enterprise/v2.2/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>Revoke Server for clusters</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. You no longer need to know how many KrakenDs are running using the Revoke Server and interact with them individually.</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/v2.10/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/v2.6/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/v2.7/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/v2.8/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>gRPC Server</title><link>https://www.krakend.io/docs/enterprise/v2.9/grpc/server/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/grpc/server/</guid><description>The gRPC server integration allows you to expose an additional gRPC service under the same HTTP port. The gRPC service can consume data from mixed upstream services, whether they are also gRPC, HTTP, Lambdas, queues, or any other supported type.
Due to its nature, when you access the gateway through gRPC, you cannot use HTTP components in the user request (but you can work with the HTTP layer when connecting to your services).</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Response manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/response-body-generator/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/response-body-generator/</guid><description>The response body generator lets you write a whole new payload using a template that has access to all the response data. In addition to the payload from the backend, you can incorporate other information such as headers, status codes, query strings, or URL parameters.
You can add validations, data transformation, and other valuable operations as you work with a template.
Modify the body with templates The modifier/response-body-generator lets you change the content from a backend response or the aggregated result after merging in an endpoint.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.1/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.2/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.3/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.4/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.0/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.1/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.2/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.3/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.4/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to. Recommended value is in the range 1024-65535 to run as an unpriviliged user.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to. Recommended value is in the range 1024-65535 to run as an unpriviliged user.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.0/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to. Recommended value is in the range 1024-65535 to run as an unpriviliged user.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.1/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.10/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.2/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.3/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.4/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.5/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.6/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.7/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "false" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.8/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>HTTP Server Settings</title><link>https://www.krakend.io/docs/v2.9/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Fields of "_root" * required fields cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Generate documentation using OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/openapi/</guid><description>The OpenAPI or Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of API documentation through a static Swagger file.
For an OpenAPI specification with detailed fields of backend responses (an information the gateway does not have), use the OpenAPI generator in the KrakenD Studio as is capable of providing in-depth detail of backend responses in the documentation through inspection of live requests.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/openapi/</guid><description>The OpenAPI generators are command-line utilities embedded in the KrakenD binary, offering OpenAPI import and export capabilities. The OpenAPI generator allows you to:
Export to OpenAPI: From an existing KrakenD configuration, you can automatically generate the API documentation in OpenAPI format. Import from OpenAPI: From an existing OpenAPI spec, you can generate the initial KrakenD configuration to start working. The OpenAPI-supported version is Swagger v2 (not OAS3) in both functionalities.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/openapi/</guid><description>The OpenAPI generators are command-line utilities embedded in the KrakenD binary, offering OpenAPI import and export capabilities. The OpenAPI generator allows you to:
Export to OpenAPI: From an existing KrakenD configuration, you can automatically generate the API documentation in OpenAPI format. Import from OpenAPI: From an existing OpenAPI spec, you can generate the initial KrakenD configuration to start working. The OpenAPI-supported version is Swagger v2 (not OAS3) in both functionalities.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/openapi/</guid><description>The OpenAPI generator is a command-line utility embedded in the KrakenD binary, offering OpenAPI import and export capabilities (for both Swagger v2 and OAS3). The OpenAPI generator allows you to generate the documentation from a KrakenD configuration or a KrakenD configuration from an existing OpenAPI.
The generate openapi creates OpenAPI documentation when you have a KrakenD configuration. The generate from openapi creates a KrakenD configuration from an OpenAPI specification file. Switching to OAS 3 The input and output used by default is Swagger v2, as a measure to keep backwards compatibility with all existing customers.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>OpenAPI Integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by multiple Identity Providers.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. There are times when tokens arriving at an endpoint originate in different providers or different tenants. This is especially true in multi-tenant scenarios, or where there is an ongoing migration, or when different systems converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers (or realms)</title><link>https://www.krakend.io/docs/enterprise/v2.1/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, there are times when tokens arriving at an endpoint originate in different providers or different tenants or realms. This is especially true in multi-tenant scenarios, where an ongoing migration or other systems converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers (or realms)</title><link>https://www.krakend.io/docs/enterprise/v2.2/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server. The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, there are times when tokens arriving at an endpoint originate in different providers or different tenants or realms.</description></item><item><title>Validate tokens from multiple providers/realms</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, there are times when tokens arriving at an endpoint originate in different providers or different tenants or realms. This is especially true in multi-tenant scenarios, where an ongoing migration or other systems converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, there are times when tokens arriving at an endpoint originate in different providers or different tenants or realms. This is especially true in multi-tenant scenarios, where an ongoing migration or other systems converge into the gateway.</description></item><item><title>Multiple Identity Providers in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, there are times when tokens arriving at an endpoint originate in different providers or different tenants or realms. This is especially true in multi-tenant scenarios, where an ongoing migration or other systems converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by numerous Identity Providers or multiple realms of the same Identity Server.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. However, sometimes, tokens arriving at an endpoint originate in different providers or, tenants or realms. It might be because you have a multi-tenant scenario, an ongoing migration, or other systems that converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/multiple-identity-providers/</guid><description>This plugin allows KrakenD to validate tokens issued by multiple Identity Providers.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. There are times when tokens arriving at an endpoint originate in different providers or different tenants. This is especially true in multi-tenant scenarios, or where there is an ongoing migration, or when different systems converge into the gateway. The KrakenD krakend-jwk-aggregator allows you to alleviate this issue.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.509 authentication certificate. KrakenD relies on the system&amp;rsquo;s CA to validate certificates.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Mutual Authentication in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v1.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v1.4/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.0/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.1/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.10/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.2/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.4/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.5/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.6/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.7/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.8/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>Mutual Authentication</title><link>https://www.krakend.io/docs/v2.9/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/mutual-authentication/</guid><description>mTLS is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
As KrakenD is a piece of software in the middle of two parts, there are different types of mTLS supported, that can work together or separately.
Service mTLS: When you require end-users to provide a certificate to connect to KrakenD. Client mTLS: When you require KrakenD to provide a certificate to connect to your services.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>InfluxDB Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads and allows you to store and visualize metrics data. Influx is offered as an open-source solution you can host but also as a cloud service.
Native influx component Before KrakenD v2.6, the only option to push data to Influx was configuring the native exporter telemetry/influx. Although the component is development-frozen in favor of OTEL, you can still use it as described in the Metrics API.</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v1.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.0/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.1/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.2/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.4/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v1.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v1.4/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.0/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.1/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.2/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.4/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/v1.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/v1.4/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.0/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.1/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.10/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.2/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.4/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.5/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.6/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.7/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.8/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Client Credentials Authorization</title><link>https://www.krakend.io/docs/v2.9/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. This token is passed in the &amp;ldquo;Authorization&amp;rdquo; header. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the qos/httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v1.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v1.4/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.0/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the qos/httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.1/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.2/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.4/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.10/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.5/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.6/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.7/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.8/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>KrakenD API Gateway Playground</title><link>https://www.krakend.io/docs/v2.9/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always return a response in JSON format to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client. This is the default encoding if none is declared.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v1.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always return a response in JSON format to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v1.4/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client. This is the default encoding if none is declared.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v2.0/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client. This is the default encoding if none is declared.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Dynamic Routing in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write directly in the url_pattern the variables that inject the content provided by the user.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Dynamic Routing</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/dynamic-routing/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/dynamic-routing/</guid><description>The dynamic routing extends the routing capabilities to add header, tokens, and query string processing to assemble the final upstream URL you want to reach. In addition, it allows you to convert headers to query strings and enforce the existence of parameters on the request.
To enable dynamic routing, you don&amp;rsquo;t need to add any specific extra entry in the configuration. Instead, write the variables that inject the content provided by the user directly in the url_pattern or inside a host entry.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.0/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.1/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.2/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.3/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.4/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections. The generation of Postman collections is also available in KrakenD Studio.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend generate postman -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v1.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend generate postman -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: v2.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend generate postman -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: Generates the Postman descriptor for the gateway based on the configuration file.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend generate postman -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend generate postman -h ╓▄█ ▄▄▌ ╓██████▄µ ▐███ ▄███╨▐███▄██H╗██████▄ ║██▌ ,▄███╨ ▄██████▄ ▓██▌█████▄ ███▀╙╙▀▀███╕ ▐███▄███▀ ▐█████▀&amp;#34;╙▀▀&amp;#34;╙▀███ ║███▄███┘ ███▀&amp;#34;&amp;#34;▀███ ████▀╙▀███H ███ ╙███ ▐██████▌ ▐███⌐ ,▄████████M║██████▄ ║██████████M███▌ ███H ███ ,███ ▐███╨▀███µ ▐███ ███▌ ,███M║███╙▀███ ███▄```▄▄` ███▌ ███H ███,,,╓▄███▀ ▐███ ╙███▄▐███ ╙█████████M║██▌ ╙███▄`▀███████╨ ███▌ ███H █████████▀ `` `&amp;#39;` Version: 2.</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v1.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v1.4/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.0/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/opencensus/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/opencensus/</guid><description>OpenCensus is no longer maintained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now is transitioning to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer maintained, and all efforts are focused on OpenTelemetry.
The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>OpenCensus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is. Without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v1.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v1.4/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.0/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is. Without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.1/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.2/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.4/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v1.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v1.4/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.0/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.1/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.2/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.4/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v1.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.0/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.1/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.2/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.4/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.
Every ecosystem needs its own setting, have this in mind:</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/v1.3/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.
Every ecosystem needs its own setting, have this in mind:</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/v1.4/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.
Every ecosystem needs its own setting, have this in mind:</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile to immediately render it to a png image.
The following image illustrates an example of a KrakenD configuration:
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>OpenCensus Agent Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>OpenCensus Agent</title><link>https://www.krakend.io/docs/v2.5/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/ocagent/</guid><description>OpenCensus is no longer mantained KrakenD has traditionally offered its telemetry integration through this OpenCensus component, which has provided reliable service for over six years, but now has transitioned to the more modern and robust OpenTelemetry framework.
As a result of a change in the industry, the OpenCensus integration is no longer mantained, we recommend you to migrate to OpenTelemetry.
The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you push data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port on which Prometheus is running, the namespace (optional), and Prometheus will start receiving the data.
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } port on which Prometheus is listening namespace sets the domain the metric belongs to.</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data. { &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v1.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you push data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port on which Prometheus is running, the namespace (optional), and Prometheus will start receiving the data.
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } port on which Prometheus is listening namespace sets the domain the metric belongs to.</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v1.4/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus will start receiving the data. { &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.0/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data. { &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.1/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.2/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.4/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response, although it can be used for objects as well. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v1.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v1.4/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v2.0/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v2.1/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response, although it can be used for objects as well. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v1.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v1.4/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.0/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.1/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.2/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.4/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; }, } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v1.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; } } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v1.4/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; } } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>KrakenD API Gateway - Prometheus Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>KrakenD API Gateway - Prometheus Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/v1.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/v1.4/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in adding more traffic to your backends.
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.0/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in adding more traffic to your backends.
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.1/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.2/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.4/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
The Sequential Proxy enables chaining multiple backend requests where the output of one call is used as input for the next, whether just injecting previous values of the response in the URL or as the body for the next call.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
The Sequential Proxy enables chaining multiple backend requests where the output of one call is used as input for the next, whether just injecting previous values of the response in the URL or as the body for the next call.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
The Sequential Proxy enables chaining multiple backend requests where the output of one call is used as input for the next, whether just injecting previous values of the response in the URL or as the body for the next call.</description></item><item><title>Sequential Proxying in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.10/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
The Sequential Proxy enables chaining multiple backend requests where the output of one call is used as input for the next, whether just injecting previous values of the response in the URL or as the body for the next call.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.5/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.6/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.7/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.8/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Sequential Proxying</title><link>https://www.krakend.io/docs/v2.9/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends simultaneously. However, sometimes you need to delay a backend call until you have called a previous service. Although this is not ideal, the sequential proxy allows you to chain backend requests.
Do you really need a sequential proxy? Chained calls are considered an anti-pattern Using sequential calls is considered an anti-pattern because when you make a network service dependent on the other, you are increasing the latency, decreasing the performance, and augmenting the error rate.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.1/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.2/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.3/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.4/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.0/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.1/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.10/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.2/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.3/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.4/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.5/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.6/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.7/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.8/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot Reload Feature</title><link>https://www.krakend.io/docs/v2.9/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/developer/hot-reload/</guid><description>The Docker tag :watch is a development-phase image that allows you to restart KrakenD automatically after saving or changing files inside the configuration folder, although is not recommended for production workloads. It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The watch is a regular KrakenD binary wrapped in a reflex watcher. When it detects that any piece inside the configuration has changed, it restarts the service, applying the changes.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v1.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v1.4/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.0/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.1/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.2/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.4/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Conditional Routing</title><link>https://www.krakend.io/docs/enterprise/backends/conditional/</link><pubDate>Wed, 10 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/conditional/</guid><description>The Conditional Routing feature enables dynamic backend or multi-backend selection based on request headers (including propagated JWT claims) or custom policy expressions. This functionality enhances flexibility and operational control for complex routing scenarios, including AI/LLM integrations, feature flags, and multi-tenant APIs, among others, without requiring the use of Security Policies or raising errors in the log.
The functionality checks if a specific rule is met before executing a backend, and if it is not, it is skipped from the list.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Google Cloud service-to-service authentication</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/gcloud/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/gcloud/</guid><description>KrakenD supports the three different service-to-service authentication mechanisms Google Cloud provides: Service Accounts (this page), OAuth 2.0, and Mutual TLS Authentication.
A service account is a special type of Google account that belongs to an application or a virtual machine. Service accounts are used to authenticate requests to Google Cloud APIs and services or when connecting to your Google Cloud Run services if you added an option &amp;ldquo;Require Authentication&amp;rdquo;.
When KrakenD requests a Google Cloud resource, Google Cloud checks the IAM policy associated with the resource to determine whether it has the necessary permissions to access the resource.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Virtual Hosts in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host used to access the server.
For instance, you can declare different endpoint configurations for a path /foo that is accessed through abcd.example.com/foo or efgh.example.com/foo. These two could have different rate limits or authorization rules, for example.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config and declare the host names that you will recognize.</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } }</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using a Collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;service_name&amp;#34;: &amp;#34;krakend_service&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1, &amp;#34;@comment&amp;#34;: &amp;#34;Report 20% of traces&amp;#34;, &amp;#34;trace_sample_rate&amp;#34;: 0.2, &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;my_datadog_agent&amp;#34;, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;port&amp;#34;: 8126, &amp;#34;use_http&amp;#34;: false } ] } } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v1.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v1.4/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.0/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } }</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.1/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.2/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.4/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires adding the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using a Collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;service_name&amp;#34;: &amp;#34;krakend_service&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1, &amp;#34;@comment&amp;#34;: &amp;#34;Report 20% of traces&amp;#34;, &amp;#34;trace_sample_rate&amp;#34;: 0.2, &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;my_datadog_agent&amp;#34;, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;port&amp;#34;: 8126, &amp;#34;use_http&amp;#34;: false } ] } } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Datadog Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
The OpenTelemetry integration allows you to send metrics and traces to Datadog using their collector.
Datadog configuration Datadog uses the standard OTLP exporter, here is a configuration example:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;$schema&amp;#34;: &amp;#34;https://www.krakend.io/schema/krakend.json&amp;#34;, &amp;#34;host&amp;#34;: [ &amp;#34;http://localhost:8080&amp;#34; ], &amp;#34;debug_endpoint&amp;#34;: true, &amp;#34;echo_endpoint&amp;#34;: true, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opentelemetry&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;otlp&amp;#34;: [ { &amp;#34;use_http&amp;#34;: false, &amp;#34;port&amp;#34;: 4317, &amp;#34;host&amp;#34;: &amp;#34;ddagent&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;my_dd_exporter&amp;#34;, &amp;#34;disable_metrics&amp;#34;: false, &amp;#34;disable_traces&amp;#34;: false } ] }, &amp;#34;trace_sample_rate&amp;#34;: 1, &amp;#34;service_name&amp;#34;: &amp;#34;krakend_dd_telemetry&amp;#34;, &amp;#34;metric_reporting_period&amp;#34;: 1 } } } The important part of the configuration is the otlp exporter, which accepts the following fields:</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/v1.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/v1.4/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.0/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.1/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.2/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.4/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } }
collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v1.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v1.4/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.0/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } }
collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.1/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.2/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.4/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/v1.3/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/v1.4/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.0/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.1/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.2/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.3/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.4/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.0/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.1/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.2/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.3/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.4/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AI Security</title><link>https://www.krakend.io/docs/ai-gateway/security/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/ai-gateway/security/</guid><description>Protecting sensitive AI data and controlling access is essential for trustworthy AI workloads. KrakenD&amp;rsquo;s AI Gateway integrates multiple layers of security at the edge to enforce zero-trust AI operations. From isolated authorization flows to data masking and exfiltration prevention, you can safeguard data traveling between clients and LLM providers without altering your existing API infrastructure.
The following key features are explained in this document:
Isolated Authentication (JWT + API key separation) API Key Injection (backend-only exposure) Data Masking (request &amp;amp; response layers) Exfiltration Prevention Patterns Isolated Authentication KrakenD separates the authentication flows between consumers and LLM on your AI endpoints.</description></item><item><title>AI Security</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/security/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/security/</guid><description>Protecting sensitive AI data and controlling access is essential for trustworthy AI workloads. KrakenD&amp;rsquo;s AI Gateway integrates multiple layers of security at the edge to enforce zero-trust AI operations. From isolated authorization flows to data masking and exfiltration prevention, you can safeguard data traveling between clients and LLM providers without altering your existing API infrastructure.
The following key features are explained in this document:
Isolated Authentication (JWT + API key separation) API Key Injection (backend-only exposure) Data Masking (request &amp;amp; response layers) Exfiltration Prevention Patterns Isolated Authentication KrakenD separates the authentication flows between consumers and LLM on your AI endpoints.</description></item><item><title>AI Security</title><link>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/security/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/security/</guid><description>Protecting sensitive AI data and controlling access is essential for trustworthy AI workloads. KrakenD&amp;rsquo;s AI Gateway integrates multiple layers of security at the edge to enforce zero-trust AI operations. From isolated authorization flows to data masking and exfiltration prevention, you can safeguard data traveling between clients and LLM providers without altering your existing API infrastructure.
The following key features are explained in this document:
Isolated Authentication (JWT + API key separation) API Key Injection (backend-only exposure) Data Masking (request &amp;amp; response layers) Exfiltration Prevention Patterns Isolated Authentication KrakenD separates the authentication flows between consumers and LLM on your AI endpoints.</description></item><item><title>AI Security</title><link>https://www.krakend.io/docs/v2.10/ai-gateway/security/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/ai-gateway/security/</guid><description>Protecting sensitive AI data and controlling access is essential for trustworthy AI workloads. KrakenD&amp;rsquo;s AI Gateway integrates multiple layers of security at the edge to enforce zero-trust AI operations. From isolated authorization flows to data masking and exfiltration prevention, you can safeguard data traveling between clients and LLM providers without altering your existing API infrastructure.
The following key features are explained in this document:
Isolated Authentication (JWT + API key separation) API Key Injection (backend-only exposure) Data Masking (request &amp;amp; response layers) Exfiltration Prevention Patterns Isolated Authentication KrakenD separates the authentication flows between consumers and LLM on your AI endpoints.</description></item><item><title>AI Security</title><link>https://www.krakend.io/docs/v2.10/ai-gateway/rag/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/ai-gateway/rag/</guid><description>RAG Pipelines (DRAFT) You can use KrakenD as a secure, lightweight proxy layer in a RAG (Retrieval-Augmented Generation) pipeline, and even enforce exfiltration prevention and data sanitization on the fly.
As per today, the usage of RAG requires you to make manual use of the sequential proxy and implement the flow in the configuration.
A typical RAG pipeline looks like this:
User prompt API Gateway (KrakenD) Retriever (e.g., vector DB) Enricher / Processor (e.</description></item><item><title>Run using the FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/security/fips-140/</guid><description>While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary that facilitates FIPS 140-3 compliance to protect customers&amp;rsquo; data in-transit.
If you are unfamiliar with FIPS, the US National Institute of Standards and Technology (NIST), in collaboration with the Canadian Centre for Cyber Security, released the [Cryptographic Module Validation Program][https://csrc.nist.gov/projects/cryptographic-module-validation-program] (CMVP), which validates cryptographic modules to ensure they meet security standards for Federal agencies. Still, it gained interest from other sectors and industries that started to follow the same standards.</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.10/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.6/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.7/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.8/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Docker Container with FIPS-140 Cryptographic Module</title><link>https://www.krakend.io/docs/enterprise/v2.9/security/fips-140/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/security/fips-140/</guid><description>The NIST (National Institute of Standards and Technology) released the FIPS-140-2 publication as a security standard for cryptographic modules that U.S. federal agencies must use. Still, it gained interest from other sectors and industries that started to follow the same standards.
While KrakenD&amp;rsquo;s stateless design does not handle customer data storage, it still offers a binary compiled using the BoringCrypto encryption module to protect customers&amp;rsquo; data in-transit, which is a FIPS 140-2 validated encryption module (certified until September 21, 2026).</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.10/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.5/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.6/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.7/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.8/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Working Directory: Specifying paths</title><link>https://www.krakend.io/docs/v2.9/configuration/working-directory/</link><pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/working-directory/</guid><description>Many components and options in KrakenD allow you to specify paths. In all of them, you can use absolute or relative paths.
For absolute paths, no possible interpretation or mistake arises when reading them. For instance, if you write /etc/krakend/krakend.json, you know exactly where this file is. Absolute paths are as clear as water but less convenient when your environments have different locations.
Relative paths, on the other hand, are helpful because you only specify a small part, but there is usually the question of the location of their corresponding base directory.</description></item><item><title>Moesif integration for API Analytics and Monetization</title><link>https://www.krakend.io/docs/enterprise/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>Moesif integration for API Analytics and Monetization</title><link>https://www.krakend.io/docs/enterprise/v2.10/governance/moesif/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/governance/moesif/</guid><description>Moesif is our API Analytics and Monetization partner that helps you understand and monetize API usage with a robust analytics and billing platform. While KrakenD focuses on organizing and protecting your content through the API gateway, Moesif provides governance and monetization dashboards that allow you to rule the activity on the API.
When the Moesif integration is enabled on KrakenD, the activity of your API is asynchronously pushed to Moesif, where you can configure your API governance and API Monetization rules.</description></item><item><title>AWS SigV4 Authentication for Service-to-Service Calls</title><link>https://www.krakend.io/docs/enterprise/authentication/aws-sigv4/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/aws-sigv4/</guid><description>Use AWS SigV4 authentication in KrakenD when your backend services or APIs require signed AWS requests to authorize access. This method signs HTTP requests with AWS Signature Version 4, allowing KrakenD to securely authenticate to AWS services or custom APIs that understand SigV4 signed requests. You might need this component when:
When accessing AWS APIs or services that enforce SigV4 signing (e.g., presign an S3 link). When your internal services require AWS IAM-based authentication for secure service-to-service communication.</description></item><item><title>Automatic Gzip compression</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
The gzip is not applied when the header is missing, or when the Accept-Encoding header contains a text/event-stream value.
Gzip compression is unrelated to decompression when consuming content from your services. Decompression is also done automatically, but in all KrakenD flavours, not only Enterprise.
When the content is successfully compressed, the response contains a &amp;quot;Content-Encoding: gzip&amp;quot; header</description></item><item><title>Automatic Gzip compression</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
The gzip is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.
Gzip compression is unrelated to decompression when consuming content from your services. Decompression is also done automatically, but in all KrakenD flavors, not only Enterprise.
When the content is successfully compressed, the response contains a &amp;quot;Content-Encoding: gzip&amp;quot; header.</description></item><item><title>Automatic Gzip compression</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
The gzip is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.
Gzip compression is unrelated to decompression when consuming content from your services. Decompression is also done automatically, but in all KrakenD flavors, not only Enterprise.
When the content is successfully compressed, the response contains a &amp;quot;Content-Encoding: gzip&amp;quot; header.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.1/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.2/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.3/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.4/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/v2.1/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/v2.2/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/v2.3/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/v2.4/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.0/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.1/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.2/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.3/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.4/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Service rate limit (stateless)</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service rate limit (stateless)</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service rate limit (stateless)</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.10/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.5/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.7/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.8/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP Server Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.9/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>Wildcard Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</guid><description>The krakend-wildcard plugin allows you that URLs starting with known patterns are forwarded to a common endpoint, without needing to declare all possible routes. For instance, you want to forward all traffic to /foo/* (with any nesting levels) to a specific backend.
Adding wildcard routes Let&amp;rsquo;s say you define the wildcard pattern /foo. It could match with URLs like the ones below:
/foo /foo/a?x=1 /foo/a/b/c/d /foo/* Wildcard paths are not regexp patterns, but literal matches of an URL and all its subresources.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/wildcard/</guid><description>The wildcard functionality allows you to declare endpoints that have many implicit paths in their backend. Instead of declaring all possible routes one by one, you can create one or more endpoints that will respond to a path pattern instead. The gateway then forwards all routes starting with the configured path to the backend(s).
For instance, you can declare an endpoint /foo/* that forwards all traffic starting with /foo/ to a specific backend.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Serving or using static content</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</guid><description>The krakend-static-live plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http server handler, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http client executor, the KrakenD endpoints use static content as if it were a backend.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Serving Static Content</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/serve-static-content/</guid><description>The static filesystem component lets you return content saved in the disk to end users and updates as the filesystem changes. The component is very lightweight and straightforward, using only the standard lib.
Notice the two possible usages of this component
When used globally at the service level (server/static-filesystem), the component registers itself as a static web server for a set of defined paths. Whenever users request a recognized starting path (the prefix), the component tries to return the requested resource (CSS, JS, images, or JSON files, to name a few examples).</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } }</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.0/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } }</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.1/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.2/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.3/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.4/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v1.3/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v1.4/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v1.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v1.4/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.0/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.1/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.2/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.4/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Zipkin Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Caching Strategies in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.10/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.5/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.6/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.7/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.8/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between the end user and KrakenD.</description></item><item><title>Caching Strategies</title><link>https://www.krakend.io/docs/v2.9/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating the pressure on your services.
KrakenD works similarly to the default rules of a CDN to cache responses, as it adheres mostly to the RFC-7234 (HTTP/1.1 Caching) in its implementation, and all the internals follow the decisions based on the RFC.
The caching component is a capability of the default KrakenD HTTP client connecting to your upstream services, and can store content in-memory so the next request that is within a valid expiration window can be returned right away without using the network, alleviating pressure and improving times.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v1.3/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v1.4/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.0/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.1/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.10/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.2/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.3/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.4/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.5/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.6/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.7/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.8/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.9/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v1.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v1.4/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.0/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.1/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.10/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.2/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.4/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.5/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.6/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.7/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.8/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Auth0 Integration</title><link>https://www.krakend.io/docs/v2.9/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.10/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.5/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.6/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.7/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.8/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>AMQP Consumer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.9/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Catchall (Fallback backend)</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/catch-all/</link><pubDate>Thu, 17 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/catch-all/</guid><description>The catchall endpoint is a particular type of endpoint that, when added, receives all the traffic from routes and methods that do not resolve to any of the other existing endpoints in the configuration.
Its primary use case is for initial stages of a migration, when you want to test a small subset of endpoints on KrakenD and have all the rest of the traffic forwarded to a common backend.</description></item><item><title>Global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Redis-based global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Redis-based global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Redis-based global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Global Rate Limiting</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>AI Token Cost Control &amp; Quotas</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/budget-control/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/budget-control/</guid><description>AI workloads can quickly generate unpredictable and excessive costs. KrakenD&amp;rsquo;s AI Gateway provides granular token usage monitoring and enforcement to keep your AI expenses transparent and within budget. Features like token quotas, budget alerts, prompt caching, and intelligent routing enable you to optimize requests and avoid surprise bills while maintaining performance and scalability.
Token Quota and Budget Enforcement KrakenD Enterprise includes a powerful persistent quota system that&amp;rsquo;s perfect for managing token-based usage quotas in LLM applications, designer for controlling cost, enforcing subscription tiers, and preventing overuse.</description></item><item><title>AI Token Cost Control &amp; Quotas</title><link>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/budget-control/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/budget-control/</guid><description>AI workloads can quickly generate unpredictable and excessive costs. KrakenD&amp;rsquo;s AI Gateway provides granular token usage monitoring and enforcement to keep your AI expenses transparent and within budget. Features like token quotas, budget alerts, prompt caching, and intelligent routing enable you to optimize requests and avoid surprise bills while maintaining performance and scalability.
Token Quota and Budget Enforcement KrakenD Enterprise includes a powerful persistent quota system that&amp;rsquo;s perfect for managing token-based usage quotas in LLM applications, designer for controlling cost, enforcing subscription tiers, and preventing overuse.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.10/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.5/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.7/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.8/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>HTTP Client Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.9/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and their way back. It is the perfect time to modify the request before it reaches the backend.
You cannot chain HTTP client plugins, limiting them to one plugin per backend connection, and replace the default KrakenD&amp;rsquo;s HTTP client.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>Import and Export OpenAPI definitions</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/openapi/</guid><description>The OpenAPI integration is a series of commands embedded in the KrakenD binary and additional metadata you can add in the configuration to enrich the documentation.
KrakenD offers OpenAPI import and export capabilities for OAS3 and Swagger v2 (--legacy mode), so you can autogenerate documentation or create a gateway configuration from one or multiple OpenAPI specs.
The openapi command supports the following functionalities:
openapi export: Creates OpenAPI documentation by reading the KrakenD configuration.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (payment and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration.
Configuration for GeoIP Add the following extra_config in the root to your configuration file:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.10/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.5/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to a Jaeger Collector (HTTP) or Jaeger Agent (UDP) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
The Opencensus Jaeger exporter allows you to export spans to Jaeger.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.7/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.8/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemtry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Jaeger Telemetry Integration - KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.9/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/jaeger/</guid><description>The KrakenD exporter to Jaeger allows you to submit spans to an OpenTelemetry Collector (HTTP or gRPC) automatically.
Jaeger is an open-source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems. Use Jaeger when you want to see the complete flow of a user request through KrakenD and its connected services.
Jaeger configuration To add Jaeger, configure a new exporter to the OpenTelemetry settings.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } version (string): The version of the running application that is reporting data.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v1.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v1.4/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.0/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } version (string): The version of the running application that is reporting data.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.1/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.2/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.4/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.10/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.5/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.6/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.7/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.8/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Array manipulation</title><link>https://www.krakend.io/docs/v2.9/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists; you name it) or to flatten objects from the response.
While the basic manipulation operations allow you to work directly with objects, the collections require you to use this flatmap component. The flatmap also will enable you to extract or move nested objects to have a customized object structure.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them and vice versa.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v1.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v1.4/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.0/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.1/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.2/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.4/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.5/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.6/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>KrakenD API Gateway Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v1.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v1.4/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.0/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.1/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.2/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.4/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.1/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.2/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/enterprise/v2.3/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.4/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.5/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.6/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.7/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.8/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v1.4/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.0/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.1/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.10/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.2/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.3/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.4/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.5/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.6/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.7/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.8/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Keycloak Authorization</title><link>https://www.krakend.io/docs/v2.9/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.10/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.5/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.6/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.7/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.8/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>AMQP Producer Integration in the API Gateway (RabbitMQ)</title><link>https://www.krakend.io/docs/v2.9/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/enterprise/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.10/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/enterprise/v2.9/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/v2.10/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Descope Authorization</title><link>https://www.krakend.io/docs/v2.9/authorization/descope/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/authorization/descope/</guid><description>Securing your APIs and underlying microservices is crucial in modern development. Descope enables you to add advanced authentication capabilities to your KrakenD endpoints efficiently.
Descope is a passwordless authentication and user management service designed for developers. KrakenD integrates with Descope via the JWT validation component.
Descope integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>AI Governance</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/governance/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/governance/</guid><description>KrakenD AI Governance empowers organizations to deploy large language models responsibly by enforcing compliance, security, and operational guardrails inline with AI traffic. Leverage granular controls on prompts, responses, usage, and reuse of prompt templates to standardize AI across teams, tenants, and projects.
Prompt Policy Enforcement Prompt policies enforce constraints on input prompts by pattern matching, contextual validation, or checking request metadata to prevent abusive or sensitive content from being processed downstream.</description></item><item><title>AI Governance</title><link>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/governance/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/governance/</guid><description>KrakenD AI Governance empowers organizations to deploy large language models responsibly by enforcing compliance, security, and operational guardrails inline with AI traffic. Leverage granular controls on prompts, responses, usage, and reuse of prompt templates to standardize AI across teams, tenants, and projects.
Prompt Policy Enforcement Prompt policies enforce constraints on input prompts by pattern matching, contextual validation, or checking request metadata to prevent abusive or sensitive content from being processed downstream.</description></item><item><title>Response header transformation</title><link>https://www.krakend.io/docs/enterprise/service-settings/response-headers-modifier/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/response-headers-modifier/</guid><description>The response headers modifier allows you to add, replace, or delete headers declaratively before responses are returned to the end-user for all declared endpoints simultaneously.
The main benefit of the modifier/response-headers is that the execution happens at the end of the response flow, and you can transform headers from all types of endpoints or encodings or change headers set by KrakenD itself (like the X-KrakenD-Complete and similar)
With this component, you can transform the returning headers no matter how they were generated.</description></item><item><title>Response header transformation</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/response-headers-modifier/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/response-headers-modifier/</guid><description>The response headers modifier allows you to add, replace, or delete headers declaratively before responses are returned to the end-user for all declared endpoints simultaneously.
The main benefit of the modifier/response-headers is that the execution happens at the end of the response flow, and you can transform headers from all types of endpoints or encodings or change headers set by KrakenD itself (like the X-KrakenD-Complete and similar)
With this component, you can transform the returning headers no matter how they were generated.</description></item><item><title>Response header transformation</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/response-headers-modifier/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/response-headers-modifier/</guid><description>The response headers modifier allows you to add, replace, or delete headers declaratively before responses are returned to the end-user for all declared endpoints simultaneously.
The main benefit of the modifier/response-headers is that the execution happens at the end of the response flow, and you can transform headers from all types of endpoints or encodings or change headers set by KrakenD itself (like the X-KrakenD-Complete and similar)
With this component, you can transform the returning headers no matter how they were generated.</description></item><item><title>Response header transformation</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/response-headers-modifier/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/response-headers-modifier/</guid><description>The response headers modifier allows you to add, replace, or delete headers declaratively before responses are returned to the end-user for all declared endpoints simultaneously.
The main benefit of the modifier/response-headers is that the execution happens at the end of the response flow, and you can transform headers from all types of endpoints or encodings or change headers set by KrakenD itself (like the X-KrakenD-Complete and similar)
With this component, you can transform the returning headers no matter how they were generated.</description></item><item><title>Response header transformation</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/response-headers-modifier/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/response-headers-modifier/</guid><description>The response headers modifier allows you to add, replace, or delete headers declaratively before responses are returned to the end-user for all declared endpoints simultaneously.
The main benefit of the modifier/response-headers is that the execution happens at the end of the response flow, and you can transform headers from all types of endpoints or encodings or change headers set by KrakenD itself (like the X-KrakenD-Complete and similar)
With this component, you can transform the returning headers no matter how they were generated.</description></item><item><title>SOAP integration</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>SOAP Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/soap/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/soap/</guid><description>The SOAP integration is the ideal tool for those companies that rely on SOAP services and would like to have an option to modernize their interface for the end-user.
KrakenD has the native capability of dealing with multiple encodings, like XML or JSON, and transforming from one to the other transparently before returning the content to the user. In addition, the SOAP integration adds the possibility to craft the body and XML content you will send to a SOAP service, injecting dynamic variables from places like the body sent by the user, headers, query strings, or parameters of the URL.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.10/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.5/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.6/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.7/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.8/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Router Options</title><link>https://www.krakend.io/docs/v2.9/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change how KrakenD processes the requests globally at the router layer.
Generally speaking you don&amp;rsquo;t need this. But there is an exception in every case, and you might need to change some values.
Configuration for the router The router controls the behavior of KrakenD toward users. Its settings affect all activity in the gateway. For instance, you can obfuscate the X-KrakenD-version header, set a custom body for 404 errors, remove the requests from the logs, or define how to calculate client IPs to name a few examples.</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD API Gateway with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.5/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.6/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.7/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.8/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/enterprise/v2.9/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.10/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD API Gateway with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.5/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.6/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.7/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.8/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Extending KrakenD with Request and Response Plugin Modifiers</title><link>https://www.krakend.io/docs/v2.9/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Document your endpoints with OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the krakend-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like 301 with the following configuration in your backend section:
{ &amp;#34;endpoint&amp;#34;: &amp;#34;/redirect&amp;#34;, &amp;#34;output_encoding&amp;#34;: &amp;#34;no-op&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;url_pattern&amp;#34;: &amp;#34;/__debug&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;no-op&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the no-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like a 301 with the following configuration, highlighting relevant sections:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;: &amp;#34;.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the no-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like a 301 with the following configuration, highlighting relevant sections:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;: &amp;#34;.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the no-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like a 301 with the following configuration, highlighting relevant sections:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;: &amp;#34;.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>Handling Client Redirects</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behavior of KrakenD is to follow the redirection and serve the final content to the user. When you don&amp;rsquo;t want this behavior and let the end client follow the redirect, you must enable the no_redirect HTTP client option.
No redirect configuration The no_redirect option is one in the list of HTTP client options in the backend.
By enabling the flag, you can stop KrakenD from following redirections like a 301.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>AWS X-Ray Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
Consider switching to OpenTelemetry The AWS Distro for OpenTelemetry Collector (ADOT Collector) is an AWS supported version of the upstream OpenTelemetry Collector and is distributed by Amazon.</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud metrics</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud metrics</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/v2.1/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/v2.2/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud metrics</title><link>https://www.krakend.io/docs/v2.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud metrics</title><link>https://www.krakend.io/docs/v2.4/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metrics_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v1.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v1.4/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v2.0/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metrics_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Unified LLM Interface</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/unified-llm-interface/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/unified-llm-interface/</guid><description>The Unified LLM Interface of KrakenD allows you to interact with one or more LLMs, removing the complexity of dealing with LLMs for the end user. It allows you to set the grounds to communicate with LLMs, authenticate, and treat requests and responses back and forth.
The unified LLM interface helps you to:
Route to the right LLM Abstract the request interface Abstract the response interface Routing to the right LLM KrakenD&amp;rsquo;s LLM Routing and AI Proxy feature enables the distribution of AI requests across one or multiple Large Language Model.</description></item><item><title>Unified LLM Interface</title><link>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/unified-llm-interface/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/unified-llm-interface/</guid><description>The Unified LLM Interface of KrakenD allows you to interact with one or more LLMs, removing the complexity of dealing with LLMs for the end user. It allows you to set the grounds to communicate with LLMs, authenticate, and treat requests and responses back and forth.
LLM Routing KrakenD’s AI Proxy and LLM routing feature enables you to distribute AI requests across multiple Large Language Model providers or instances. This ensures high availability, optimized performance, cost efficiency, developer abstraction, and compliance.</description></item><item><title>Unified LLM Interface</title><link>https://www.krakend.io/docs/v2.10/ai-gateway/unified-llm-interface/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/ai-gateway/unified-llm-interface/</guid><description>The Unified LLM Interface of KrakenD allows you to interact with one or more LLMs, removing the complexity of dealing with LLMs for the end user. It allows you to set the grounds to communicate with LLMs, authenticate, and treat requests and responses back and forth.
LLM Routing KrakenD’s AI Proxy and LLM routing feature enables you to distribute AI requests across multiple Large Language Model providers or instances. This ensures high availability, optimized performance, cost efficiency, developer abstraction, and compliance.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>Generating API documentation</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/api-docs/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/api-docs/</guid><description>KrakenD supports exporting (and importing) OpenAPI Specification. This flexibility allows you to auto-generate documentation that you can serve from the gateway itself, or host somewhere else.
There are multiple ways of generating docs API documentation is a dragon of many heads. This page sets an example for you to understand how to do it, and open the door to start working with it. It does not mean that you have to generate the docs on the Docker image, or that you need to serve the documentation from KrakenD itself.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>Validating the responses with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Validating the responses with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Validating the responses with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Middleware Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/extending/middleware-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/middleware-plugins/</guid><description>Middleware plugins are designed to provide the maximum level of customization. While an open-source user could fork the source code of KrakenD and implement their own middleware, an enterprise user can use this plugin to change the internals of KrakenD.
Middleware plugins allow you to add functionality to the remaining parts, whereas the other plugins do not allow you to do so. The primary purpose of Middleware plugins is:
Intercept the request and response Delegate the execution to custom code Abort the execution (e.</description></item><item><title>Middleware Plugins for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/extending/middleware-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/extending/middleware-plugins/</guid><description>Middleware plugins are designed to provide the maximum level of customization. While an open-source user could fork the source code of KrakenD and implement their own middleware, an enterprise user can use this plugin to change the internals of KrakenD.
Middleware plugins allow you to add functionality to the remaining parts, whereas the other plugins do not allow you to do so. The primary purpose of Middleware plugins is:
Intercept the request and response Delegate the execution to custom code Abort the execution (e.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v1.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v1.4/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v2.0/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/v2.1/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/v2.2/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/v2.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting traces to Azure Monitor</title><link>https://www.krakend.io/docs/v2.4/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/v2.1/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/v2.2/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/v2.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/v2.4/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v1.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v1.4/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v2.0/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Strategies to return the backend errors</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, except when you use the no-op encoding. The philosophy behind this is that clients have to be decoupled from their underlying services.
You can override the default policy of returning backend error details with different strategies:
Errors entirely handled by the backend (default strategy for no-op): Show the HTTP status codes, headers, and body as returned by the backend (maximum one).</description></item><item><title>Strategies to return the backend errors</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, except when you use the no-op encoding. The philosophy behind this is that clients have to be decoupled from their underlying services.
You can override the default policy of returning backend error details with different strategies:
Errors entirely handled by the backend (default strategy for no-op): Show the HTTP status codes, headers, and body as returned by the backend (maximum one).</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v1.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v2.0/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Strategies to return the backend errors</title><link>https://www.krakend.io/docs/v2.1/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, except when you use the no-op encoding. The philosophy behind this is that clients have to be decoupled from their underlying services.
You can override the default policy of returning backend error details with different strategies:
Errors entirely handled by the backend (default strategy for no-op): Show the HTTP status codes, headers, and body as returned by the backend (maximum one).</description></item><item><title>Strategies to return the backend errors</title><link>https://www.krakend.io/docs/v2.2/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, except when you use the no-op encoding. The philosophy behind this is that clients have to be decoupled from their underlying services.
You can override the default policy of returning backend error details with different strategies:
Errors entirely handled by the backend (default strategy for no-op): Show the HTTP status codes, headers, and body as returned by the backend (maximum one).</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Google Cloud and Stackdriver Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s Operation Suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Pub-Sub Backend Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Pub-Sub Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Pub-Sub Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Pub-Sub Backend Integration</title><link>https://www.krakend.io/docs/v2.5/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Pub-Sub Backend Integration</title><link>https://www.krakend.io/docs/v2.6/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/enterprise/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/v2.10/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/v2.7/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/v2.8/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Publisher/Subscribe with Kafka, NATS and cloud systems</title><link>https://www.krakend.io/docs/v2.9/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>AI Gateways's Prompt Templates</title><link>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/prompt-templates/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/ai-gateway/prompt-templates/</guid><description>Prompt Templates are a mechanism to build the body sent to the LLM using a predefined template, instead of allowing the end user passing it directly. This is not only writing a text that you send to the LLM, but actually have the opportunity to insert place holders, values that came in the request body, headers, parameters, etc. or even apply scripting over it.
The Prompt Templates offer more control on the types of requests sent to the AI and allow you to specify system and user input to ensure the final output.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.10/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.5/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.6/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.7/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.8/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>HTTP Global Client settings</title><link>https://www.krakend.io/docs/v2.9/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using HTTP with all your upstream services, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
The following settings affect all connections from KrakenD to your services.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.10/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.5/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.6/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.7/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.8/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL Backend Integration</title><link>https://www.krakend.io/docs/v2.9/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>IP Filtering for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</guid><description>The OpenAPI or Swagger generator is a component provided by the KrakenD Studio, offering the automatic generation of API documentation through a static Swagger file. Even KrakenD is the gateway and lacks all the knowledge of your API backends, KrakenD Studio is capable of providing in-depth detail of backend responses in the documentation documentation:inspection of live requests.
Generating the OpenAPI spec When you run the KrakenD configuration through KrakenD Studio you can enable the Swagger generation from the UI, or by adding the configuration snippet in your krakend.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/openapi/</guid><description>The OpenAPI or Swagger documentation is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command.
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user. endpoint level: Defines the documentation for a specific endpoint. Both placements of the configuration are entirelly optional.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.1/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/endpoints/openapi/</guid><description>The OpenAPI or Swagger documentation is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.2/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.3/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.4/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/endpoints/openapi/</guid><description>The OpenAPI documentation (formerly Swagger) is automatically generated by the KrakenD Enterprise binary when you use the krakend openapi export command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.10/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.5/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.6/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.7/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.8/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Azure Monitor Telemetry Integration</title><link>https://www.krakend.io/docs/v2.9/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/azure/</guid><description>Azure Monitor collects, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The gateway sends all the traces to a local OpenTelemetry Collector (see repository), allowing the gateway to offload data quickly and the collector can take care of additional handling like retries, batching, encryption or even sensitive data filtering. Finally, the Otel Collector pushes all the data to your Application Insights on Azure Monitor.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>OpenCensus Agent (Azure Monitor)</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>OpenCensus Agent (Azure Monitor)</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v1.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v1.4/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v2.0/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v2.1/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v2.2/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>OpenCensus Agent (Azure Monitor)</title><link>https://www.krakend.io/docs/v2.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>OpenCensus Agent (Azure Monitor)</title><link>https://www.krakend.io/docs/v2.4/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.1/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.2/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.3/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.4/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>Handling WebSockets connections</title><link>https://www.krakend.io/docs/enterprise/v1.3/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end-client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/v2.0/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/v2.1/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/v2.2/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/v2.3/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets Integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/backends/http-client/</link><pubDate>Wed, 03 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/http-client/</guid><description>The HTTP client namespace allows you to set the behavior of the HTTP connections between KrakenD and your backend service.
Send the payload on 307 and 308 redirects KrakenD does not duplicate the body of the request when following a redirection because automatically doing it would affect the performance of all requests. In the unusual cases where your backend responds with a 307 Temporary Redirect or a 308 Permanent Redirect, enable the following flag to resend the original payload to the final redirected service:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>HTTP Per-backend Client settings</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.0/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.1/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.2/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.3/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.4/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>Instana Telemetry for KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/v2.1/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/v2.2/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/v2.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/v2.4/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 0, &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.10/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.7/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.8/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>AWS Lambda Integration</title><link>https://www.krakend.io/docs/v2.9/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.10/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.5/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.6/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.7/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.8/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Handling Concurrent Requests</title><link>https://www.krakend.io/docs/v2.9/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;My KrakenD API gateway&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/newrelic&amp;#34;: { &amp;#34;license&amp;#34;: &amp;#34;XXXX&amp;#34;, &amp;#34;debug&amp;#34;: true } } } license (string) The API key provided by New Relic to push data into your account.</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;My KrakenD API gateway&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/newrelic&amp;#34;: { &amp;#34;license&amp;#34;: &amp;#34;XXXX&amp;#34;, &amp;#34;debug&amp;#34;: true } } } Fields of NewRelic exporter * required fields debug boolean Set to true when configuring New Relic for the first time while in development, to see the activity in the logs.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;My KrakenD API gateway&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/newrelic&amp;#34;: { &amp;#34;license&amp;#34;: &amp;#34;XXXX&amp;#34;, &amp;#34;debug&amp;#34;: true } } } Fields of NewRelic exporter * required fields debug boolean Set to true when configuring New Relic for the first time while in development, to see the activity in the logs.</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;My KrakenD API gateway&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/newrelic&amp;#34;: { &amp;#34;license&amp;#34;: &amp;#34;XXXX&amp;#34;, &amp;#34;debug&amp;#34;: true } } } Fields of NewRelic exporter * required fields debug boolean Set to true when configuring New Relic for the first time while in development, to see the activity in the logs.</description></item><item><title>New Relic Telemetry Integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;My KrakenD API gateway&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/newrelic&amp;#34;: { &amp;#34;license&amp;#34;: &amp;#34;XXXX&amp;#34;, &amp;#34;debug&amp;#34;: true } } } Fields of NewRelic exporter * required fields debug boolean Set to true when configuring New Relic for the first time while in development, to see the activity in the logs.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>New Relic Telemetry Integration (native DSK)</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/newrelic/</guid><description>The New Relic native integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
How is the native SDK integration different from OpenTelemetry? Open-source and Enterprise users can also report traces and metrics to New Relic using the OpenTelemetry integration. Nevertheless, New Relic supports an OTLP specification dated from November 2021 (v1.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.10/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.5/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.6/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.7/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.8/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery Integration</title><link>https://www.krakend.io/docs/v2.9/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.10/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.5/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.6/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.7/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.8/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing and mirroring</title><link>https://www.krakend.io/docs/v2.9/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.10/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.5/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.6/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.7/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.8/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.9/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Request manipulation with templates</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/body-generator/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/body-generator/</guid><description>The body generator modifier allows you to craft the body you send to a backend through templates and enables injecting other values from the user request, such as the original body, headers, query strings, or URL parameters.
The body generator does not necessarily need that the endpoint sends data, as it works even when there is no input body from the user. It lets you specify the body content you want to send to the final service, and you can reuse parts of the request (such as headers) to form a new body.</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>Postman Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/postman/</guid><description>The Postman generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
When you call the generate postman command, it reads the KrakenD configuration and generates a collection of endpoints as a Postman specification.
Another option you have to import your API specifications is to import an OpenAPI file into Postman. You can generate the OpenAPI specification from a KrakenD API using the OpenAPI export</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.10/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.3/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.4/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.5/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.6/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.7/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.8/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>NTLM authentication</title><link>https://www.krakend.io/docs/enterprise/v2.9/authentication/ntlm/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/authentication/ntlm/</guid><description>NTLM (NT Lan Manager) is a suite of Microsoft security protocols used for authentication, integrity, and confidentiality of network communications. It is primarily used for authentication on Windows-based systems but can also be used in other environments.
KrakenD NTLM integration does the user impersonation and acts as a client in the communication gateway to the backend. The end-user authentication is independent, and you can offer standard JWT tokens, no authentication, or another authentication option.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration On KrakenD EE the virtual host plugin usually lives inside the /plugins folder.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.1/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.2/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.3/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.4/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/service-settings/virtual-hosts/</guid><description>The Virtual Host server allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts, add the component server/virtualhost under the service extra_config, as depicted below:</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.10/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.5/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.6/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.7/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.8/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua Scripting</title><link>https://www.krakend.io/docs/v2.9/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>HTTP Logger: Dump backend requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger: Dump backend requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.1/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger: Dump backend requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger to dump requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger Integration</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.10/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.5/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.6/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.7/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.8/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>API Throttling and Timeout Management</title><link>https://www.krakend.io/docs/v2.9/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Lua advanced helpers</title><link>https://www.krakend.io/docs/enterprise/endpoints/lua-advanced-helpers/</link><pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/lua-advanced-helpers/</guid><description>When running Lua scripts on the Enterprise Edition, a collection of helpers extends functionality and improves the speed of Lua execution. Because these helpers run natively on Go and their output is passed to the Lua virtual machine, their performance is optimal and much better than any behavior you can code within Lua libraries.
Debug helpers The debug package contains a single method that allows you to dump into the console objects for debugging:</description></item><item><title>Lua advanced helpers</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/lua-advanced-helpers/</link><pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/lua-advanced-helpers/</guid><description>When running Lua scripts on the Enterprise Edition, a collection of helpers extends functionality and improves the speed of Lua execution. Because these helpers run natively on Go and their output is passed to the Lua virtual machine, their performance is optimal and much better than any behavior you can code within Lua libraries.
Debug helpers The debug package contains a single method that allows you to dump into the console objects for debugging:</description></item><item><title>Lua advanced helpers</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/lua-advanced-helpers/</link><pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/lua-advanced-helpers/</guid><description>When running Lua scripts on the Enterprise Edition, a collection of helpers extends functionality and improves the speed of Lua execution. Because these helpers run natively on Go and their output is passed to the Lua virtual machine, their performance is optimal and much better than any behavior you can code within Lua libraries.
Debug helpers The debug package contains a single method that allows you to dump into the console objects for debugging:</description></item><item><title>Lua advanced helpers</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/lua-advanced-helpers/</link><pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/lua-advanced-helpers/</guid><description>When running Lua scripts on the Enterprise Edition, a collection of helpers extends functionality and improves the speed of Lua execution. Because these helpers run natively on Go and their output is passed to the Lua virtual machine, their performance is optimal and much better than any behavior you can code within Lua libraries.
Debug helpers The debug package contains a single method that allows you to dump into the console objects for debugging:</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.2/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/backends/http-proxy/</guid><description>The HTTP proxy plugin adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy Connecting to all backends using a proxy Passing an environment variable HTTP_PROXY when starting the gateway ensures that all backend requests pass through the defined proxy.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>HTTP Proxy: Access to backends through a proxy</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/http-proxy/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/http-proxy/</guid><description>The HTTP proxy adds an intermediate layer where the connection to the backend goes through an external proxy.
There are two different ways to connect to your backends through a corporate proxy:
Connect to all backends using a proxy Connect to a specific backend using a proxy No longer a plugin Since KrakenD Enterprise v2.3 the HTTP proxy functionality is no longer offered as a plugin, but as a regular component to improve the connectivity options.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
The policy language is used in CEL Validation, Security Policies, and in the Tiered Rate Limit.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.10/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
The policy language is used in CEL Validation, Security Policies, and in the Tiered Rate Limit.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.5/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.6/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.7/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
The policy language is used in CEL Validation, Security Policies, and in the Tiered Rate Limit.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.8/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
The policy language is used in CEL Validation, Security Policies, and in the Tiered Rate Limit.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Security Policies language and syntax</title><link>https://www.krakend.io/docs/enterprise/v2.9/security-policies/policy-language/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/security-policies/policy-language/</guid><description>The policies language and syntax look nearly identical to C++, Go, Java, and Typescript and is based on Google&amp;rsquo;s CEL built-in functions and advanced macros. If you have existing validation using the CEL Component, you can also port them as policies.
The policy language is used in CEL Validation, Security Policies, and in the Tiered Rate Limit.
Basic syntax Data types The supported data types are:
uint (unsigned integer) int (integer) double (Number, float) string (string) bool (boolean) null_type bytes (on JSON mapping a string of base64-encoded bytes) map (Object.</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration: Location-based services</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Per backend HTTP client settings</title><link>https://www.krakend.io/docs/enterprise/v2.3/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>Per backend HTTP client settings</title><link>https://www.krakend.io/docs/enterprise/v2.4/backends/http-client/</link><pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/backends/http-client/</guid><description>The HTTP client options allow you to set the client TLS settings for each backend, configure the no-redirect behavior, or connect through an external proxy.
You can set the client TLS settings for all backends as a global setting. Nevertheless, you can decide to individually change the client TLS settings for a specific backend.
HTTP client settings To do so, include the backend/http/client namespace in the backend&amp;rsquo;s extra configuration. It accepts the following settings:</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.10/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.5/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.6/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.7/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.8/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>CEL Built-in functions for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.9/security-policies/built-in-functions/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/security-policies/built-in-functions/</guid><description>The CEL language (language definition) offers the following built-in functions and macros that you can use while building your Security Policies or conditional requests and responses with CEL.
The following functions and macros are always available regardless of your configuration. The signatures of the functions below follow the format function -&amp;gt; return, and include the different data &amp;lt;types&amp;gt; you can use in each of them.
Membership functions and macros Their usage is checking different aspects of maps and arrays mostly.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.10/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.5/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.6/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.7/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.8/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Advanced Macros for Security Policies</title><link>https://www.krakend.io/docs/enterprise/v2.9/security-policies/advanced-policy-macros/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/security-policies/advanced-policy-macros/</guid><description>The advanced macros are powerful functions that allow you to declare Security Policies with simple expressions, reducing code complexity and speeding up development. Advanced macros are not available on the CEL component, only on Security Policies.
You have the following list of advanced macros always available unless you set in the configuration the disable_advanced_macros flag to true.
Adding functionality The following list is not the complete catalogue of functions, but the ones added to the built-in functions.</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.10/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.5/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.6/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.7/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.8/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Security Policies Playbook</title><link>https://www.krakend.io/docs/enterprise/v2.9/security-policies/playbook/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/security-policies/playbook/</guid><description>An example is sometimes self-explanatory and lets you see the potential of the kind of stuff you can do with policies. The following examples demonstrate who to apply different policies to your API, but possibilities are endless!
Check if user has one of the selected roles (RBAC) or attributes (ABAC) This configuration would go inside the endpoint&amp;rsquo;s extra_config. Checks that the role is admin or root, and that the department is also contained in a list:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.5/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.6/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.10/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.5/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.6/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.7/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.8/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>Static modification of requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.9/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/martian/</guid><description>The Martian component allows you to modify requests and responses with static data through a simple DSL definition in the configuration file.
Martian works perfectly in combination with other components, such as CEL verifications or Caching, as it acts before other components start processing.
As it acts at HTTP level, it can change requests and responses even using the no-op encoding.
Use Martian when you want to make modifications before passing the content to the backends (request) or when returning from them (response).</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.10/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.5/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.6/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.7/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.8/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE Integration Guide for Developers</title><link>https://www.krakend.io/docs/v2.9/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>Logstash Integration in the API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/v2.6/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration in the API Gateway</title><link>https://www.krakend.io/docs/v2.5/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/v2.6/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/logger/</guid><description>Use standard logging instead Unless you have a compelling reason to use this logger based on OpenCensus, you should use the standard KrakenD Logging and not this component. This component will be deprecated in the future. Opencensus can also export data to the system logger as other exporters. If you use this component, do not not enable standard logging.
To enable OpenCensus logging, it only requires you to add the logger exporter in the opencensus module.</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/v2.5/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/logger/</guid><description>Use standard logging instead Unless you have a compelling reason to use this logger based on OpenCensus, you should use the standard KrakenD Logging and not this component. This component is deprecated and will be removed in the future. Opencensus can also export data to the system logger as other exporters. If you use this component, do not not enable standard logging.
To enable OpenCensus logging, it only requires you to add the logger exporter in the opencensus module.</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.10/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.7/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.8/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog GELF Logging Integration</title><link>https://www.krakend.io/docs/v2.9/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/v2.10/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/v2.7/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/v2.8/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/enterprise/v2.9/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/v2.10/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/v2.7/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/v2.8/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash Integration (JSON logs)</title><link>https://www.krakend.io/docs/v2.9/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable Logstash is very simple:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;stdout&amp;#34;: true, &amp;#34;syslog&amp;#34;: false, &amp;#34;format&amp;#34;:&amp;#34;custom&amp;#34;, &amp;#34;custom_format&amp;#34;: &amp;#34;%{message}&amp;#34; }, &amp;#34;telemetry/logstash&amp;#34;:{ &amp;#34;enabled&amp;#34;: true } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/v2.10/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/v2.6/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/v2.7/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/v2.8/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/enterprise/v2.9/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.10/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.5/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.6/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.7/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.8/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Integration for Logging</title><link>https://www.krakend.io/docs/v2.9/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.10/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.5/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.6/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.7/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.8/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>End-to-End Testing for Developers</title><link>https://www.krakend.io/docs/enterprise/v2.9/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, an essential step in any CI/CD strategy is including end-to-end tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned when working together with your upstream services.
How E2E testing works The end-to-end testing definition is quite simple. You must create a folder to hold all the test cases you want to execute (e.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.10/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.5/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.6/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.7/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.8/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported Encodings for Backend Integration</title><link>https://www.krakend.io/docs/v2.9/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) yaml (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.10/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.5/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.6/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.7/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.8/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Returned encodings</title><link>https://www.krakend.io/docs/v2.9/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding).
When clients consume upstream services content through KrakenD, the response is automatically transformed to the encoding of your choice, independently of the encoding it had in origin, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send these responses back to the client in different formats than provided by your services (in KrakenD jargon, backend).</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>Automatic Gzip compression on responses</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/gzip/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/gzip/</guid><description>KrakenD Enterprise compresses with gzip all traffic returned to the client when the request contains an Accept-Encoding: gzip header.
This feature only talks about Gzipping responses KrakenD understands gzipped responses from backends and decompresses them when it needs to manipulate the response. But this functionality talks about compressing all traffic back to the client. The gzip response compression is not applied when the header is missing or when the Accept-Encoding header contains a text/event-stream value.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.10/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.5/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.6/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.7/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.8/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>API Gateway Status Codes</title><link>https://www.krakend.io/docs/v2.9/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints The following status codes are the ones returned by the gateway.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors We do not recommend you to change the default behavior to have a secure and decoupled gateway.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors We do not recommend you to change the default behavior to have a secure and decoupled gateway.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors We do not recommend you to change the default behavior to have a secure and decoupled gateway.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.10/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors We do not recommend you to change the default behavior to have a secure and decoupled gateway.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.5/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.6/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.7/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.8/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Returning the backend headers and errors</title><link>https://www.krakend.io/docs/v2.9/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/detailed-errors/</guid><description>KrakenD&amp;rsquo;s default policy regarding errors and status codes is to hide from the client any backend details, this includes headers and errors, except when you use the no-op encoding.
The philosophy behind this is that clients have to be decoupled from their underlying services, as an API Gateway should do. The opposite is a reverse proxy or a simple router.
Strategies to return headers and errors Yet, you can override the default policy of returning backend error details with different strategies.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.10/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.5/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.6/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.7/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.8/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>Static Proxy Endpoints</title><link>https://www.krakend.io/docs/v2.9/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/static-proxy/</guid><description>The static proxy aids in decorating the final response with static data. It helps deal with incomplete and degraded responses or add more content to good responses. When enabled, it injects the static data** into the final response when a backend&amp;rsquo;s behavior falls within the selected strategy. The data is injected replacing any colliding keys and merging with any existing data from the backend responses.
Key precedence The static proxy data is a final decorator and wins every fight.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.10/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.5/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.6/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.7/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.8/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>JSON Schema Validation</title><link>https://www.krakend.io/docs/v2.9/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</guid><description>The response JSON schema validator adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
Validation of responses, not requests This component validates that the response from the server of after content aggregation/manipulation in KrakenD has the desired attributes.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/response-schema-validator/</guid><description>The response JSON schema validator adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
Validation of responses, not requests This component validates that the response from the server of after content aggregation/manipulation in KrakenD has the desired attributes.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Response Schema Validation for API Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/response-schema-validator/</guid><description>The response JSON schema validator adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
Validation of responses, not requests This component validates that the response from the server of after content aggregation/manipulation in KrakenD has the desired attributes.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>Limiting requests' payload maximum size</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/maximum-request-size/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/maximum-request-size/</guid><description>Consumers of the gateway might see their requests limited when using the max_payload property. All requests are validated when this attribute is set, checking that their size is inside the limits set.
There are two possible placements of this attribute:
At the service level: limits the requests of all activity At the endpoint level: limits the requests of specific endpoints You can set both limits simultaneously if you want. When both limits exist, the service level limit is checked first, and if it passes, then it checks the endpoint limit.</description></item><item><title>LLM Routing</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/llm-routing/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/llm-routing/</guid><description>KrakenD’s AI Proxy and LLM routing feature enables you to distribute AI requests across one or multiple Large Language Model providers or instances.
LLM Routing on KrakenD supports both single-provider and multi-provider. You can configure endpoints that can connect to a specific LLM model, or based on policies, change the model on the fly, or they even make simultaneous requests to different providers to aggregate their responses.
To implement single or multi-LLM routing in KrakenD, like dynamically selecting between different Large Language Model (LLM) providers like OpenAI, Mistral, Anthropic, or custom models, there are several clean, scalable strategies depending on how you want to choose the provider:</description></item><item><title>OpenAI Integration</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/openai/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/openai/</guid><description>The OpenAI interface allows KrakenD to use OpenAI&amp;rsquo;s API without writing custom integration code, enabling intelligent automation, content generation, or any LLM-powered use case within your existing API infrastructure.
This component abstracts you from the OpenAI API usage allowing the consumer to concentrate on the prompt only, as for each request to an endpoint, KrakenD will create the OpenAI request with all the necessary elements in their API, and will return a unified response, so if you use other vendors you have a consitent use of LLM models.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.10/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.5/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.6/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.7/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.8/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/enterprise/v2.9/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.10/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.5/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.6/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.7/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.8/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for the Asynchronous Agent</title><link>https://www.krakend.io/docs/v2.9/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>Google Gemini integration</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/gemini/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/gemini/</guid><description>The Gemini interface allows KrakenD to use Gemini&amp;rsquo;s API without writing custom integration code, enabling intelligent automation, content generation, or any LLM-powered use case within your existing API infrastructure.
This component abstracts you from the Gemini API usage allowing the consumer to concentrate on the prompt only, as for each request to an endpoint, KrakenD will create the Gemini request with all the necessary elements in their API, and will return a unified response, so if you use other vendors you have a consitent use of LLM models.</description></item><item><title>Mistral Integration</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/mistral/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/mistral/</guid><description>The Mistral integration enables KrakenD to talk to Mistral’s AI services, allowing you to embed powerful language model capabilities into your API workflows without custom coding. Use this interface when you want to connect Mistral for tasks like intelligent automation, conversational AI, content generation, or other LLM-driven functionalities inside your existing API infrastructure.
This component abstracts the complexities of communicating with Mistral’s AI API. When an API request hits your KrakenD endpoint configured with the Mistral interface, KrakenD automatically constructs the necessary Mistral API payload, handles authentication, and processes the responses uniformly.</description></item><item><title>Anthropic integration</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/anthropic/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/anthropic/</guid><description>The Anthropic interface allows KrakenD to use Anthropic&amp;rsquo;s API (Claude) without writing custom integration code, enabling intelligent automation, content generation, or any LLM-powered use case within your existing API infrastructure.
This component abstracts you from the Anthropic API usage allowing the consumer to concentrate on the prompt only, as for each request to an endpoint, KrakenD will create the Anthropic request with all the necessary elements in their API, and will return a unified response, so if you use other vendors you have a consitent use of LLM models.</description></item><item><title>Workflows</title><link>https://www.krakend.io/docs/enterprise/endpoints/workflows/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/workflows/</guid><description>The Workflow component allows you to create complex API flows behind an endpoint. In a regular endpoint, you connect a route to one or several backends, but what if you could nest other endpoints in any backend call? The workflow component allows you, amongst other things, to:
Add more functionality to your backends without changing them: like decorating responses of existing backends, sending additional messages to queues, and other functionality. Create unlimited nested calls: The user calls an endpoint that internally calls one or more services, and at the same time, they can call other services again and again to create complex workflows Combine sequential and parallel flows: While a regular endpoint offers sequential OR concurrent connections, with the workflow, you can connect sequentially AND in concurrent using the combinations that better work for you.</description></item><item><title>Workflows</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/workflows/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/workflows/</guid><description>The Workflow component allows you to create complex API flows behind an endpoint. In a regular endpoint, you connect a route to one or several backends, but what if you could nest other endpoints in any backend call? The workflow component allows you, amongst other things, to:
Add more functionality to your backends without changing them: like decorating responses of existing backends, sending additional messages to queues, and other functionality. Create unlimited nested calls: The user calls an endpoint that internally calls one or more services, and at the same time, they can call other services again and again to create complex workflows Combine sequential and parallel flows: While a regular endpoint offers sequential OR concurrent connections, with the workflow, you can connect sequentially AND in concurrent using the combinations that better work for you.</description></item><item><title>Workflows</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/workflows/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/workflows/</guid><description>The Workflow component allows you to create complex API flows behind an endpoint. In a regular endpoint, you connect a route to one or several backends, but what if you could nest other endpoints in any backend call? The workflow component allows you, amongst other things, to:
Add more functionality to your backends without changing them: like decorating responses of existing backends, sending additional messages to queues, and other functionality. Create unlimited nested calls: The user calls an endpoint that internally calls one or more services, and at the same time, they can call other services again and again to create complex workflows Combine sequential and parallel flows: While a regular endpoint offers sequential OR concurrent connections, with the workflow, you can connect sequentially AND in concurrent using the combinations that better work for you.</description></item><item><title>Workflows</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/workflows/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/workflows/</guid><description>The Workflow component allows you to create complex API flows behind an endpoint. In a regular endpoint, you connect a route to one or several backends, but what if you could nest other endpoints in any backend call? The workflow component allows you, amongst other things, to:
Add more functionality to your backends without changing them: like decorating responses of existing backends, sending additional messages to queues, and other functionality. Create unlimited nested calls: The user calls an endpoint that internally calls one or more services, and at the same time, they can call other services again and again to create complex workflows Combine sequential and parallel flows: While a regular endpoint offers sequential OR concurrent connections, with the workflow, you can connect sequentially AND in concurrent using the combinations that better work for you.</description></item><item><title>Workflows</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/workflows/</link><pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/workflows/</guid><description>The Workflow component allows you to create complex API flows behind an endpoint. In a regular endpoint, you connect a route to one or several backends, but what if you could nest other endpoints in any backend call? The workflow component allows you, amongst other things, to:
Add more functionality to your backends without changing them: like decorating responses of existing backends, sending additional messages to queues, and other functionality. Create unlimited nested calls: The user calls an endpoint that internally calls one or more services, and at the same time, they can call other services again and again to create complex workflows Combine sequential and parallel flows: While a regular endpoint offers sequential OR concurrent connections, with the workflow, you can connect sequentially AND in concurrent using the combinations that better work for you.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.10/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.5/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.6/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.7/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.8/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load Balancing and Throttling</title><link>https://www.krakend.io/docs/v2.9/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern in KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/v2.10/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern</title><link>https://www.krakend.io/docs/v2.5/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern</title><link>https://www.krakend.io/docs/v2.6/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker Pattern</title><link>https://www.krakend.io/docs/v2.7/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/v2.8/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Circuit Breaker</title><link>https://www.krakend.io/docs/v2.9/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. In the image above you can see a simplified version of its behavior. When backends fail to succeed for a number of consecutive times, the circuit breaker will prevent sending more traffic to a failing backend alleviating its pressure under challenging conditions.
When KrakenD demands more throughput than your API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.5/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Service Rate Limiting to Control API Usage</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.10/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.5/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting (client_max_rate): applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.6/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting (client_max_rate): applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.7/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.8/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/enterprise/v2.9/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.10/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.5/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting (client_max_rate): applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.6/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting (client_max_rate): applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed during the controlled time window in that endpoint.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.7/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.8/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limiting API Gateway Endpoints</title><link>https://www.krakend.io/docs/v2.9/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests a KrakenD endpoint (a route) will accept in a given time window. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting (max_rate): applies simultaneously to all clients using the endpoint, sharing a unique counter. User rate-limiting (client_max_rate): sets a counter to each individual user. Both types can coexist and they complement each other, and store the counters in-memory.</description></item><item><title>Rate Limit Tiers</title><link>https://www.krakend.io/docs/enterprise/service-settings/tiered-rate-limit/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/tiered-rate-limit/</guid><description>The rate limit based on tiers allows you to have multiple sets of service and endpoint rate limits that apply differently to users depending on their tier or sometimes called subscription plans.
There are four variants of the Tiered Rate Limit:
Service Tiered Rate Limit (stateless) Endpoint Tiered Rate Limit (stateless) Service Tiered Rate Limit consolidated to Redis (stateful) Endpoint Tiered Rate Limit consolidated to Redis (stateful) The service rate limits apply to all traffic in the gateway, while the endpoint rate limits apply to specific endpoints where you include them.</description></item><item><title>Rate Limit Tiers</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/tiered-rate-limit/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/tiered-rate-limit/</guid><description>The rate limit based on tiers allows you to have multiple sets of service and endpoint rate limits that apply differently to users depending on their tier or sometimes called subscription plans.
There are four variants of the Tiered Rate Limit:
Service Tiered Rate Limit (stateless) Endpoint Tiered Rate Limit (stateless) Service Tiered Rate Limit consolidated to Redis (stateful) Endpoint Tiered Rate Limit consolidated to Redis (stateful) The service rate limits apply to all traffic in the gateway, while the endpoint rate limits apply to specific endpoints where you include them.</description></item><item><title>Rate Limit Tiers</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/tiered-rate-limit/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/tiered-rate-limit/</guid><description>The rate limit based on tiers allows you to have multiple sets of service and endpoint rate limits that apply differently to users depending on their tier or sometimes called subscription plans.
There are four variants of the Tiered Rate Limit:
Service Tiered Rate Limit (stateless) Endpoint Tiered Rate Limit (stateless) Service Tiered Rate Limit consolidated to Redis (stateful) Endpoint Tiered Rate Limit consolidated to Redis (stateful) The service rate limits apply to all traffic in the gateway, while the endpoint rate limits apply to specific endpoints where you include them.</description></item><item><title>Rate Limit Tiers</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/tiered-rate-limit/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/tiered-rate-limit/</guid><description>The rate limit based on tiers allows you to have multiple sets of service and endpoint rate limits that apply differently to users depending on their tier or sometimes called subscription plans.
There are four variants of the Tiered Rate Limit:
Service Tiered Rate Limit (stateless) Endpoint Tiered Rate Limit (stateless) Service Tiered Rate Limit consolidated to Redis (stateful) Endpoint Tiered Rate Limit consolidated to Redis (stateful) The service rate limits apply to all traffic in the gateway, while the endpoint rate limits apply to specific endpoints where you include them.</description></item><item><title>Rate Limit Tiers</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/tiered-rate-limit/</link><pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/tiered-rate-limit/</guid><description>The rate limit based on tiers allows you to have multiple sets of service and endpoint rate limits that apply differently to users depending on their tier or sometimes called subscription plans.
For example, Mary has a Gold plan that entitles her to make more requests per second than John, who is in an inferior Silver plan:
The tiered rate limit component allows you to get a header from the requests that set the tier a user belongs to.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/v2.10/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting in KrakenD API Gateway Backends</title><link>https://www.krakend.io/docs/enterprise/v2.5/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/v2.6/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/v2.7/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/v2.8/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/enterprise/v2.9/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.10/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.5/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.6/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.7/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.8/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Rate Limiting Backends</title><link>https://www.krakend.io/docs/v2.9/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/backends/rate-limit/</guid><description>No matter what amount of activity the users generate at the router level, you can limit KrakenD&amp;rsquo;s connections to your backends. The configuration is similar to the router&amp;rsquo;s rate limit, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
The limit applies per defined backend entry and does not consider the activity other backends generate. Each backend entry handles its counters and does not share them with different backends or endpoints.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.10/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.5/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.6/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.7/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.8/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless Cluster Throttling: Optimize API Performance</title><link>https://www.krakend.io/docs/v2.9/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/cluster/</guid><description>The stateless rate-limiting (service Enterprise or endpoint types) is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateful endpoint rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/throttling/endpoint-redis-rate-limit/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/endpoint-redis-rate-limit/</guid><description>The Stateful Endpoint Rate Limit based on Redis centralizes the activity of all KrakenD instances rate limiting. It works identically to the stateful service rate limit but applies the limits to specific endpoints instead of the whole service.
You should always use the stateless rate limit unless an unavoidable business rule forces you to choose this one. The stateless rate limit does not need any database and does not generate network activity to manage the token bucket.</description></item><item><title>Stateful endpoint rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/endpoint-redis-rate-limit/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/endpoint-redis-rate-limit/</guid><description>The Stateful Endpoint Rate Limit based on Redis centralizes the activity of all KrakenD instances rate limiting. It works identically to the stateful service rate limit but applies the limits to specific endpoints instead of the whole service.
You should always use the stateless rate limit unless an unavoidable business rule forces you to choose this one. The stateless rate limit does not need any database and does not generate network activity to manage the token bucket.</description></item><item><title>Stateful endpoint rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/endpoint-redis-rate-limit/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/endpoint-redis-rate-limit/</guid><description>The Stateful Endpoint Rate Limit based on Redis centralizes the activity of all KrakenD instances rate limiting. It works identically to the stateful service rate limit but applies the limits to specific endpoints instead of the whole service.
You should always use the stateless rate limit unless an unavoidable business rule forces you to choose this one. The stateless rate limit does not need any database and does not generate network activity to manage the token bucket.</description></item><item><title>Stateful endpoint rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/endpoint-redis-rate-limit/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/endpoint-redis-rate-limit/</guid><description>The Stateful Endpoint Rate Limit based on Redis centralizes the activity of all KrakenD instances rate limiting. It works identically to the stateful service rate limit but applies the limits to specific endpoints instead of the whole service.
You should always use the stateless rate limit unless an unavoidable business rule forces you to choose this one. The stateless rate limit does not need any database and does not generate network activity to manage the token bucket.</description></item><item><title>Stateful service rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/global-rate-limit/</guid><description>The Redis rate limit functionality enables a Redis database store to centralize all KrakenD rate limit counters. Instead of having each KrakenD node count its hits in memory, the counters are global and persist in the database.
Rate limit (stateless) vs. Redis-backed rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster and want to limit a specific group of users to 100 requests per second.</description></item><item><title>Stateful service rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/global-rate-limit/</guid><description>The Redis rate limit functionality enables a Redis database store to centralize all KrakenD rate limit counters. Instead of having each KrakenD node count its hits in memory, the counters are global and persist in the database.
Rate limit (stateless) vs. Redis-backed rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster and want to limit a specific group of users to 100 requests per second.</description></item><item><title>Stateful service rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/global-rate-limit/</guid><description>The Redis rate limit functionality enables a Redis database store to centralize all KrakenD rate limit counters. Instead of having each KrakenD node count its hits in memory, the counters are global and persist in the database.
Rate limit (stateless) vs. Redis-backed rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster and want to limit a specific group of users to 100 requests per second.</description></item><item><title>Stateful service rate limit (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/global-rate-limit/</guid><description>The Redis rate limit functionality enables a Redis database store to centralize all KrakenD rate limit counters. Instead of having each KrakenD node count its hits in memory, the counters are global and persist in the database.
Rate limit (stateless) vs. Redis-backed rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster and want to limit a specific group of users to 100 requests per second.</description></item><item><title>Rate Limiting the API Gateway (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Rate Limiting the API Gateway (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Rate Limiting the API Gateway (Redis backed)</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.10/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.5/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.6/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.7/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.8/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Bot Detection and Throttling Guide: Prevent API Abuse</title><link>https://www.krakend.io/docs/v2.9/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Connecting to other AI vendors</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/other-vendors/</link><pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/other-vendors/</guid><description>If you need to connect to an AI vendor that is not listed in the pre-defined list of abstracted interfaces, you can still perform the abstraction by providing a template.
On KrakenD you can implement completely different models while you keep the user away from this process.
The way to adapt the payload sent to each LLM, you need to pass the right request template to each LLM. This is achieved with the request body generator which takes care of this job.</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v1.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v1.4/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.0/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.1/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.10/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.2/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.4/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.5/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.6/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.7/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.8/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Comprehensive Guides for KrakenD API Gateway</title><link>https://www.krakend.io/docs/v2.9/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
Add a link User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } }
stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v1.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v1.4/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v2.0/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } }
stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.1/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.2/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.3/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.4/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.0/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.1/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.2/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.3/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.4/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/v2.10/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API in KrakenD API Gateway Telemetry</title><link>https://www.krakend.io/docs/enterprise/v2.5/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/v2.6/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/v2.7/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/v2.8/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/enterprise/v2.9/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/v2.10/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API Telemetry</title><link>https://www.krakend.io/docs/v2.5/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/v2.6/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/v2.7/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/v2.8/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended Metrics API</title><link>https://www.krakend.io/docs/v2.9/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/telemetry/extended-metrics/</guid><description>The metrics API offers a new /__stats/ endpoint in a different port and contains a lot of metrics that you can scrape in a custom collector, or you can push them to InfluxDB.
This component is unrelated to the OpenTelemetry metrics, and they can coexist. Previous to the creation of OpenTelemetry, the combination of Influx and the metrics API, offered the older versions of Grafana dashboard.
Configuration In order to add the metrics API to your KrakenD installation add the telemetry/metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.1/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.2/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.3/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.4/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating KrakenD Configuration from v1.x or v0.x</title><link>https://www.krakend.io/docs/enterprise/v2.5/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.0/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.1/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.2/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.3/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.4/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Migrating KrakenD Configuration from v1.x or v0.x</title><link>https://www.krakend.io/docs/v2.5/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.0 and above Use git or similar DVCS to track the changes.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/v2.10/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/v2.6/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/v2.7/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/v2.8/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/enterprise/v2.9/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/v2.10/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/v2.6/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/v2.7/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/v2.8/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>Upgrading KrakenD from an older version</title><link>https://www.krakend.io/docs/v2.9/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/configuration/migrating/</guid><description>Upgrading to a new version of KrakenD is designed to be straightforward, thanks to our commitment to maintaining backward compatibility across versions within the same major release (e.g., within 2.x versions). You can generally update KrakenD to a newer version without altering your configuration. However, to ensure optimal performance and access to the latest features, reviewing and adjusting your configuration is wise.
KrakenD&amp;rsquo;s upgrade policy Our policy focuses on minimizing disruption by preserving compatibility with previous versions.</description></item><item><title>AI usage monitoring</title><link>https://www.krakend.io/docs/ai-gateway/usage-monitoring/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/ai-gateway/usage-monitoring/</guid><description>Monitoring AI backends in KrakenD does not require special treatment. AI services are integrated and handled just like any other backend in your API Gateway. Your existing monitoring tools and practices, such as OpenTelemetry, remain fully applicable.
AI backends, regardless of their complexity, respond to API calls just like any other backend service. KrakenD treats AI integrations as regular backends. This simplifies observability and operational consistency by applying proven monitoring frameworks without specialized or separate tooling.</description></item><item><title>AI usage monitoring</title><link>https://www.krakend.io/docs/enterprise/ai-gateway/usage-monitoring/</link><pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/ai-gateway/usage-monitoring/</guid><description>Monitoring AI backends in KrakenD does not require special treatment. AI services are integrated and handled just like any other backend in your API Gateway. Your existing monitoring tools and practices, such as OpenTelemetry, remain fully applicable.
AI backends, regardless of their complexity, respond to API calls just like any other backend service. KrakenD treats AI integrations as regular backends. This simplifies observability and operational consistency by applying proven monitoring frameworks without specialized or separate tooling.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.10/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.6/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.7/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.8/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.9/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.10/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.6/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.7/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.8/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.9/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.10/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.5/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.6/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.7/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.8/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>How API Traffic Throttling with Token Bucket algorithm works</title><link>https://www.krakend.io/docs/v2.9/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy If you ever went to a traveling carnival, funfair, or amusement park to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the carousel operator, bumper cars, or chance games stand to collect the payment faster and allow or deny access.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.10/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.5/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.6/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.7/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.8/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.9/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.10/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.5/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.6/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.7/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.8/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Understanding Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.9/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat krakend.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/v1.3/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat krakend.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/v1.4/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat krakend.</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, you should spend a few minutes understanding the big pieces of the system, how they work, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very, very important) Failing fast is better than succeeding slow The simpler, the better Everything is pluggable Each request must be processed in its request-scoped context KrakenD internal states When you start KrakenD, the system goes through two different internal states: building and working.</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v2.0/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, you should spend a few minutes understanding the big pieces of the system, how they work, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very, very important) Failing fast is better than succeeding slow The simpler, the better Everything is pluggable Each request must be processed in its request-scoped context KrakenD internal states When you start KrakenD, the system goes through two different internal states: building and working.</description></item><item><title>KrakenD EE v2.11: New AI integrations and Conditional Routing</title><link>https://www.krakend.io/blog/krakend-ee-2.11-release-notes/</link><pubDate>Tue, 23 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.11-release-notes/</guid><description>The new version EE v2.11 brings native AI Gateway integrations with AI providers such as OpenAI, Google Gemini, Anthropic (Claude), and Mistral. While using these vendors was already possible, we have reduced the amount of configuration needed. Alongside this, a new Conditional Routing component allows dynamic request routing and aggregation based on request data, greatly enhancing API orchestration flexibility.
AI Gateway integrations The OpenAI, Google Gemini, Anthropic (Claude), and Mistral integrations let you embed powerful AI-driven capabilities inside your APIs with minimal configuration.</description></item><item><title>KrakenD CE v2.11 released with improved AMQP, JWT, caching and more</title><link>https://www.krakend.io/blog/krakend-2.11-release-notes/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.11-release-notes/</guid><description>This release of KrakenD Community Edition v2.11 brings a substantial upgrade to message queue integration, improved JWT handling, enhanced HTTP client capabilities, telemetry configuration flexibility, and important bug fixes that improve stability and performance.
AMQP Driver Overhaul We&amp;rsquo;ve replaced the previous AMQP driver with the official RabbitMQ client maintained by the RabbitMQ Core Team. This change means better ongoing support, quicker bug fixes, and enhanced capabilities. Importantly, no action is required from you to adapt existing configurations.</description></item><item><title>Suvoda Case Study: Scaling eClinical Integrations</title><link>https://www.krakend.io/case-study/suvoda/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/suvoda/</guid><description>Faced with the task of streamlining external integration workflows for its global clinical trial technology platform, Suvoda encountered a challenging landscape. The clinical trials the platform supports are often highly complex and operate on tight timelines.
Unifying a fast-growing API ecosystem Suvoda needed a more efficient way to manage third party integrations with other clinical technology provider solutions. The objective: create a single integration layer that simplifies client connectivity, scales effortlessly, and enforces consistent security and governance.</description></item><item><title>KrakenD joins Shop Circle to accelerate global expansion</title><link>https://www.krakend.io/blog/krakend-joins-shopcircle/</link><pubDate>Sat, 02 Aug 2025 08:12:51 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-joins-shopcircle/</guid><description>KrakenD today announced it has joined Shop Circle, the global AI-driven software group that powers modern enterprises with mission-critical tools, in a strategic move that will accelerate KrakenD’s growth and global reach while preserving its vision, roadmap, and commitment to customers.
Since its creation in 2016, KrakenD has been dedicated to building the fastest, most reliable, and developer-first API Gateway. Today it powers mission-critical infrastructures across government, finance, telecom, healthcare, and Fortune 500 companies, with deployments on millions of servers worldwide.</description></item><item><title>KrakenD Cookie Policy</title><link>https://www.krakend.io/cookies-policy/</link><pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/cookies-policy/</guid><description>KRAKEND, S.L., (hereinafter, &amp;ldquo;KrakenD&amp;rdquo; or the “Company”) informs you, through this cookie policy, (hereinafter, &amp;ldquo;Cookie Policy&amp;rdquo;) about the use of data storage and retrieval devices in the terminal equipment of the users.
1.- WHAT ARE COOKIES AND WHAT ARE THEY FOR? Cookies are files that are downloaded to your computer / smartphone / tablet as a User (hereinafter, the &amp;ldquo;User&amp;rdquo;), when accessing certain websites and applications, which allow the storage and retrieval of your data.</description></item><item><title>KrakenD Terms and Conditions</title><link>https://www.krakend.io/terms/</link><pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/terms/</guid><description>Website owner KRAKEND, S.L., (hereinafter KrakenD or the “Company”). Registered Address Plaça Universitat 3, 6º, CP 08007, Barcelona Contact hello@krakend.io Registry details Registro Mercantil de Barcelona; T 47888, F 124 H 565484 TAX CODE B06933832 The website has been created to offer detailed and updated information on the services of KrakenD. KrakenD offers a commercial website for the KrakenD API Gateway software and offers documentation for the software operation and several software utils to help operate it.</description></item><item><title>Culture Amp Case Study: Success Story</title><link>https://www.krakend.io/case-study/cultureamp/</link><pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/cultureamp/</guid><description>I don&amp;rsquo;t need to think about KrakenD, it just works. &amp;ndash; Dave McPherson, Platform Engineering Lead
As Culture Amp scaled, managing API traffic efficiently became a critical need. The company sought an API gateway that could:
Route traffic to upstream services efficiently. Validate authenticated requests. Protect upstream services using throttling and circuit breakers. Manipulate requests and responses when necessary. Provide centralized, coarse-grained observability of external-facing APIs. Why KrakenD? Culture Amp chose KrakenD because of its lightweight, high-performance architecture and powerful feature set.</description></item><item><title>KrakenD is Now SOC 2 Type II Certified: Our Commitment to Your Security, Officially Verified</title><link>https://www.krakend.io/blog/soc2-certification-announcement/</link><pubDate>Thu, 19 Jun 2025 11:02:12 +0200</pubDate><guid>https://www.krakend.io/blog/soc2-certification-announcement/</guid><description>If there is one thing we know about APIs, it’s that security is no joke, even if sometimes security jargon sounds like an acronym soup nobody wants for lunch. That is why today, we&amp;rsquo;re beyond pleased to share that KrakenD is now SOC 2 Type II certified.
After months of audits, sweat, and yes, the occasional “Are we done yet?” moments from our team, we proudly hold this certification that shows we don’t just talk the security talk.</description></item><item><title>KrakenD CE and EE 2.10.1 (bugfixing) released</title><link>https://www.krakend.io/blog/krakend-2.10.1-ee-ce-release-notes/</link><pubDate>Thu, 19 Jun 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.10.1-ee-ce-release-notes/</guid><description>This minor release of KrakenD - Community Edition and Enterprise Edition - is a security fix and introduces small bug resolution in the Enterprise version.
Both CE and EE now run on Go 1.24.4, which includes patches for security vulnerabilities included in the language.
🚀 Summary of changes for EEv2.10.1 (patch) Minor fixes on weighted quotas and middleware plugins
The no-op encoding for Enterprise is now compatible with streaming. Allow the direct WebSockets connection to forward query strings.</description></item><item><title>Neo4j Case Study: Scaling Internal API Infrastructure</title><link>https://www.krakend.io/case-study/neo4j/</link><pubDate>Thu, 19 Jun 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/neo4j/</guid><description>KrakenD doesn’t try to do too much. That’s a feature, not a bug. Other gateways make complexity the default—you end up needing UIs just to manage their bloat. KrakenD is the opposite: well-documented, simple, powerful. It just works.
Challenge: Taming API Chaos Across Teams As Neo4j’s internal APIs rapidly multiplied across development teams, the complexity of managing secure, scalable access grew unsustainable. The existing API gateway setup lacked the flexibility needed to address authentication workflows consistently across services.</description></item><item><title>How Diebold Nixdorf Simplified their Retail API Platform</title><link>https://www.krakend.io/case-study/diebold-nixdorf/</link><pubDate>Fri, 13 Jun 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/diebold-nixdorf/</guid><description>I appreciate solutions that strike the right balance between power and simplicity. KrakenD does exactly that, and more. It’s now an integral part of our digital infrastructure.
The Challenge: Simplifying API Exposure at Scale Within the Retail vertical, Diebold Nixdorf needed to expose a new generation of public-facing APIs. These APIs serve internal Customer Services teams and, in some cases, customers directly. The goals: fast performance, low operational overhead, and architectural flexibility.</description></item><item><title>KrakenD EE v2.10: AI Gateway &amp; Quota management</title><link>https://www.krakend.io/blog/krakend-ee-2.10-release-notes/</link><pubDate>Wed, 04 Jun 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.10-release-notes/</guid><description>With the release of KrakenD Enterprise Edition v2.10, we&amp;rsquo;re thrilled to unveil a game-changing innovation that marks a new era in API management: AI Gateway functionality. This release includes several powerful enhancements to logging, quota management, observability, and developer tooling to better adopt AI in your company. Let&amp;rsquo;s dive into the highlights.
The KrakenD AI Gateway Vision As AI adoption explodes, organizations face pressure to integrate intelligent systems into their architectures without compromising control, cost, or compliance.</description></item><item><title>MyCarrier: One Powerful API for Smarter Logistics</title><link>https://www.krakend.io/case-study/mycarrier/</link><pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/mycarrier/</guid><description>MyCarrier is a technology-driven logistics company dedicated to carrier management. By connecting shippers directly with carriers through its platform, MyCarrier empowers businesses to simplify their shipping operations and access real-time rates, shipping data, and carrier information.
Unifying Microservices into a Single, Manageable API Gateway To maintain a streamlined, secure, and high-performance interface, MyCarrier needed an API gateway that could unify multiple microservices into a single public-facing API, deployed in their existing Kubernetes ecosystem.</description></item><item><title>KrakenD CE v2.10 released with new Docker official image, LRU cache, and more</title><link>https://www.krakend.io/blog/krakend-2.10-release-notes/</link><pubDate>Tue, 06 May 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.10-release-notes/</guid><description>We’re excited to announce that KrakenD v2.10 is out now! This release brings new features, enhancements for developers, important deprecations, and critical fixes that improve your KrakenD experience. Let’s dive into what’s new:
Goodbye Docker image! Hello, Official Docker image! As we announced a few days ago, KrakenD is now an official Docker image! 🎉
The old image devopsfaith/krakend is now deprecated and no longer maintained. Please rename your Docker image source to the official krakend image to continue receiving security updates and verified builds.</description></item><item><title>KrakenD is now an official Docker image!</title><link>https://www.krakend.io/blog/official-docker-image/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/official-docker-image/</guid><description>We&amp;rsquo;re thrilled to announce a major milestone for the KrakenD community: KrakenD is now available as an official Docker image! 🎉
This means that open source users can pull KrakenD directly from Docker Hub using the much simpler and cleaner image name:
docker pull krakend No more relying on third-party or community-maintained images. KrakenD now sits alongside the most trusted and widely-used projects in the Docker ecosystem.
What changes for you?</description></item><item><title>KrakenD v2.9.4 CE and EE security releases</title><link>https://www.krakend.io/blog/krakend-2.9.4-ce-ee-release-notes/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.9.4-ce-ee-release-notes/</guid><description>KrakenD CE 2.9.4 and KrakenD EE 2.9.4 are security releases that address several newly disclosed vulnerabilities affecting KrakenD EE and CE. The release ensures enhanced protection against known threats and maintains compliance with industry best practices for secure API gateways.
All KrakenD users are strongly encouraged to upgrade to version 2.9.4, even though some of the severities of these vulnerabilities have yet to be classified, and the potential impact is unknown.</description></item><item><title>KrakenD v2.9.2 and v2.9.3 security releases</title><link>https://www.krakend.io/blog/krakend-2.9.2-2.9.3-ce-ee-release-notes/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.9.2-2.9.3-ce-ee-release-notes/</guid><description>With just one day of difference two CVEs required the attention of KrakenD to publish new security versions.
KrakenD Enterprise 2.9.2 and KrakenD Community 2.9.2 have been released on March 4th and announced to customers via Slack/Email on that day before writing blog post. We strongly recommend all users using JWT validation upgrade to this version as soon as possible. The severity for this vulnerability is classified as moderate.
In addition, one day later, on March 5th, another CVE was published by the Go community, affecting the proxy package.</description></item><item><title>Changing component execution order with KrakenD Workflows</title><link>https://www.krakend.io/blog/customizing-execution-order-with-workflows/</link><pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/customizing-execution-order-with-workflows/</guid><description>Components of the API Gateway play a crucial role in validating, proxying, transforming, and securing requests and responses. We call these components the &amp;ldquo;middleware ,&amp;rdquo; which execute in a predefined order. For instance, you validate a JWT token first, then transform the request later, not vice versa. You can find here the component execution order.
However, there will be times when guaranteeing an execution order is vital for your logic. KrakenD Workflows provide an elegant way to define the sequence in which internal middleware should execute.</description></item><item><title>KrakenD EE v2.9 released: Redis Cluster Support, LRU, WebSockets Upgrades &amp; More!</title><link>https://www.krakend.io/blog/krakend-ee-2.9-release-notes/</link><pubDate>Fri, 07 Feb 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.9-release-notes/</guid><description>We&amp;rsquo;re excited to announce the release of KrakenD Enterprise Edition (EE) 2.9, packed with powerful new features and enhancements across a lot of components. This release brings greater flexibility, caching improvements, Redis Cluster support, enhanced WebSockets, and more. See below the most relevant changes.
More data on the sequential proxy The sequential proxy was limited to passing previous calls&amp;rsquo; data to the next call&amp;rsquo;s URL. Now you can propagate parameters or the entire body response of previous calls, allowing more flexibility when passing data from one backend to the other.</description></item><item><title>KrakenD CE v2.9 released with improved sequential proxy and security</title><link>https://www.krakend.io/blog/krakend-2.9-release-notes/</link><pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.9-release-notes/</guid><description>We are excited to announce the latest updates and improvements to our platform. Here&amp;rsquo;s a breakdown of the new features, bug fixes, and security enhancements:
Sequential Proxy enhancements The enhanced sequential proxy functionality of v2.9.0 provides greater flexibility with multi-step API calls. We have added a parameter sequential_propagated_params that allows you to propagate parameters to the next calls, having more data available in dependent calls. With this new parameter, you can do things like passing as the body of a request any previous response, or reuse any element of a prior response in scripts without having the requirement to pass values in the url_pattern</description></item><item><title>lastminute.com Case Study: Success Story</title><link>https://www.krakend.io/case-study/lastminute/</link><pubDate>Thu, 09 Jan 2025 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/lastminute/</guid><description>In lastminute.com, KrakenD played a vital role in our API transformation journey by protecting our business platforms boundary and exposing the business capabilities in a standard way to both internal and external audience &amp;ndash; Stefano Leopizzi
Background Over the past decade, lastminute.com has evolved its production architecture, shifting from a traditional approach to a more flexible and scalable system.
As part of this continuous evolution, lastminute.com identified opportunities to enhance governance and streamline interactions across its growing ecosystem of hundreds of microservices.</description></item><item><title>KRAKEND GENERAL TERMS OF USE</title><link>https://www.krakend.io/general-terms-of-use/</link><pubDate>Fri, 20 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/general-terms-of-use/</guid><description>These General Terms of Use (“General Terms”), along with any applicable license agreement you entered whether with KRAKEND or any of its VARs, will govern your use of and access to the Software, including without limitation applications, sample files, content files, scripts, instruction sets, customer support, and your installation of any software and related documentation. If you have agreed to our licensing terms, then these General Terms are considered part of such agreement.</description></item><item><title>KrakenD EE v2.8 released: Configurable logging, Redis-backed rate limits, Lua, YAML encoding and more</title><link>https://www.krakend.io/blog/krakend-ee-2.8-release-notes/</link><pubDate>Tue, 17 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.8-release-notes/</guid><description>We are excited to announce the release of KrakenD Enterprise 2.8, packed with new features, upgrades, bug fixes, and some deprecations. Below is a breakdown of the updates.
Configurable access logs The most acclaimed feature by our customers was the ability to customize the access log. This is why we have introduced in the new version a custom log format that allows you to define the string and fields you want to print in the stdlog.</description></item><item><title>Breaking the Mold: Rethinking the Control Plane</title><link>https://www.krakend.io/blog/rethink-control-plane/</link><pubDate>Sun, 15 Dec 2024 10:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/rethink-control-plane/</guid><description>When KrakenD was first conceived, we weren’t interested in reinventing the wheel. We wanted to break it apart and build something better. The API gateway market was crowded with solutions clinging to centralized control plane architectures—complex, fragile systems that claimed flexibility but often left teams tangled in operational webs. At KrakenD, we asked ourselves a bold question:
How can we rethink the control plane and manage it more effectively?
This question stemmed from a genuine need to rethink the industry&amp;rsquo;s reliance on traditional control planes.</description></item><item><title>KrakenD CE v2.8 released with improved Lua and OpenTelemetry</title><link>https://www.krakend.io/blog/krakend-2.8-release-notes/</link><pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.8-release-notes/</guid><description>We&amp;rsquo;re thrilled to announce the release of KrakenD Community v2.8, packed with upgrades to Lua and OpenTelemetry, and a few key fixes to improve your API gateway experience. Let&amp;rsquo;s dive into the highlights of this release.
OpenTelemetry enhancements In this release, OpenTelemetry gains the ability to override configurations at both the endpoint and backend levels. This new flexibility ensures you can fine-tune telemetry settings on a more granular level. In addition, several improvements address issues with multi-error handling, enhancing stability and reducing potential friction when working with complex setups.</description></item><item><title>How KrakenD Solves API Gateway Security Vulnerabilities</title><link>https://www.krakend.io/blog/krakend-solves-api-gateway-security-vulnerabilities/</link><pubDate>Sat, 23 Nov 2024 09:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-solves-api-gateway-security-vulnerabilities/</guid><description>API Gateways are a prime target for attackers, as highlighted by a recent Trend Micro study on API security vulnerabilities in gateways like APISIX and Kong. The research reveals alarming security gaps, including exposed admin panels, default credentials, unsandboxed script execution, and logging practices that leak sensitive information—issues that lead to severe breaches like Remote Code Execution (RCE) and data exfiltration. These misconfigurations make it easy for attackers to infiltrate, exploit, and compromise entire infrastructures.</description></item><item><title>DigitalRoute Case Study: Success Story</title><link>https://www.krakend.io/case-study/digitalroute/</link><pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/digitalroute/</guid><description>DigitalRoute has long been a leader in transforming raw usage data into revenue, with its Cloud Edition SaaS platform earning a stellar reputation for reliability and performance. But as they expanded their product portfolio to offer public APIs, the company faced a critical challenge: how to support their new &amp;ldquo;Usage Metering&amp;rdquo; feature efficiently, allowing customers to interact with their system via APIs instead of the traditional user interface.
The Turning Point: From Internal to Public APIs Before KrakenD, DigitalRoute&amp;rsquo;s system leaned heavily on internal APIs, supported by a custom-built gateway that worked well for backend needs but wasn&amp;rsquo;t equipped to handle public-facing demands.</description></item><item><title>Coop Atlantique Case Study: Success Story</title><link>https://www.krakend.io/case-study/coop-atlantique/</link><pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/coop-atlantique/</guid><description>We began by creating a model with the community version to assess its capabilities. Once we confirmed that this tool met our needs, we opted for an enterprise license. Simply to benefit from tools that facilitate integration into our model and address specific requirements of our architecture in terms of security, data transformation, and authentication management. &amp;ndash; Nicolas Gabetty
Coop Atlantique is a supermarket and hypermarket specialist who faced several challenges in integrating SAP with their service architecture while ensuring secure, scalable exposure of APIs.</description></item><item><title>Bloom Credit: Multi-Provider API Security with KrakenD</title><link>https://www.krakend.io/case-study/bloom-credit/</link><pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/bloom-credit/</guid><description>I want to highlight the exceptional support KrakenD provides. We can always expect prompt and thorough responses, I believe this has definitely accelerated our development speed and allowed us to find the right KrakenD feature that fits our needs. &amp;ndash; Akanksha Nichrelay, Senior Engineer
Bloom Credit simplifies credit-related services for financial institutions, fintechs and other businesses consuming or producing credit data. Their platform abstracts the complexities of credit bureau connectivity, enabling compliant credit inquiries and accurate payment reporting to the major US credit bureaus.</description></item><item><title>Jobteaser Case Study: Scalable Public APIs with KrakenD</title><link>https://www.krakend.io/case-study/jobteaser/</link><pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/jobteaser/</guid><description>The versatility of KrakenD allows us to use it as a &amp;lsquo;one size fits all&amp;rsquo; solution. We’ve been able to migrate all our legacy API endpoints seamlessly, and it’s now the main gateway for our services and partners alike.
The JobTeaser tech ecosystem was initiated more than a decade ago. If our platform was initially a Ruby on Rails monolith, now we manage a fleet of ever-growing services built using Ruby and Go.</description></item><item><title>KrakenD vs Kong: API Gateway Comparison for Performance &amp; Scale</title><link>https://www.krakend.io/krakend-vs-kong/</link><pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/krakend-vs-kong/</guid><description/></item><item><title>New Look, Same Vision: KrakenD’s Website Redesign</title><link>https://www.krakend.io/blog/new-look-same-vision/</link><pubDate>Wed, 02 Oct 2024 11:02:12 +0200</pubDate><guid>https://www.krakend.io/blog/new-look-same-vision/</guid><description>At KrakenD, we’re excited to introduce our new website design! While our logo and core branding remain consistent, the visual overhaul gives a fresh, modern look that better conveys what KrakenD is all about. We’ve focused on a style that highlights our core principles: simplicity, high performance, and efficiency. The new design doesn’t just look better: it helps users quickly grasp KrakenD’s added value and how our solutions can simplify their API management.</description></item><item><title>Why Rate Limiting Matters for Your API’s Health and Security</title><link>https://www.krakend.io/blog/effective-rate-limiting-traffic-management/</link><pubDate>Wed, 02 Oct 2024 09:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/effective-rate-limiting-traffic-management/</guid><description>When deploying APIs, rate limiting is one of the most critical strategies for managing traffic and ensuring system security. In this blog, we’ll dive into the fundamentals of API rate limiting and how platforms like KrakenD can help you implement scalable and robust rate-limiting mechanisms. Let’s explore the essentials of rate limiting and why it plays such a pivotal role in API traffic management.
What is Rate Limiting and Why is it Important?</description></item><item><title>KrakenD Partners with Massil Technologies for India and Middle East</title><link>https://www.krakend.io/blog/krakend-partners-with-massil-technologies/</link><pubDate>Tue, 01 Oct 2024 09:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-partners-with-massil-technologies/</guid><description>KrakenD is pleased to announce its exclusive partnership with Massil Technologies, a leading IT services provider, as the official reseller and certified KrakenD integration partner in India and the Middle East. This strategic collaboration enhances KrakenD&amp;rsquo;s ability to provide localized API gateway solutions and support to customers across these regions.
Founded in 2016, Massil Technologies is based in Hyderabad, India, and specializes in delivering rapid IT system integrations and cloud services.</description></item><item><title>Mastering Microservices Authorization: Strategies for Secure Access Control</title><link>https://www.krakend.io/blog/microservices-authorization-secure-access/</link><pubDate>Thu, 19 Sep 2024 09:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/microservices-authorization-secure-access/</guid><description>Software development has evolved significantly, and so has the way we architect applications. Microservices have emerged as a dominant pattern, offering scalability, flexibility, and resilience. The distributed nature of microservices introduces unique challenges, particularly when it comes to security. Ensuring proper authorization and access control is critical because each microservice acts as an independent unit.
In the context of microservices, access management plays a crucial role by enabling convenient authentication and authorization for both end-users and microservices.</description></item><item><title>Releases of KrakenD EE 2.7.1 and KrakenD CE 2.7.1 with minor fixes</title><link>https://www.krakend.io/blog/krakend-2.7.1-ce-ee-release-notes/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.7.1-ce-ee-release-notes/</guid><description>A new patch version of KrakenD Enterprise 2.7.1 and KrakenD Community 2.7.1 is now available on the download page and the Docker registry. This update addresses minor functionality and security improvements.
This release is classified as a security release due to CVE-2024-28180. The vulnerability could allow an attacker to send a JWE containing compressed data, which could consume significant memory and CPU resources when decompressed. However, KrakenD does not support JWE, so this issue is a false positive in security scans.</description></item><item><title>KrakenD EE v2.7: Workflows, enhanced Rate Limiting, Direct WS, and more</title><link>https://www.krakend.io/blog/krakend-ee-2.7-release-notes/</link><pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.7-release-notes/</guid><description>Today, we released KrakenD EE v2.7, the latest version of our enterprise edition. This version includes many new features and enhancements to existing components. Here&amp;rsquo;s a closer look at what&amp;rsquo;s new and why it matters.
Workflows The most exciting addition in KrakenD EE v2.7 is the new workflow component that allows you to create workflows and nest virtual endpoints without limitations. This feature is a game-changer for those managing complex API ecosystems, enabling you to orchestrate multiple API calls within the gateway efficiently.</description></item><item><title>KrakenD CE v2.7 released with better rate-limiting and security options</title><link>https://www.krakend.io/blog/krakend-2.7-release-notes/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.7-release-notes/</guid><description>We are excited to announce the latest release of KrakenD, which focuses on resource optimization and brings new features, especially on security. Here&amp;rsquo;s a detailed look at what&amp;rsquo;s new in this release:
Finer rate-limiting We have been working on optimizing the rate-limit feature, significantly reducing the RAM consumption for users of the endpoint rate limit. Generally speaking, installations using it can reduce their RAM consumption at least a 70%. No action is needed to benefit from this optimization other than upgrading your installation to v2.</description></item><item><title>MARKETPLACE SOFTWARE LICENSE AGREEMENT</title><link>https://www.krakend.io/marketplace-software-license-agreement/</link><pubDate>Mon, 01 Jul 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/marketplace-software-license-agreement/</guid><description>This Marketplace Software License Agreement (“Agreement”, “Marketplace SLA” or “MSLA”) is between you (“you”, “Licensee” or “End Customer”) and KRAKEND, S.L. a Spanish company with its registered office at Plaça Universitat 3, 6º, 08007, Barcelona, with ID ES B06933832, registered in the Barcelona Commercial Registry (“KRAKEND”, the “Licensor”, “We”, “Us”); and governs your use of the KRAKEND Software (the “Software”) purchased through either Microsoft AppSource or Azure Marketplace (collectively “Marketplace”).</description></item><item><title>Improving The Developer Experience of Your APIs</title><link>https://www.krakend.io/blog/improving-developer-experience-moesif-krakend/</link><pubDate>Sun, 02 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/improving-developer-experience-moesif-krakend/</guid><description>Contributor note This is a guest post by Matt Tanner, Head of Developer Relations at Moesif, our advanced API Analytics, Governance, and Monetization partners. Matt utilizes his extensive experience to help developers and product managers optimize the Moesif platform. As a modern organization, you’re likely building many APIs. Most are exposed internally and externally, allowing developers of varying backgrounds to leverage them. Building APIs developers love to use is the key to adoption, success, and growth.</description></item><item><title>Automating License Validity Checks with KrakenD</title><link>https://www.krakend.io/blog/automating-license-check/</link><pubDate>Wed, 08 May 2024 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/automating-license-check/</guid><description>KrakenD&amp;rsquo;s Enterprise Edition offers a feature for automated license validity checks. While we at KrakenD always take a proactive role in renewals and interim replacements, we understand the importance of automated systems in avoiding oversights, especially in critical components like your API gateway.
Why Monitor License Validity? Monitoring license validity is a crucial step in maintaining operational stability, particularly as your business scales. An expired license could lead to unexpected disruptions in your API gateway, a key component in your infrastructure.</description></item><item><title>OnchainPLM Case Study: Success Story</title><link>https://www.krakend.io/case-study/onchainplm/</link><pubDate>Tue, 30 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/onchainplm/</guid><description>OnchainPLM is a product lifecycle management (PLM) solutions provider that specializes in serving the semiconductor industry among other sectors and a leader in cloud-native technology development, that has modernized its business gateway integration with KrakenD. This case study delves into their use of our API gateway to address unique business challenges, highlighting the effectiveness of KrakenD in improving service delivery and operational efficiency.
Facing the challenge Initially, OnchainPLM faced the challenge of customizing their existing business gateways to better suit their needs.</description></item><item><title>KrakenD Enterprise v2.6 released with OpenTelemetry, FIPS-140, gRPC server and more</title><link>https://www.krakend.io/blog/krakend-ee-2.6-release-notes/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.6-release-notes/</guid><description>We&amp;rsquo;re rolling out KrakenD Enterprise v2.6, and it&amp;rsquo;s packed with new features and improvements that make managing your APIs smoother and more efficient. This version builds on everything you know and love about KrakenD Community 2.6, adding even more to the mix. Let&amp;rsquo;s break down what&amp;rsquo;s new without the fluff.
Observability and monitoring OpenTelemetry integration: We&amp;rsquo;ve integrated OpenTelemetry to give you a better way to keep an eye on your APIs through tracing and metrics.</description></item><item><title>KrakenD CE v2.6 released with OpenTelemetry</title><link>https://www.krakend.io/blog/krakend-2.6-release-notes/</link><pubDate>Tue, 05 Mar 2024 14:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-2.6-release-notes/</guid><description>We&amp;rsquo;re thrilled to share the latest KrakenD Community Edition v2.6 updates, focusing on enhancing observability, plugin development, and JWT validation. This release introduces significant improvements, new features, and an emphasis on OpenTelemetry integration.
Developers of plugins will find a new command to test plugins before you deploy them. While developing them, there is also access to more data, like the KrakenD context or the internal request, which allows for more imaginative plugins.</description></item><item><title>From OpenCensus to OpenTelemetry</title><link>https://www.krakend.io/blog/from-opencensus-to-opentelemetry/</link><pubDate>Tue, 05 Mar 2024 12:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/from-opencensus-to-opentelemetry/</guid><description>In deployments of complex, distributed, and cloud-native environments, understanding the intricacies of application behavior and performance is crucial, and this is why KrakenD integrated advanced telemetry six years ago through OpenCensus and native metrics.
With the release of KrakenD v2.6, we have created an integration for OpenTelemetry and marks a significant evolution in its observability capabilities, providing users with enhanced insights and diagnostics tools.
What are the benefits of the OTEL integration OpenTelemetry represents a pivotal shift in how telemetry data is collected and managed.</description></item><item><title>KrakenD 2023: Milestones and New Horizons</title><link>https://www.krakend.io/blog/2023-recap/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/2023-recap/</guid><description>As the year 2023 draws to a close, we at KrakenD are taking a moment to reflect on the incredible journey we&amp;rsquo;ve embarked upon together. It&amp;rsquo;s been a year marked by achievements, growth, and a relentless pursuit of excellence. We&amp;rsquo;re deeply grateful to our customers and the vibrant community that has supported us every step of the way. Your enthusiasm and trust have been the driving forces behind our success.</description></item><item><title>KrakenD Enterprise v2.5 released with API Monetization</title><link>https://www.krakend.io/blog/krakend-ee-2.5-release-notes/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.5-release-notes/</guid><description>We&amp;rsquo;re excited to announce the latest release v2.5 of KrakenD Enterprise, packed with powerful features and enhancements to make your API gateway experience even more seamless and robust. Needless to say, the KrakenD Enterprise v2.5 contains everything in the KrakenD Community 2.5 and a lot more. Let&amp;rsquo;s dive into the key changes in this release:
API Monetization and Governance Ooh la la! Our first release of KrakenD with API Monetization, in partnership with Moesif, which allows you to charge for your APIs based on usage, check the analytics, and set governance rules that KrakenD keeps in-sync in real time.</description></item><item><title>How KrakenD API Gateway uses JSON Schema</title><link>https://www.krakend.io/blog/json-schema-use-case/</link><pubDate>Mon, 20 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/json-schema-use-case/</guid><description>Adopting best practices in the dynamic realm of API development is critical to ensuring data integrity, security, and seamless interactions.
In our experience, JSON Schema (project website) emerged as a fundamental tool in this journey. Since we started using it, the developer experience has dramatically improved for KrakenD core developers and KrakenD users.
KrakenD uses JSON Schema mainly for five very distinct use cases (though there are more):
Validating incoming requests on runtime Ensure complete responses before returning them to users Validate configuration files in deployment and build processes.</description></item><item><title>API Response Manipulation: Enhanced Control and Flexibility</title><link>https://www.krakend.io/blog/response-manipulation/</link><pubDate>Mon, 13 Nov 2023 10:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/response-manipulation/</guid><description>&amp;nbsp; Table of contents Ready-to-Use Options for Response Manipulation 1. Comprehensive Manipulations: Aggregation, Filtering, Grouping, Mapping 2. Enhancing Response Manipulations with Martian 3. Enhanced Manipulation with Regular Expressions 4. Advanced Content Manipulation with a Query Language 5. Advanced Response Manipulation with Templates: Power and Versatility Extensible Options for Tailored Response Manipulation 6. Lua Scripting 7. Request / Response Custom Plugin Modifiers Conclusion: KrakenD - Power, Flexibility, and Simplicity in API Management KrakenD is a versatile tool for API management that shines in handling the complex aspects of API-based systems, and is particularly noted for its backend response manipulation.</description></item><item><title>Keep-Alive Connections And Its Critical Role While Optimizing API Performance</title><link>https://www.krakend.io/blog/keep-alive-optimizing-performance/</link><pubDate>Sun, 12 Nov 2023 20:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/keep-alive-optimizing-performance/</guid><description>An important yet often overlooked aspect while optimizing API performance is the management of HTTP keep-alive connections. KrakenD, an advanced API Gateway, offers an array of configuration parameters that significantly influence these connections. This post delves into these parameters, elucidating how they affect API performance.
Understanding Keep-Alive in HTTP HTTP keep-alive is a protocol mechanism that maintains an open connection between the client and the server. It allows multiple requests and responses over a single connection, reducing the overhead of establishing new connections, thus enhancing API performance.</description></item><item><title>KrakenD CE v2.5 released: multiple POSTs opened</title><link>https://www.krakend.io/blog/krakend-2.5-release-notes/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.5-release-notes/</guid><description>Hey KrakenD enthusiasts,
We&amp;rsquo;ve got some exciting news for you – KrakenD v2.5 is here, packed with features that take simplicity to a whole new level while tackling complex challenges head-on. Let&amp;rsquo;s dive right into the key updates that make this release worth upgrading:
Multiple POSTs When we created the aggregation feature seven years ago, we considered it too dangerous for our users to open the door to allow aggregation and sequential calls to write data to multiple targets from a single API call.</description></item><item><title>Enhancing KrakenD operations with complementing technologies</title><link>https://www.krakend.io/blog/complementary-technologies/</link><pubDate>Wed, 25 Oct 2023 10:01:33 +0200</pubDate><guid>https://www.krakend.io/blog/complementary-technologies/</guid><description>&amp;nbsp; Table of contents Local Development &amp;amp; Debugging Deployment &amp;amp; Orchestration Continuous Integration/Continuous Deployment (CI/CD) Load Balancing &amp;amp; Scalability Service Mesh &amp;amp; Internal Traffic Management Security / Auth Streaming, Queuing &amp;amp; Event-Driven Communication Monitoring, Visualization &amp;amp; Performance Optimization Conclusion Exploring platform architecture often highlights the potential of technology collaborations. KrakenD stands out by aligning effortlessly with a variety of specialized solutions and technical stacks, thanks to its unopinionated design approach.</description></item><item><title>Upgrade to mitigate the Rapid Reset Attack vulnerability</title><link>https://www.krakend.io/blog/krakend-2.4.6-ce-2.4.2-ee-release-notes/</link><pubDate>Thu, 12 Oct 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.4.6-ce-2.4.2-ee-release-notes/</guid><description>A new patch version KrakenD Enterprise 2.4.2, and another for KrakenD Community 2.4.6 is available on the download page and the Docker registry, addressing a critical security issue related to Distributed Denial of Service (DDoS) vulnerabilities in HTTP/2 server implementations
More specifically this upgrade addresses CVE-2023-44487 and CVE-2023-39325&amp;quot;, known as the &amp;ldquo;Rapid Reset Attack.&amp;rdquo;
These vulnerabilities have been rated with a CVSSv3 Score of 7.5 and are classified as having an important security impact.</description></item><item><title>KrakenD Training: The Definitive Certification Program for API Gateway Mastery</title><link>https://www.krakend.io/blog/krakend-api-gateway-training-certification/</link><pubDate>Thu, 28 Sep 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-api-gateway-training-certification/</guid><description>We&amp;rsquo;re thrilled to unveil KrakenD Training, a certification program that stands out in its depth and breadth. Crafted by the very engineers who developed KrakenD, this program is designed for tech professionals who are serious about mastering the full spectrum of features offered by KrakenD&amp;rsquo;s API Gateway.
Why Choose KrakenD Training? In an industry where specialized knowledge is your strongest asset, KrakenD Training offers:
Technical Depth: The course covers KrakenD&amp;rsquo;s extensive feature set, ensuring you become proficient in a wide range of use cases.</description></item><item><title>Unlocking the Power of OpenAPI with KrakenD Enterprise</title><link>https://www.krakend.io/blog/openapi-krakend-enterprise/</link><pubDate>Tue, 26 Sep 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/openapi-krakend-enterprise/</guid><description>If you&amp;rsquo;re in the API game, you&amp;rsquo;ve likely heard of the OpenAPI Specification (OAS). But have you ever wondered how to leverage it to its fullest potential? In this blog post, we&amp;rsquo;ll dive deep into what OpenAPI is, its key use cases, and how KrakenD Enterprise customers can harness its capabilities to streamline their API management.
What is OpenAPI? OpenAPI is a specification for building APIs. It serves as a blueprint that describes how your API works and what it can do.</description></item><item><title>Mastering API Rate Limiting with KrakenD: A Comprehensive Guide</title><link>https://www.krakend.io/blog/api-rate-limit/</link><pubDate>Mon, 25 Sep 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/api-rate-limit/</guid><description>When it comes to managing APIs effectively with KrakenD, understanding the intricacies of rate limiting is essential. This guide provides a deep dive into rate limiting within KrakenD, covering its importance, types, best practices, and future trends.
Understanding Rate Limiting in KrakenD: Types and Roles Rate limiting serves multiple functions, from resource allocation and security to ensuring API availability. KrakenD offers a variety of rate limiting options to suit different needs:</description></item><item><title>Automating the Software Bill of Materials (SBOM)</title><link>https://www.krakend.io/blog/generating-a-sbom/</link><pubDate>Wed, 13 Sep 2023 11:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/generating-a-sbom/</guid><description>We can define a Software Bill of Materials (SBOM) as a comprehensive inventory of open-source and third-party components within a codebase.
It includes component licenses, versions, and patch status to assess security and license risks. This concept draws inspiration from manufacturing, where product inventory lists are vital. Like an automotive Bill of Materials, an SBOM helps identify and address issues in software components efficiently.
Organizations need SBOMs due to security breaches, prompting cybersecurity guidelines.</description></item><item><title>KrakenD Enterprise 2.4.1 (bugfixing) released</title><link>https://www.krakend.io/blog/krakend-ee-2.4.1-release-notes/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.4.1-release-notes/</guid><description>The new KrakenD Enterprise version 2.4.1 is already available for install or upgrade. This patch version fixes primarly WebSocket connectivity.
🚀 Summary of changes for EEv2.4.1 (patch) This release fixes the buffer size of WebSocket messages.
WebSocket messages larger than 4KB were split despite overriding this behavior with max_message_size Corrected the $schema URL when using the --lint flag to point to the correct version Corrected a continuous restart of the :watch Docker container when using the new Advanced Flexible Configuration for the first time Upgrading to the latest version is always advised.</description></item><item><title>Securing Sensitive Data with KrakenD API Data Masking</title><link>https://www.krakend.io/blog/api-data-masking/</link><pubDate>Sun, 10 Sep 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/api-data-masking/</guid><description>Securing sensitive data is a non-negotiable requirement for organizations. API data masking is a robust security measure that can help you achieve this. This article dives into the mechanics of API data masking and how KrakenD&amp;rsquo;s features like regex content replacer and response body generator can make this process more efficient and compliant.
Understanding API Data Masking API data masking is a technique that replaces original data with random or pseudonymous data.</description></item><item><title>KrakenD Enterprise v2.4: New Power and Efficiency</title><link>https://www.krakend.io/blog/krakend-ee-2.4-release-notes/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.4-release-notes/</guid><description>We are thrilled to announce the upcoming release of KrakenD API Gateway v2.4 (download, a significant step forward in enhancing your API management experience. Packed with an array of powerful features and improvements, this release is set to improve the way you manage and optimize your APIs.
As the API landscape evolves, KrakenD remains dedicated to providing cutting-edge tools to optimize and manage your APIs. The v2.4 release showcases our commitment to innovation, flexibility, and security, ensuring that you have the best possible resources at your disposal.</description></item><item><title>Instill AI Case Study: Success Story</title><link>https://www.krakend.io/case-study/instill/</link><pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/instill/</guid><description>Initial Challenges In our pursuit of harnessing unstructured data&amp;rsquo;s value, we faced challenges in our microservice architecture that required a portable, lightweight, and high-performance API Gateway solution. This was crucial for maintaining real-time end-to-end requirements while ensuring seamless integration with our existing technologies. Our Scenario
KrakenD emerged as the perfect solution for our needs. We seamlessly integrated KrakenD into both Instill Core and Instill Cloud&amp;rsquo;s API Gateways. This integration not only improved our microservice architecture&amp;rsquo;s efficiency but also streamlined our entire data processing pipeline.</description></item><item><title>Securing Your Microservices and APIs: The KrakenD Way</title><link>https://www.krakend.io/blog/securing-your-microservices/</link><pubDate>Wed, 26 Jul 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/securing-your-microservices/</guid><description>In today&amp;rsquo;s world, where everything is going digital, we can&amp;rsquo;t overemphasize the importance of keeping your APIs and microservices safe. Cyber threats are an everyday reality, and they don&amp;rsquo;t care how big or complex your infrastructure is. They just want a way in. This is where KrakenD, a leading API gateway company, steps in. We&amp;rsquo;ve got your back with our robust solution, built around a zero-trust policy, OWASP guidelines, and a bunch of other cool stuff to bolster your API security.</description></item><item><title>The Importance of an API Gateway in Modern Services Architecture</title><link>https://www.krakend.io/blog/importance-of-api-gateway-modern-services-architecture/</link><pubDate>Sun, 23 Jul 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/importance-of-api-gateway-modern-services-architecture/</guid><description>How KrakenD Steers the Fleet As we traverse the evolving landscape of modern services architecture, the significance of an API Gateway cannot be overstated. At KrakenD, we are not just participating in this evolution but leading it. We have channeled our expertise into developing an API Gateway solution that is efficient, scalable, and perfectly tuned to meet the specific needs of the digital age.
What is an API Gateway? Think of an API Gateway as the touchpoint that connects your clients to your backend services.</description></item><item><title>KrakenD CE 2.4.2 and EE 2.3.3 security fixes</title><link>https://www.krakend.io/blog/krakend-2.4.2-ce-2.3.3-ee-release-notes/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.4.2-ce-2.3.3-ee-release-notes/</guid><description>A new patch version KrakenD Enterprise 2.3.3, and another for KrakenD Community 2.4.2 is available on the download page and the Docker registry. Upgrading from any 2.x is backward compatible.
The following security fixes do not seem to have any impact on KrakenD after all the tests performed, but a patch is offered as a cautionary measure.
🚀 Summary of changes for CEv2.4.2 (patch) We have updated our internal libraries to rectify security issues identified in scans.</description></item><item><title>REST vs gRPC vs GraphQL in KrakenD: A Comprehensive Comparison</title><link>https://www.krakend.io/blog/rest-grpc-graphql-krakend-comparison/</link><pubDate>Wed, 05 Jul 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/rest-grpc-graphql-krakend-comparison/</guid><description>Understanding the landscape of APIs and making the right choice can seem daunting, especially with a myriad of available technologies. This is where KrakenD, your trusted partner in API management, steps in. We offer an in-depth comparison of three leading technologies: REST, gRPC, and GraphQL, examining their strengths, drawbacks, and how they integrate with KrakenD.
REST: The Reliable Partner Enhanced by KrakenD REST (Representational State Transfer) is a time-tested, reliable technology in the API world.</description></item><item><title>Canary releases with KrakenD: Safely roll out API changes</title><link>https://www.krakend.io/blog/canary-releases/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/canary-releases/</guid><description>Canary release is a powerful technique that helps organizations deploy changes to their APIs in a controlled and gradual manner. Instead of publishing changes to receive the impact of all traffic when going live, you expose the changes to a small subset of the traffic. The Canary Release allows for thorough monitoring and validation, reducing the risk of potential issues affecting the entire system.
This blog post will explore three ways of implementing Canary Releases on KrakenD, ensuring smoother deployments and enhanced reliability.</description></item><item><title>KrakenD 2.4.1 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.4.1-release-notes/</link><pubDate>Sun, 02 Jul 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.4.1-release-notes/</guid><description>A new patch version KrakenD 2.4.1 is available on the download page and the Docker registry. Upgrading from any 2.x is backward compatible.
🚀 Summary of changes for CEv2.4.1 (patch) Fix on the new rate limit component
The rate limit did not load because its namespace was internally rewritten using an ancient namespace (KrakenD v1) Upgrading to the latest version is always advised. Compare versions Upgrade to v2.4.1</description></item><item><title>KrakenD CE v2.4 released!</title><link>https://www.krakend.io/blog/krakend-2.4-release-notes/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.4-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD Community Edition v2.4, which improves configuration granularity, and a more user-friendly rate limit.
You can get v2.4 packaged for several options from the download page.
🚀 Summary of changes for CEv2.4 The v2.4 improves the rate limit usage experience to support non-second time intervals, and offers more granularity option to improve security.
A rewritten rate limit introduces the every component, allowing to set limits per second, minute, or hour.</description></item><item><title>Modernizing your legacy SOAP services with KrakenD</title><link>https://www.krakend.io/blog/modernizing-soap-services/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/modernizing-soap-services/</guid><description>We are thrilled to introduce one of our latest features: SOAP integration. This powerful integration is designed to help businesses modernize their legacy SOAP systems without the need for extensive modifications.
Understanding SOAP and Its Limitations SOAP (Simple Object Access Protocol) is a protocol specification for exchanging structured information in web services using XML. It operates over HTTP for simplicity and compatibility, but also supports other protocols such as SMTP. SOAP&amp;rsquo;s primary application is in large-scale enterprise environments with high security and transactional requirements.</description></item><item><title>Step-by-step Migration Guide: From AWS API Gateway to KrakenD API Gateway</title><link>https://www.krakend.io/blog/migrate-aws-api-gateway-to-krakend/</link><pubDate>Fri, 23 Jun 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/migrate-aws-api-gateway-to-krakend/</guid><description>Introduction As you consider migrating from AWS API Gateway to KrakenD API Gateway, you&amp;rsquo;re likely driven by a number of compelling benefits such as a better pricing model, reduced vendor lock-in, operational simplicity, enhanced content manipulation and transformation capabilities, increased connectivity protocols, and extensibility trough Custom golang Plugins or Lua scripts. This guide will walk you through the primary steps and considerations in this migration process.
Pre-Migration Before starting the migration process, it&amp;rsquo;s essential to make sure to map your existing API Gateway resources to equivalent KrakenD concepts, which include endpoints, routers, and backends.</description></item><item><title>KrakenD Enterprise 2.3.2 (bugfixing) released</title><link>https://www.krakend.io/blog/krakend-ee-2.3.2-release-notes/</link><pubDate>Thu, 22 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.3.2-release-notes/</guid><description>The new KrakenD Enterprise version 2.3.2 is already available for install or upgrade. This patch version fixes a few corner cases of several components that could not work properly in edge scenarios.
🚀 Summary of changes for EEv2.3.2 (patch) Small fixes on Redis rate limiter, gRPC, API keys, and Lua
Lua: Corrected bug not preventing lists to grow, and added a special type for nil treatment. API Keys: When a user key is valid, but it does not have permissions to use the resource now a 403 is returned instead of the 401 gRPC: Fix types of recursive objects Better logging on plugins Redis rate-limit: Fix a corner-case panic during startup Upgrading to the latest version is always advised.</description></item><item><title>Bikefolder Case Study: Success Story</title><link>https://www.krakend.io/case-study/bikefolder/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/bikefolder/</guid><description>With nearly a century of experience in bike retail, distribution, brand management, sport performance, and product design, BikeFolder.com has taken the pedal off the metal and shifted gears towards digital transformation. Transcending the typical CRM framework, BikeFolder.com is a universal platform fostering neutrality and connecting bike owners, retailers, and manufacturers in a cohesive environment. It optimizes interactions, streamlines inventories, service histories, and appointments while providing invaluable data for manufacturers to catalyze innovation.</description></item><item><title>KrakenD Enterprise 2.3.1 (bugfixing) released</title><link>https://www.krakend.io/blog/krakend-ee-2.3.1-release-notes/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.3.1-release-notes/</guid><description>The new KrakenD Enterprise version 2.3.1 is already available for install or upgrade. This patch version fixes a few corner cases of several components that could not work properly in edge scenarios. It also adds two small new Lua functions for working with tables and lists.
🚀 Summary of changes for EEv2.3.1 (patch) Fixes on Redis rate limiter, Alpine security upgrade, body generator, gRPC, and added new helpers in Lua</description></item><item><title>Introducing versioning in JSON schema validation</title><link>https://www.krakend.io/blog/changes-in-json-schema/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/changes-in-json-schema/</guid><description>We&amp;rsquo;re excited to announce some significant changes to the JSON schema validation in KrakenD. These updates are aimed at improving versioning and organization, providing clearer support for different KrakenD versions, and enabling broader usage of JSON schemas beyond just configuration files. Let&amp;rsquo;s delve into the details of these changes.
From a unique schema to one schema per version Previously to writing this post, we had a single schema validation URL (https://www.</description></item><item><title>Understanding API Calls: The KrakenD Approach</title><link>https://www.krakend.io/blog/api-calls/</link><pubDate>Mon, 05 Jun 2023 13:25:33 +0200</pubDate><guid>https://www.krakend.io/blog/api-calls/</guid><description>KrakenD, a market leader in high-performance API Gateway solutions, enables seamless and efficient API interactions within today&amp;rsquo;s complex digital landscape. This comprehensive guide delves into the intricate details of API calls and their pivotal role within the microservices architecture, specifically in a KrakenD environment.
Understanding API Calls: The Essence of Software Interactions APIs, or Application Programming Interfaces, form the core of sophisticated software interactions, providing the pathways for communication between different software modules.</description></item><item><title>KrakenD 2.3.3 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.3.3-release-notes/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.3.3-release-notes/</guid><description>A new patch version KrakenD 2.3.3 is available on the download page and the Docker registry. Upgrading from any 2.x is backward compatible.
This release includes a security fix to mitigate SSL3 CVE-2023-1255 (Base Score: 5.9 MEDIUM) and new Lua helpers fo facilitate developments of custom business logic. The new Lua helpers are:
luaTable.new(), which returns a new table. t:keys(), which returns the sorted key names of a table t. luaList.</description></item><item><title>KrakenD Enterprise v2.3: Easing Your API Journey</title><link>https://www.krakend.io/blog/krakend-ee-2.3-release-notes/</link><pubDate>Fri, 19 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.3-release-notes/</guid><description>KrakenD Enterprise is excited to announce the release of its API gateway software v2.3, available for download. This upgrade delivers an improved experience for users looking to simplify their operations.
With KrakenD v2.3, users will experience greater simplicity, eliminating the need for several plugins and adding automated processes to import OpenAPI and gRPC contracts.
This upgrade has been designed to address the joint pain points customers experience when managing their APIs.</description></item><item><title>Download your KrakenD License</title><link>https://www.krakend.io/download/license/</link><pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/download/license/</guid><description/></item><item><title>Optimize you API Gateway Management with Flexible Configuration</title><link>https://www.krakend.io/blog/unleash-power-flexible-configuration/</link><pubDate>Sun, 14 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/unleash-power-flexible-configuration/</guid><description>Flexible Configuration is a template-based configuration system for KrakenD API Gateway that allows you to manage configurations efficiently and cater to multiple environments. In this blog post, we&amp;rsquo;ll explore the pain-points it addresses and the benefits it brings to customers.
Challenges solved by Flexible Configuration Organizing and managing configurations can be challenging, especially when:
Configurations are extensive and need to be split into multiple files You need to inject environment-specific variables Reusable code blocks and placeholders are necessary to avoid repetition Multiple developers are working on the API gateway KrakenD is managed using multiple repositories Tracking changes, avoiding conflicts, and reviewing code is crucial Flexible Configuration is designed to tackle these pain-points effectively.</description></item><item><title>Benefits of a Stateless API Gateway</title><link>https://www.krakend.io/blog/benefits-of-stateless-api-gateway/</link><pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/benefits-of-stateless-api-gateway/</guid><description>API Gateways play a crucial role in modern software architecture, enabling developers to manage and route traffic between client applications and backend services. KrakenD stands out due to its stateless design, which provides several significant advantages over other solutions.
What is a Stateless API Gateway? A stateless API Gateway is an APII Gateway that doesn&amp;rsquo;t depend on a centralized database for storing configurations or maintaining a shared &amp;ldquo;state.&amp;rdquo; Instead, each instance of the API Gateway possesses its own configuration file, read when the service initiates.</description></item><item><title>KrakenD 2.3.2 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.3.2-release-notes/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.3.2-release-notes/</guid><description>A new patch version KrakenD 2.3.2 is available on the download page and the Docker registry. Upgrading from any 2.x is backward compatible.
🚀 Summary of changes for CEv2.3.2 (patch) Fixed plugin builder and corrected edge cases in JWT validation.
Custom plugins: Alpine image builder fixed for ARM64 JWT: Panic when receiving an invalid number of claims JWT: Remove misleading error log when no global cache is defined JWT: index out of range Upgrade to Go version 1.</description></item><item><title>KrakenD 2.3.1 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.3.1-release-notes/</link><pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.3.1-release-notes/</guid><description>A new patch version KrakenD 2.3.1 is available to download page. Upgrading from any 2.x is backwards compatible.
🚀 Summary of changes for CEv2.3.1 (patch) The new TLS Client functionality was not included in the release.
The deny attribute did not work on the third nesting level and above. The new client_tls attribute was not yet included. Upgrading to the latest version is always advised. Compare versions Upgrade to v2.3.1</description></item><item><title>KrakenD CE v2.3 released!</title><link>https://www.krakend.io/blog/krakend-2.3-release-notes/</link><pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.3-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD Community Edition v2.3, which improves connectivity with backends, caching, and adds the possibility to play with KrakenD using the web Designer directly.
You can get v2.3 packaged for several options from the download page.
🚀 Summary of changes for CEv2.3 The v2.3 adds more connectivity options with backends and caching and adds the possibility to load changes into a local KrakenD using the Designer (UI) directly.</description></item><item><title>KrakenD Enterprise 2.2.1 (bugfixing) released</title><link>https://www.krakend.io/blog/krakend-ee-2.2.1-release-notes/</link><pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.2.1-release-notes/</guid><description>The new KrakenD Enterprise version 2.2.1 is already available for install or upgrade. This patch version does not bring significant new functionality (except for AMQP) but includes a few fixes.
🚀 Summary of changes for EEv2.2.1 (patch) Enables backoff strategies for AMQP producers and consumers, and fixes OpenAPI generation issues.
AMQP consumers and producers offer now retries with several backoff strategies. Request modifier plugin loader is now hardened and is more strict to prevent human error.</description></item><item><title>KrakenD Enterprise 2.2 released</title><link>https://www.krakend.io/blog/krakend-ee-2.2-release-notes/</link><pubDate>Mon, 27 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.2-release-notes/</guid><description>The new KrakenD Enterprise version 2.2 is now available, and it&amp;rsquo;s supercharged: Introduces dynamic routing based on headers and query strings, adds a security policies engine, upgrades to OpenAPI 3, improves SOAP integration, default gzip compression and a lot more&amp;hellip;
Below there is a summary of changes and an introduction to some of these new features.
Security Policies: Enforce any check, anywhere From RBAC and ABAC, to lifecycle management, restriction of content by country, validation custom cryptography or other strategies, &amp;hellip; The new policies engine allows you to do any custom evaluations you need, during runtime and with access to query strings, URLs, parameters, cookies, tokens, time functions, geolocation, cryptography, and a long etcetera.</description></item><item><title>KrakenD 2.2.1 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.2.1-release-notes/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.2.1-release-notes/</guid><description>A new patch version KrakenD 2.2.1 is available to download page. Upgrading from any 2.x does not require changes in the configuration.
🚀 Summary of changes for CEv2.2.1 (patch) Fixes a memory leak on Shadow Proxies.
Fixed memory leak on Shadow Proxies when the response wasn&amp;rsquo;t a 200 Fixed audit command that would still warn on some fixed issues Upgraded Go to version 1.20.1 Upgrading to the latest version is always advised.</description></item><item><title>Rainbow Smile Case Study: Success Story</title><link>https://www.krakend.io/case-study/rainbow-smile/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/rainbow-smile/</guid><description>To us, KrakenD is an enterprise system that forgives mistakes and allows you to get the desired result.
The challenges At &amp;ldquo;Rainbow Smile&amp;rdquo;, we faced challenges with publishing technical APIs from external sources, leading to increased development costs and a violation of the Domain Driven Design. We also needed help publishing the REST interface, which required developer involvement.
Scenario To solve these challenges, we implemented KrakenD as a gateway for systems that do not support gRPC.</description></item><item><title>KrakenD 2.2 Release Notes: Latest Features and Enhancements</title><link>https://www.krakend.io/blog/krakend-2.2-release-notes/</link><pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.2-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD Community Edition v2.2. It introduces a new security audit command (krakend audit) that parses and analyzes your configurations and outputs security recommendations. We have designed it to run as a standalone command or integrated it into your existing CI/CD pipeline to avoid dangerous configurations, such as unwillingly disabling the TLS, setting excessive timeouts, unprotected endpoints, or similar scenarios.
You can get v2.</description></item><item><title>KrakenD Enterprise 2.1.2 (security fix) released</title><link>https://www.krakend.io/blog/krakend-ee-2.1.2-release-notes/</link><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.1.2-release-notes/</guid><description>The new KrakenD Enterprise version 2.1.2 is already available for install or upgrade. This patch version does not bring significant new functionality but updates dependencies that have security vulnerabilities and adds a few fixes:
🚀 Summary of changes for EEv2.1.2 (patch) The patch v2.1.2 updates dependencies that have security vulnerabilities.
Add the content-type header when returning errors Upgrade from Go 1.19.3 to Go 1.19.5, which includes security fixes to the net/http, crypto/x509, and os packages, among others.</description></item><item><title>KrakenD 2.1.4 (security fix) released</title><link>https://www.krakend.io/blog/krakend-2.1.4-release-notes/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.4-release-notes/</guid><description>The new KrakenD version 2.1.4 is now available. This patch version does not bring significant new functionality but updates dependencies that have security vulnerabilities and adds a few fixes:
🚀 Summary of changes for CEv2.1.4 (patch) Corrects a bug when caching Gzipped content and adds the Content-Type header when returning errors.
Add the Content-Type header when returning errors Upgrade from Go 1.19.3 to Go 1.19.5, which includes security fixes to the net/http, crypto/x509, and os packages, among others.</description></item><item><title>KrakenD 2022 Recap: A Look Back at Our Major Milestones</title><link>https://www.krakend.io/blog/2022-recap/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/2022-recap/</guid><description>We can&amp;rsquo;t believe it&amp;rsquo;s been six years since the first commit to KrakenD. It&amp;rsquo;s incredible how fast time passes when you have a purpose, and we&amp;rsquo;ve had a blast working on this project and seeing it grow. We are so grateful to everyone who has been with us on this journey.
At KrakenD, we are passionate about building an open-source API Gateway that pursues performance, scalability, and simplicity. This past year marked our first full year as an independent company.</description></item><item><title>KrakenD 2.1.1 EE (patch version) released</title><link>https://www.krakend.io/blog/krakend-ee-2.1.1-release-notes/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.1.1-release-notes/</guid><description>The new KrakenD Enterprise version 2.1.1 is already available for install or upgrade. This patch version does not bring new API Gateway functionality but adds support for ARM64 and other improvements.
🚀 Summary of changes for EEv2.1.1 (patch) The patch v2.1.1 fixes logging on the wildcard and a race condition on OpenAPI generation.
Fix OpenAPI race condition Fix wildcard plugin logger messages Upgrading to the latest version is always advised.</description></item><item><title>KrakenD 2.1.3 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.3-release-notes/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.3-release-notes/</guid><description>The new KrakenD version 2.1.3 is now available. This patch version does not bring new API Gateway functionality but adds support for ARM64 and other improvements.
🚀 Summary of changes for CEv2.1.3 (patch) ARM64 support, and obfuscate the KrakenD version header.
Now officially supporting ARM64 architectures, releasing new Docker containers and packages. Performance improvement on Lambda usage A new flag, hide_version_header, placed in the router settings, allows obfuscating the X-Krakend-Version header.</description></item><item><title>KrakenD Enterprise 2.1 released</title><link>https://www.krakend.io/blog/krakend-ee-2.1-release-notes/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD Enterprise 2.1, already available for install or upgrade.
Apologies because we have added so much that the summary is not going to be short this time :)
🚀 Summary of changes for EEv2.1 KrakenD Enterprise v2.1 brings a lot of new functionality, including advanced manipulation with a JSON Query language, a Revoke Server to manage tokens in clusters, new Kibana and Grafana dashboards, faster encoding, a rewritten and richer NewRelic exporter, Websockets balancing, everything on Community 2.</description></item><item><title>KrakenD becomes a CNA (CVE Numbering Authority)</title><link>https://www.krakend.io/blog/krakend-becomes-a-cna/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-becomes-a-cna/</guid><description>The Spanish National Cybersecurity Institute (INCIBE) announces today the addition of KrakenD as a CNA (CVE Numbering Authority). KrakenD assumes as its own, from this date, the best practices of this program.
KrakenD is now authorized by the CVE Program to assign CVE identifiers within its scope and its corresponding publication in the CNA section. Information technology and cybersecurity professionals use CVE Records to ensure they are discussing the same issue, and to coordinate their efforts to prioritize and address the vulnerabilities.</description></item><item><title>KrakenD 2.1.2 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.2-release-notes/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.2-release-notes/</guid><description>A new patch version KrakenD 2.1.2 is available to download page. This release fixes a bug while parsing placeholders in endpoint.
🚀 Summary of changes for CEv2.1.2 (patch) Corrects a bug with parameters sent to the backend
Some requests sent to backend didn&amp;rsquo;t have the parameters replaced from the client URL Upgrading to the latest version is always advised. Compare versions Upgrade to v2.1.2</description></item><item><title>KrakenD 2.1.1 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.1-release-notes/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.1-release-notes/</guid><description>A new patch version KrakenD 2.1.1 is available to download page. In addition to the patch, we have created a new plugin-builder Docker image for those who compile custom plugins.
🚀 Summary of changes for CEv2.1.1 (patch) Adds a Docker image to build plugins and fixes issues with the JOSE and Lua packages.
Bot Detector: Avoid aborting with an error Influx: Logs normalized for better consistency JOSE: Use a sempahore to orchestrate the concurrent warm up of the JWK caches Lambda: Upgrade the AWS SDK version used (by @boris154) The krakend check command did not accept configurations with zero number of endpoints.</description></item><item><title>KrakenD 2.1 released!</title><link>https://www.krakend.io/blog/krakend-2.1-release-notes/</link><pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 2.1. You can get it packaged from the download page.
KrakenD 2.1 brings a new ready-to-use Kibana dashboard, an updated Grafana Dashboard for InfluxDB v2 and more features and bugfixes described below:
🚀 Summary of changes for CEv2.1 KrakenD 2.1 brings a new ready-to-use Kibana dashboard, an updated Grafana Dashboard for InfluxDB v2 and more features and bugfixes
New repository Telemetry Dashboards, including Kibana, Grafana, Logstash, and Influx v2 Added a krakend version command that outputs the KrakenD, Go, and Glibc versions.</description></item><item><title>Case Study: Child Rescue Coalition</title><link>https://www.krakend.io/case-study/child-rescue-coalition/</link><pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/child-rescue-coalition/</guid><description>Child Rescue Coalition (CRC) is a nonprofit organization that develops advanced technology to help law enforcement identify and rescue children from sexual exploitation. With more than 12,000 investigators trained across 106 countries, CRC’s tools have contributed to the arrest of over 17,000 offenders and the rescue of more than 3,900 children.
Image: One minute of illicit activity captured by Child Rescue Coalition technology
To support these high-stakes missions, CRC relies on KrakenD Unlimited.</description></item><item><title>KrakenD partners with Child Rescue Coalition</title><link>https://www.krakend.io/blog/krakend-child-rescue-coalition-partnership/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-child-rescue-coalition-partnership/</guid><description>Barcelona, September 19th 2022.- KrakenD announces today the partnership with Child Rescue Coalition. Child Rescue Coalition (CRC) is a nonprofit organization whose mission is to rescue children from sexual abuse by building technology for law enforcement to track, arrest and prosecute child predators. KrakenD has donated an unlimited commercial license (KrakenD Enterprise) to CRC to help them build and scale their APIs-oriented technological platform.
CRC has contributed to rescuing more than 3,200 children from sexual exploitation and abuse.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/enterprise/v2.1/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.10/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/enterprise/v2.2/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/enterprise/v2.3/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/enterprise/v2.4/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.5/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.6/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.7/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.8/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/enterprise/v2.9/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/v2.1/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.10/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/v2.2/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/v2.3/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/v2.4/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.5/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.6/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.7/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.8/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow Design</title><link>https://www.krakend.io/docs/v2.9/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>IBM proposes KrakenD to replace IBM Cloud API Gateway</title><link>https://www.krakend.io/blog/krakend-alternative-ibm-api-cloud/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-alternative-ibm-api-cloud/</guid><description>The IBM Cloud API Gateway service provided traffic limiting, splitting, and authentication for Cloud Functions and Cloud Foundry users. Unfortunately, IBM&amp;rsquo;s API Gateway service was deprecated and shut down on August 31st, 2022. Existing endpoints will no longer route to their respective functions or apps.
A blog post by IBM Cloud published on June 8th provided some tips and recommendations for IBM Cloud API Gateway users. For those users who still require an API Gateway as part of their platform architecture, KrakenD has been suggested as an alternative.</description></item><item><title>Adressing CVE-2022-1561: Crafted backend urls</title><link>https://www.krakend.io/blog/cve-2022-1561-crafted-backend-urls/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/cve-2022-1561-crafted-backend-urls/</guid><description>&lt;p>There is a new vulnerability in the &lt;a href="https://luraproject.org/">Lura Project&lt;/a> software (which is the KrakenD&amp;rsquo;s engine). We have immediately corrected the problem in the subsequent release after its report. Please upgrade to the latest version.&lt;/p></description></item><item><title>KrakenD Security Policy</title><link>https://www.krakend.io/security-policy/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/security-policy/</guid><description>KrakenD takes cybersecurity seriously.
KrakenD&amp;rsquo;s Security and Privacy teams establish policies and controls, monitor compliance with those controls, and prove our security and compliance to third-party auditors. KrakenD is SOC 2 Type II Certified.
We drive our company and craft our software without taking shortcuts, making it solid and reliable and free of practices that might introduce future security problems.
Our policies are designed to ensure:
Infrastructure security Product security KrakenD is a CVE Numbering Authority (CNA) How do we apply fixes How to report a vulnerability Credits and rewards Organizational security Internal security procedures Data and privacy safeguard Infrastructure security We implement strict security measures to protect our infrastructure and ensure system integrity.</description></item><item><title>Rappi - KrakenD API Gateway Case Study</title><link>https://www.krakend.io/case-study/rappi/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/rappi/</guid><description>Rappi is an application that helps users with their everyday shopping needs. From restaurants, supermarkets, pharmacies, spirits, travel, delivery, fintech products, and more.
Scenario At the technical level, Rappi is a large e-commerce platform and one of the top 100 AWS resource consumers worldwide, running over 7000 EC2 servers and over 1800 nodes on EKS.
Their stack runs on Amazon on a dual combination of ECS and Kubernetes. +750 developers of all sorts are allowed to choose their coding language, and the Infra team (Cloud Engineering - 70 people) provides the necessary tools to make it a reality.</description></item><item><title>Pretty Technical Case Study: Success Story</title><link>https://www.krakend.io/case-study/pretty-technical/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/pretty-technical/</guid><description>Pretty Technical has specialists providing consultancy and services for the finance and gaming industries.
Pretty Technical has a focus on simplicity and automation, and at the same time, they develop their business tools using microservices, separating concerns. Yet, all the applications need to combine all these services, which is where KrakenD fits like a glove.
Results, Return on Investment and Future Plans After researching the best tool for the job, Pretty Technical adopted KrakenD in the early stages of development in 2021.</description></item><item><title>KrakenD Enterprise 2.0 released!</title><link>https://www.krakend.io/blog/krakend-ee-2.0-release-notes/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.0-release-notes/</guid><description>The KrakenD team is pleased to announce KrakenD Enterprise 2.0, already available for install or upgrade today.
KrakenD 2.0 is the awaited new major version of KrakenD bringing a lot of improvements to the API Gateway, including all the features and improvements of open source releases between v1.4 and v2.0.4.
🚀 Summary of changes for EEv2.0 KrakenD Enterprise 2.0 is a major rework and needs migration. API Analytics, IP Filtering, GraphQL, OpenAPI importers and exporters, integration tests, specific request/modifier plugins, Async Agents, backend response logging (dumper) and improves the existing WebSockets, API Keys, configuration syntax, New Relic reporting, logging, and router to put a few examples.</description></item><item><title>AlfaStrakhovanie Case Study - Success Stories</title><link>https://www.krakend.io/case-study/alfa-strakhovanie/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/alfa-strakhovanie/</guid><description>AlfaStrakhovanie has adopted KrakenD as its gateway solution as it checks all its requirements regarding features, connectivity, source code control, security, and deployment choice using a DevOps approach.
The following video is an event recording that compares KrakenD with other solutions. It explains the reasons behind having chosen KrakenD and how it improved the existing gateway solution before that.
It covers the company dimension, numbers, methodology, and several requirements for deployment in Kubernetes, as well as which are the most liked features, and a walk-through covering the KrakenD Designer.</description></item><item><title>KrakenD Now Available in the Azure Marketplace</title><link>https://www.krakend.io/blog/krakend-partners-with-microsoft/</link><pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-partners-with-microsoft/</guid><description>BARCELONA, Spain — April 7, 2022
KrakenD today announced the availability of KrakenD API Gateway in the Microsoft Azure Marketplace, an online store providing applications and services for use on Microsoft Azure. KrakenD customers can now take advantage of the scalability, high availability, and security of Azure, with streamlined deployment and management.
The KrakenD API Gateway serves as a unified interface for managing incoming API requests and connecting to the correct destination, while supporting functionalities across security, authorization, traffic management, observability, and load balancing, among other services.</description></item><item><title>KrakenD 2.0 released!</title><link>https://www.krakend.io/blog/krakend-2.0-release-notes/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.0-release-notes/</guid><description>The KrakenD team is pleased to announce the major release KrakenD 2.0. You can get it packaged from the download page.
🚀 Summary of changes for CEv2.0 KrakenD 2.0 is the new major version of KrakenD bringing a lot of improvements to the API Gateway. GraphQL, specific request/modifier plugins, async agents, easier configuration, better logging, and a more flexible router to put a few examples.
REST to GraphQL conversion, or direct consumption of GraphQL through the gateway Backend response logging New plugin types (request/response) Plenty of new configurable router flags The krakend check adds verbosity level A new command krakend check-plugin for quicker development of custom plugins Shortened configuration namespaces.</description></item><item><title>KrakenD unnaffected by Log4j</title><link>https://www.krakend.io/blog/log4j-vulnerability/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/log4j-vulnerability/</guid><description>The year 2021 ended with terrible news for Java developers who saw how the Log4J vulnerabilities exposed their systems.
KrakenD is a Go application and not a Java application. Therefore, it is not affected by this vulnerability in any way. As a result, we didn&amp;rsquo;t want to add more noise to the chain of emails you could have probably received.
Nevertheless, during the past month, we had questions from customers who have Java systems behind KrakenD that could be vulnerable and other users that weren&amp;rsquo;t sure if KrakenD was impacted or not.</description></item><item><title>Afosto Case Study: Success Story</title><link>https://www.krakend.io/case-study/afosto/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/afosto/</guid><description>Afosto is one of the main software (SaaS) solutions empowering omnichannel commerce for retailers in The Netherlands. Our software empowers over 150 store owners with selling online and offline. Two years ago we started the transition towards an API-first development paradigm, currently powered by over 90 cloud-native microservices. KrakenD has enabled us to make this shift naturally.
Challenges KrakenD helps solve Commerce is always challenging. We have to deal with sudden spikes in traffic, payments, ever-changing regulations, and large amounts of data for analytics.</description></item><item><title>Traffic mirroring: test APIs without tests</title><link>https://www.krakend.io/blog/krakend-shadow-testing/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-shadow-testing/</guid><description>Integration and load testing are in the list of best practices in our sector, but synthesizing good inputs for such tests and analyzing the results are usually two hard things to achieve. This post will show you how we suggest our customers set up a shadow testing system with minimal impact on the production environment and proper harness.
Quick overview As pointed out at https://cloud.google.com/architecture/application-deployment-and-testing-strategies
Testing new backend features by using the production load.</description></item><item><title>4data Case Study: Success Story</title><link>https://www.krakend.io/case-study/4data/</link><pubDate>Sat, 19 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/4data/</guid><description>4data provides tailored cloud services to solve specific problems without mandating customers to increase their local infrastructure footprint. All these services can be managed remotely via our management application running in the browser only and communicating via REST APIs. This is where KrakenD joins the game to protect our backend REST API endpoints, both internal and external.
The main challenge was to protect endpoints from unauthenticated access. Wherever required, KrakenD applies JWT validation to ensure only authenticated requests are reaching the backend services.</description></item><item><title>KrakenD Now Available on Auth0 Marketplace</title><link>https://www.krakend.io/blog/krakend-auth0-announcement/</link><pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-auth0-announcement/</guid><description>Barcelona – 15th June 2020 – KrakenD today announced the availability of its API Gateway on Auth0 Marketplace, a catalog of trusted technology integrations to extend the functionality of Auth0’s identity management platform. KrakenD offers an ultra-performant API Gateway that allows companies to effortlessly adopt a microservices architecture through a powerful engine that can transform, aggregate, and remove data from their own or third-party services.
The KrakenD API Gateway serves as a unified interface for managing incoming API requests and connecting to the correct destination, while supporting functionalities across security, authorization, traffic management, observability, and load balancing, among others.</description></item><item><title>KrakenD 1.4.0 released</title><link>https://www.krakend.io/blog/krakend-1.4-release-notes/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.4-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.4.0. You can get it packaged from the download page.
🚀 Summary of changes for CEv1.4 KrakenD 1.4 is the last version of the 1.x family and primarily replaces the KrakenD Framework with the Lura Project and includes minor bug fixing and an extended flexible configuration. The next release with the new functionality will be 2.0.
All dependencies for the framework moved to Lura The json-collection output encoding allows returning collections directly Added Sprig functions to Flexible Configuration Allow the propagation of nested claims using dot notation (JWT) Add the del method to Lua Upgrading to the latest version is always advised.</description></item><item><title>KrakenD Enterprise 1.3.0 released</title><link>https://www.krakend.io/blog/krakend-ee-1.3-release-notes/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-1.3-release-notes/</guid><description>We are glad to announce that KrakenD Enterprise 1.3.0 is out. The new release comes with the following new features.
🚀 Summary of changes for EEv1.3 First commercial version of KrakenD Enterprise. Includes everything in the Community v1.3 and adds generator commands for OpenAPI, Postman, and rendering PNG files with the configuration. It also adds support for wildcard routes.
New generate postman command New generate openapi command New generate config2dot command Support for wildcard routes Multiple identity providers Integration of secret providers Upgrading to the latest version is always advised.</description></item><item><title>KrakenD framework becomes a Linux Foundation project</title><link>https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/</guid><description>Today, together with the Linux Foundation, we are announcing that the KrakenD framework, our core engine, has been donated to the Linux Foundation and is now the &amp;ldquo;Lura Project.&amp;rdquo;
The Lura Project&amp;rsquo;s mission is to offer an extendable, simple, and stateless high-performance API Gateway framework designed for cloud-native and on-prem setups. Rather than solving a specific use case, Lura provides a library of components, a framework for assembling them into custom API gateway systems like a Lego set.</description></item><item><title>Albert Garcia to expand KrakenD business.</title><link>https://www.krakend.io/blog/albert-garcia-expand-krakend-business/</link><pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/albert-garcia-expand-krakend-business/</guid><description>Today, we are announcing that Albert Garcia recently joined KrakenD as Director of Business Development and member of the Board.
In his role, he will identify and develop new business opportunities to help expand even more the presence of KrakenD. Garcia will spearhead new markets and emerging trends, sales, and client relationship management, to name a few.
Having worked previously with him for more than 15 years, we know that Garcia is the right person at the right time for KrakenD.</description></item><item><title>Xiachufang (下厨房) Case Study: Success Story</title><link>https://www.krakend.io/case-study/xiachufang/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/xiachufang/</guid><description>With around 70 million unique users, Xiachufang is the biggest cuisine community in China, making it possible for its users to share home recipes easily, watch video courses made by experts, and shop ingredients or kitchenware.
Xiachufang&amp;rsquo;s requirements at the beginning of its API gateway research were:
Being able to efficiently distribute the requests A simple and stateless approach to API gateway Strong customization capabilities An efficient and programmatic way to define rules Supporting monitoring and alarms Support the traffic and scalability needs of the company Xiachufang started with a small subset of live services (small as in nearly 2,000 requests per second) before starting moving more services to KrakenD:</description></item><item><title>Building a Telemetry Service</title><link>https://www.krakend.io/blog/building-a-telemetry-service/</link><pubDate>Mon, 15 Mar 2021 09:40:25 +0200</pubDate><guid>https://www.krakend.io/blog/building-a-telemetry-service/</guid><description>​ We have run our telemetry system live for the past three years now. In this article, we&amp;rsquo;ll share code and outline some of the things you&amp;rsquo;ll need to keep in mind if you want to build an anonymous usage reporting system for an open-source project as we did (at a ridiculous cost).
We will show you how to use our reporting client and the details of our actual reporting servers in case you are thinking in implementing a cost-efficient solution with high scalability.</description></item><item><title>KrakenD 1.3.0 released</title><link>https://www.krakend.io/blog/krakend-1.3-release-notes/</link><pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.3-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.3.0. You can get it packaged from the download page.
🚀 Summary of changes for CEv1.3 KrakenD 1.3.0 makes focus on completing the RBAC system regarding JWT.
Scopes validation (thanks to @chrisdennig) Extract and forward claims as headers (thanks to @chrisdennig) Support for Oracle Identity Cloud Service by allowing key identifers other than kid such as x5t or kid_x5t (contribution from Oracle) Allow loading of local JWK files Integration with secret providers such as, Amazon KMS, Azure&amp;rsquo;s Key Vault, Google Cloud KMS, Hashicorp&amp;rsquo;s Vault, Encrypted or plain base64 file Expose router request host to Lua virtual machine (thanks to Marc Ruiz from Stayforlong) Add X-Forwarded-Host header (thanks to Marc Ruiz from Stayforlong) Allow the extraction of client IP from custom headers Add debugging information to CORS component The Etcd component is no longer loaded in KrakenD-CE (but the repository is available for custom integrations) The WASM-based emulator in KrakenDesigner has been removed.</description></item><item><title>KrakenD 1.2.0 released</title><link>https://www.krakend.io/blog/krakend-1.2-release-notes/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.2-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.2. You can get it packaged from the download page.
Some of the highlights include:
Added a /__health endpoint Removed the wording whitelist and blacklist from all our products (#BlackLivesMatter) Datadog integration Array manipulation available after merging multiple backends KRAKEND_-like environment vars to override configuration A lot of small features and bugfixes 🚀 Summary of changes for CEv1.2 KrakenD 1.</description></item><item><title>Hepsiburada Case Study - Success Stories</title><link>https://www.krakend.io/case-study/hepsiburada/</link><pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/hepsiburada/</guid><description>Hepsiburada is the largest and fastest-growing e-commerce platform in Turkey and the top 5 in Europe. With over 150 million monthly visits and over 50 million product variations in mobile phones, cosmetics, consumer goods, fashion, and more, Hepsiburada is a business and technology leader in Turkey.
Hepsiburada challenges A company of such dimensions as Hepsiburada had several challenges before choosing KrakenD as their API gateway solution:
Operating 500 microservices and 40+ autonomous product development teams has many complex issues.</description></item><item><title>KrakenD Usage Stats - March 2020</title><link>https://www.krakend.io/blog/usage-stats-march-2020/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/usage-stats-march-2020/</guid><description>KrakenD servers with telemetry enabled help us to understand the usage of KrakenD in production. Last month we witnessed 356K running instances, and we wanted to share some data with you. 👇
From mid-March, we have seen an exciting increase in the number of KrakenD instances seen per day: x12! The trend is just beautiful, including the cumulative.
According to our internal definition, an instance is every time a KrakenD is started.</description></item><item><title>KrakenD 1.1 with Kafka integration released</title><link>https://www.krakend.io/blog/krakend-1.1-release-notes/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.1. You can get it packaged from the download page.
Some of the highlights include:
Kafka integration Extended Docker image Added Telemetry for Azure Monitor More performance improvements 🚀 Summary of changes for CEv1.1 KrakenD 1.1.0 adds Kafka integration, an extended Docker image, telemetry for Azure Monitor and performance improvements.
Corrected a bug in the httpsecure module. Lambda context as base64 json-encoded context Lua request and response helpers Upgraded to Go 1.</description></item><item><title>Perx Case Study: Success Story</title><link>https://www.krakend.io/case-study/perx/</link><pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/perx/</guid><description>Perx is developing a data management platform called Hoop built on microservices and an architecture that makes use of extensive internal and external communications through REST APIs and asynchronous NATS channels.
KrakenD API Gateway offers robust functionality to control the traffic between external API clients and services. It aggregates microservices responses together into one unified API and thus provides flexible options for request/response manipulation to meet customers&amp;rsquo; needs.
Using KrakenD provides secure external connections with OAuth.</description></item><item><title>Privalia Case Study: Success Story</title><link>https://www.krakend.io/case-study/privalia/</link><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/privalia/</guid><description>Veepee is the European flash sales leader with 72M of members, and Privalia its strategic brand for Spain, Italy, Brazil, and Mexico.
Privalia, with +13M members, evolved their customer care solution from an in-house solution to a Salesforce integration with their internal systems.
Before KrakenD, the main challenge of Veepee was to integrate Salesforce with multiple microservices and handle authorization, security, and aggregation in the middle layers.
KrakenD solved this challenge with out of the box features, keeping Privalia&amp;rsquo;s logic separated, and decoupled from Salesforce.</description></item><item><title>KrakenD 1.0 announcement</title><link>https://www.krakend.io/blog/announcing-krakend-1.0/</link><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/announcing-krakend-1.0/</guid><description>In November 2016, we released KrakenD framework to the public. Today, after three years serving traffic around the world, and a lot of lessons learned on the way, KrakenD 1.0 is out 🎉🎉🎉
KrakenD 1.0 is our announcement to the world that our libraries are now fully established and with the solid commitment of keeping backward compatibility. In the last twelve months, we have seen 120,000+ clusters in the world and 1M+ docker pulls, but as we always did (since 0.</description></item><item><title>i2S by GFI Case Study: Success Story</title><link>https://www.krakend.io/case-study/i2s/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/i2s/</guid><description>GFI is one of the most high-performing IT and digital service companies in the market. Their insurance branch i2S has software solutions installed in nearly 50 insurance companies (Life and Non-life) and several pension fund management societies.
KrakenD is the entry point to consume all the micro-services in a controlled way and helps create an insurance-related product, covering many aspects, from legal to finance and actuarial.
KrakenD unifies and aggregates the responses of all the underlying Java microservices, and injects custom middleware for insurance&amp;rsquo;s particular use case.</description></item><item><title>Open Room Inc Case Study: Success Story</title><link>https://www.krakend.io/case-study/openroom/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/openroom/</guid><description>Open Room Inc. uses KrakenD to expose easily and safely various Real Estate applications, to help agents in their daily work and end-users to find the home they are looking for.
Open Room uses image processing, character recognition, document analysis, and machine learning.
KrakenD API Gateway helped Open Room to reduce the latency of all queries by grouping backend queries by frontend use-case, and allowed Open Room to build their API simply and coherently.</description></item><item><title>Adevinta Spain Case Study: Success Story</title><link>https://www.krakend.io/case-study/adevinta/</link><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/adevinta/</guid><description>Adevinta Spain handles a vast amount of traffic, as it operates marketplaces with 18 million active users. The adoption of KrakenD&amp;rsquo;s technology in production started in early 2017 and has been running since then.
Adevinta was investigating how to get more performance in their company-wide solution, and how to provide autonomy to non backend teams.
After several weeks of research, stress-tests and benchmarking several products in the market, Adevinta decided to choose KrakenD as the api gateway engine.</description></item><item><title>Delivery Club (Mail.ru group) Case Study: Success Story</title><link>https://www.krakend.io/case-study/mailru/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/mailru/</guid><description>Delivery Club, a Mail.ru brand, is the largest online food delivery platform in Russia, moving food from thousands of restaurants to homes in more than 100 cities.
Delivery Club processes +30,000 orders per day, 72% of which are made from mobile devices.
The technology is built using a modernized microservices architecture with around 20 services, including KrakenD API Gateway that sits between end users and Delivery Club&amp;rsquo;s services.
KrakenD&amp;rsquo;s main duty is processing ingoing and outgoing traffic making sure that user sessions are properly authorized when needed, and discarding malicious activity and hacking attempts.</description></item><item><title>Dusdusan.com (Indonesia) Case Study: Success Story</title><link>https://www.krakend.io/case-study/dusdusan/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/dusdusan/</guid><description>Established in the Jakarta City of Indonesia in November 2015, PT. Dusdusan Dotcom Indonesia is a mobile Internet company engaged in the research, development, and operation of E-business platform.
As a leader of membership E-business in Indonesia, Dusdusan.com, together with many domestic and foreign top brands and quality emerging brands, has integrated into the life of thousands of Indonesian families.
As the business developed rapidly, Dusdusan.com needs to keep improving its platform.</description></item><item><title>Letgo Case Study: Success Story</title><link>https://www.krakend.io/case-study/letgo/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/letgo/</guid><description>Letgo is the biggest and fastest-growing app for buying and selling locally.
Letgo is a desktop application (SPA) and a mobile application with native implementations for every operating system. As Letgo&amp;rsquo;s organization is large, the UI experience of each client (Android, iOS, web&amp;hellip;) is handled by a different team.
Letgo uses different clusters and configurations of KrakenD API Gateway per client, allowing each team to have its customized views of merged data.</description></item><item><title>Pearson Education Case Study: Success Story</title><link>https://www.krakend.io/case-study/pearson/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/pearson/</guid><description>Pearson Central Europe has trusted KrakenD as its API Gateway solution for the Parent App, which provides parents with a wide range of resources, including podcasts, infographics, quizzes, and checklists, to support their children&amp;rsquo;s progress in learning.
KrakenD API Gateway offers the endpoints to the Parent App and sits between end-users and the Pearson services, which provide all the data that KrakenD aggregates to supply the use case.
KrakenD handles OAuth with HMAC security and implements minor custom middlewares to fit the desired end-user consumption of the services.</description></item><item><title>MTS Travel Case Study: Success Story</title><link>https://www.krakend.io/case-study/mts-travel/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/mts-travel/</guid><description>At MTS Travel, we needed an API gateway solution to support our microservices architecture and provide a single access point for API clients. After evaluating the available options, we chose KrakenD for its speed, extensibility, and open-source principle. In this case study, we&amp;rsquo;ll discuss why we decided on KrakenD, our experience using the solution, and the complexities we encountered. &amp;ndash; Vladimir Kalugin, Backend Lead Developer
Why did we choose KrakenD?</description></item><item><title>How to write a simple gRPC-gateway as a KrakenD plugin</title><link>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</link><pubDate>Sun, 09 Jun 2019 18:26:10 +0100</pubDate><guid>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</guid><description>The gRPC protocol is becoming trendy in the era of microservices. Its compactness and backward-compatibility make it very attractive. However, it requires custom code to work with it. In this article, we&amp;rsquo;ll show you how to get all the benefits from the gRPC protocol and the gRPC-gateway without coding any business logic to use your gRPC services as regular backends. Moreover, avoiding the extra network hop!</description></item><item><title>Doing housekeeping on your configuration file</title><link>https://www.krakend.io/blog/housekeeping-configuration-file/</link><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/housekeeping-configuration-file/</guid><description>Starting your krakend.json configuration from scratch and writing every attribute in a blank editor might be a difficult and time consuming task, and that&amp;rsquo;s why we have the KrakenDesigner.
KrakenDesigner is an aid tool to generate KrakenD configurations for the uninitiated audience. It produces a verbose output of the configuration file and explicitly writes unneeded attributes to let you see that a specific configuration option exists. These attributes I am mentioning are not necessary because they contain default values and the server is not going to alter its behavior.</description></item><item><title>KrakenD 0.9 released</title><link>https://www.krakend.io/blog/krakend-0.9-release-notes/</link><pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.9-release-notes/</guid><description>It&amp;rsquo;s been only one month since we released KrakenD 0.8, and although we have been releasing new versions approximately every 3 months, we have very interesting features that can&amp;rsquo;t wait! KrakenD 0.9 comes with a series of very demanded features. Let&amp;rsquo;s get started!
Integration with AMQP The AMQP integration allows you to send and receive messages to and from a queue through the KrakenD API Gateway. This feature enables the gateway to become in both a subscriber and a consumer of messages for asynchronous processing and opens the doors to very different implementations we were seeing.</description></item><item><title>KrakenD 0.8 released</title><link>https://www.krakend.io/blog/krakend-0.8-release-notes/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.8-release-notes/</guid><description>KrakenD 0.8 is a significant release as it brings numerous code changes and functionality. The framework brings +100 commits, the gateway +50 commits and even more changes in the components. A lot of refactoring and component updates has taken place. The big picture is a move from a single binary application to become a package with several internal binaries.
See the details below.
KrakenD framework The KrakenD framework brings +100 commits compared to 0.</description></item><item><title>How we run KrakenD on Javascript with WebAssembly</title><link>https://www.krakend.io/blog/krakend-wasm/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-wasm/</guid><description>KrakenD is an API Gateway written in Go that uses a single configuration file to define its whole behavior. As the configuration file might be complicated, the KrakenDesigner is a javascript-based user interface to edit this file, and we were missing the capability of reproducing directly on javascript the existing gateway pipes so that users could run manual tests over the editing configuration.
In this post, we are going to explain how we included KrakenD framework components in a .</description></item><item><title>Meet the KrakenD Team: Learn About Our Experts</title><link>https://www.krakend.io/team/</link><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/team/</guid><description/></item><item><title>KrakenD 0.7 released</title><link>https://www.krakend.io/blog/krakend-0.7-release-notes/</link><pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.7-release-notes/</guid><description>The most relevant features for the 0.7 release are increased metrics and tracing options, and functionality that has been requested by many, the sequential proxy merger. During this release, we also updated the KrakenD brand with a new logo, and we added more documentation.
On the metrics side, we can now send structured events using GELF to your Graylog Cluster. Opencensus middleware adds new functionality to push metrics to your Google StackDriver account.</description></item><item><title>iContainers Case Study: Success Story</title><link>https://www.krakend.io/case-study/icontainers/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/case-study/icontainers/</guid><description>iContainers is an ocean freight forwarder that allows you to compare, book, manage, and track maritime shipments in real-time without intermediaries.
As importers and exporters combine more than 500,000 rates and maritime transport routes from different providers, KrakenD plays the role of a Backend for Frontend in several SPAs. Some examples are the back-office, the partners portal, or the pricing API.
KrakenD&amp;rsquo;s primary duty in all these cases is to provide a reliable way to fetch data from multiple providers and APIs and merge the results of all the services into useful endpoints.</description></item><item><title>KrakenD Enterprise Edition - Advanced API Gateway Solutions</title><link>https://www.krakend.io/enterprise/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/enterprise/</guid><description/></item><item><title>KrakenD Enterprise Edition - AI Gateway Solutions</title><link>https://www.krakend.io/ai-gateway/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/ai-gateway/</guid><description/></item><item><title>KrakenD Partners: Join Our Network of Success</title><link>https://www.krakend.io/partners/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/partners/</guid><description/></item><item><title>Krakend 0.6.1 release notes</title><link>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</link><pubDate>Thu, 04 Oct 2018 09:15:49 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</guid><description>The 0.6.1 release adds TLS and enables HTTP2 and HTTPS.
TL;DR This release brings HTTP2 and HTTPS to KrakenD. It also upgrades Go from 1.10 to 1.11 and fixes forwarded query string parameters to backends that are using arrays and repeated variables.
The KrakenDesigner (UI) is also updated to reflect these changes.
KrakenD framework The KrakenD framework has the following relevant changes:
NEW: Added support for HTTP2/HTTPS FIX: query string parameters works now with arrays and repeated variables (e.</description></item><item><title>KrakenD Privacy Policy: Your Data Protection</title><link>https://www.krakend.io/privacy-policy/</link><pubDate>Fri, 14 Sep 2018 20:11:05 +0200</pubDate><guid>https://www.krakend.io/privacy-policy/</guid><description>In accordance with Regulation (EU) 2016/679 of the European Parliament and of the Council of 27 April 2016 on the protection of natural persons with regard to the processing of personal data and on the free movement of such data (General Data Protection Regulation, GDPR), and the provisions of the Organic Law 3/2018, of 5 December, of Personal Data Protection and Guarantee of Digital Rights, as well as any other applicable data protection regulations, we provide you with further information on the processing of your personal data in this privacy policy (hereinafter the &amp;ldquo;Privacy Policy&amp;rdquo;).</description></item><item><title>KrakenD 0.6 autumn release</title><link>https://www.krakend.io/blog/krakend-0.6-release-notes/</link><pubDate>Fri, 07 Sep 2018 09:18:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.6-release-notes/</guid><description>As if we were an agrarian society, our releases keep revolving around the weather calendar seasons. Autumn is around the corner (northern hemisphere), so our release is ready for a cool autumn.
TL;DR This release adds two interesting components: the JOSE component responsible for the JWT signing and validation, and the Cross-origin resource sharing (CORS) component. There is also a Consul client available.
The Krakend Playground and the KrakenDesigner (UI) is also updated.</description></item><item><title>Reloading the config with Reflex and Docker</title><link>https://www.krakend.io/blog/reloading-the-krakend-configuration/</link><pubDate>Fri, 22 Jun 2018 11:06:53 +0200</pubDate><guid>https://www.krakend.io/blog/reloading-the-krakend-configuration/</guid><description>Read the new documentation This is an article from 2018. You might want to see the Hot reload documentation. A recurrent question when we go around is if KrakenD configuration can be hot-reloaded, this is changing endpoints, backends, or any other configuration of the gateway while it&amp;rsquo;s running. The short answer is: No, you can&amp;rsquo;t. You must restart the server. And although we might have something to alleviate this, let us explain first why we don&amp;rsquo;t support such a feature:</description></item><item><title>KrakenD 0.5 summer release</title><link>https://www.krakend.io/blog/krakend-0.5-release-notes/</link><pubDate>Fri, 08 Jun 2018 14:50:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.5-release-notes/</guid><description>KrakenD 0.5 is out and we want to share some of the cool stuff this release is bringing.
This release focuses heavily on metrics and its export options to different backend systems such as Zipkin, InfluxDB, Prometheus or Jaeger. It also adds the NoOp logger and exposes all the advanced settings of the http client and server, giving all the power to the user. On the middleware side it extends even more the ecosystem with multiple components.</description></item><item><title>KrakenD API Gateway on Kubernetes - Deployment Guide</title><link>https://www.krakend.io/blog/krakend-on-kubernetes/</link><pubDate>Wed, 06 Jun 2018 18:47:03 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-kubernetes/</guid><description>In this article we are going to show how to configure and deploy the KrakenD API Gateway in a kubernetes environment.
We will use for the demonstration Minikube so you cant test it in your own local machine.
Let&amp;rsquo;s get started!
Setting up a local Kubernetes We will run Kubernetes locally thanks to Minikube. Just follow the README in the project for the installation and the Quickstart section. Installing minikube it&amp;rsquo;s quick and easy.</description></item><item><title>Website development as a sysadmin</title><link>https://www.krakend.io/blog/website-development-as-a-sysadmin/</link><pubDate>Thu, 10 May 2018 16:18:25 +0200</pubDate><guid>https://www.krakend.io/blog/website-development-as-a-sysadmin/</guid><description>As a systems administrator for the past 15 years, I&amp;rsquo;m not very used to web development as this kind of work has been usually done by other colleagues in every company I&amp;rsquo;ve worked for. I wanted to create a web application myself using an external API, as an exercise to go out my comfort zone.
Some time ago I found that Marvel Comics has a REST API where you can get a lot of information about comics, characters, authors and other interesting information.</description></item><item><title>Edge computing - A story of buses, IoT, and API gateways</title><link>https://www.krakend.io/blog/krakend-on-raspberry/</link><pubDate>Tue, 01 May 2018 21:25:00 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-raspberry/</guid><description>The IoT industry has been running for some years now adding millions of devices into the network. The range of devices and capabilities is very wide and heterogeneous, from small devices powered with a 9-volt battery to track the location of freight shippings traveling the oceans (using platforms like Sigfox) to permanently plugged devices with more powerful computing like a Raspberry Pi where computation cycles are not a problem.
Generally speaking, all these devices collect raw data and send it to the cloud where big data centers process it.</description></item><item><title>KrakenD Golang Plugins - Extending the Functionality</title><link>https://www.krakend.io/blog/krakend-golang-plugins/</link><pubDate>Thu, 12 Apr 2018 22:07:03 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-golang-plugins/</guid><description>The release of golang 1.8 more than a year ago opened the door to loading dynamic linked components in run time, and we were keen to find out if we could include this great feature in our KrakenD toolbox.
We&amp;rsquo;d like to share our experience and details on how we enhanced our products to support golang plugins.
Why would anyone use plugins in Go? The plugin concept is widely known and supported in several programming languages and environments.</description></item><item><title>Deploying and versioning an API Gateway</title><link>https://www.krakend.io/blog/deploying-an-api-gateway/</link><pubDate>Fri, 06 Apr 2018 23:46:25 +0200</pubDate><guid>https://www.krakend.io/blog/deploying-an-api-gateway/</guid><description>When it comes to maintaining and deploying an API Gateway within an organization, you should always be aware of best practice. A gateway is an extra step between the client and the servers with the power to define a whole new interface, yet it&amp;rsquo;s so flexible and easy to implement that you might be tempted to start creating API interfaces without thinking about it - and end up creating problems for the future.</description></item><item><title>KrakenD 0.4 release notes</title><link>https://www.krakend.io/blog/krakend-0.4-release-notes/</link><pubDate>Sun, 21 Jan 2018 14:50:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.4-release-notes/</guid><description>KrakenD 0.4 materializes the announcement we did 3 months ago by going full open source and public releasing the former enterprise-only components.
This release note comprehends both the KrakenD framework and the KrakenD Community Edition binary distribution.
KrakenD framework The KrakenD framework, engine of the KrakenD API Gateway. The summary of changes introduced in the 0.4 are:
Removed ALL external dependencies and placed to krakend-contrib repositories Decoder and Service Discovery register system Response metadata Response decoder and formatter exposed Custom status code handler Minor handler optimizations Config version upgraded Server configuration extended (with timeouts and limits) Now non strict REST urls are allowed Request and response manipulation optimized func version for all the interfaces Link to 0.</description></item><item><title>An API Gateway is not the new Unicorn</title><link>https://www.krakend.io/blog/what-is-an-api-gateway/</link><pubDate>Fri, 19 Jan 2018 10:10:53 +0200</pubDate><guid>https://www.krakend.io/blog/what-is-an-api-gateway/</guid><description>The more we talk to people about API gateways, the more we have come to realize that the term means different things to different people, and more specifically we see a growing trend where developers (but mostly managers) expect an API gateway to be able to perform miracles, usually a long way away from its intended use.
It&amp;rsquo;s as if the API Gateway is the new unicorn that will solve all problems and make everything wonderful in the microservices scene.</description></item><item><title>Road to KrakenD 0.4</title><link>https://www.krakend.io/blog/road-to-0.4/</link><pubDate>Sun, 12 Nov 2017 12:10:53 +0200</pubDate><guid>https://www.krakend.io/blog/road-to-0.4/</guid><description>The next iteration of KrakenD is right around the corner and the Devops Faith team and the rest of the community we are working together to launch the 0.4 release before end of year. The jump from the 0.3.9 of the binary and the 0.3 of the framework to the 0.4 will bring a lot of interesting stuff but we also need to do a remarkable change in the code for a brighter future: kill external dependencies with fire.</description></item><item><title>Automating Linux Packaging for KrakenD API Gateway</title><link>https://www.krakend.io/blog/automating-linux-packaging/</link><pubDate>Mon, 06 Nov 2017 12:43:33 +0200</pubDate><guid>https://www.krakend.io/blog/automating-linux-packaging/</guid><description>Everyone loves reaching the maximum number of available platforms for their software but this usually comes at a cost. In this article we will explain how we generated our packaging for Linux in an automated fashion, being faithful to our DevOps dogma.
Dockerize all the things! Our dev team uses both Linux and MacOS X in desktop machines and KrakenD has been running and behaving in the same way in all the platforms because from day one we decided to run everything on Docker.</description></item><item><title>Open sourcing all 1st-year enterprise components</title><link>https://www.krakend.io/blog/open-sourcing-enterprise-features/</link><pubDate>Sun, 22 Oct 2017 19:01:33 +0200</pubDate><guid>https://www.krakend.io/blog/open-sourcing-enterprise-features/</guid><description>It&amp;rsquo;s been almost one year live, and what is known today as the KrakenD Enterprise components will be disclosed in the form of open-source repositories in the following weeks, and the action has already started, don&amp;rsquo;t miss it! In this post, we will explain the reasons behind this decision which might sound crazy from a business perspective in the first place. Why would anyone publish one year of paid software as free software?</description></item><item><title>Changelog: List of changes between KrakenD versions</title><link>https://www.krakend.io/changelog/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/changelog/</guid><description/></item><item><title>Key KrakenD Features - Open Source VS Enterprise</title><link>https://www.krakend.io/features/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/features/</guid><description/></item><item><title>KrakenD API Gateway Support - Get Help and Assistance</title><link>https://www.krakend.io/support/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/support/</guid><description/></item><item><title>Open Source API Gateway</title><link>https://www.krakend.io/open-source/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/open-source/</guid><description/></item><item><title>Download KrakenD API Gateway</title><link>https://www.krakend.io/download/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/download/</guid><description/></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/enterprise/v1.3/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/v1.3/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/v1.4/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.11.1_amd64_generic-linux.tar.gz.asc krakend_2.11.1_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.3.0_amd64.tar.gz.asc krakend_1.3.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_v2.0_amd64.tar.gz.asc krakend_v2.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.1/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.1/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend__amd64_generic-linux.tar.gz.asc krakend__amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.10/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.10/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.10_amd64_generic-linux.tar.gz.asc krakend_2.10_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.2/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.2/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.2_amd64_generic-linux.tar.gz.asc krakend_2.2_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.3_amd64_generic-linux.tar.gz.asc krakend_2.3_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.4/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.4/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.4_amd64_generic-linux.tar.gz.asc krakend_2.4_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.5/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.5/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.5_amd64_generic-linux.tar.gz.asc krakend_2.5_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.6/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.6/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.6_amd64_generic-linux.tar.gz.asc krakend_2.6_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.7/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.7/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.7_amd64_generic-linux.tar.gz.asc krakend_2.7_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.8/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.8/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.8_amd64_generic-linux.tar.gz.asc krakend_2.8_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.9/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.9/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.9_amd64_generic-linux.tar.gz.asc krakend_2.9_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.11.0_amd64_generic-linux.tar.gz.asc krakend_2.11.0_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v1.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.3.0_amd64.tar.gz.asc krakend_1.3.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v1.4/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.4.1_amd64.tar.gz.asc krakend_1.4.1_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.0/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_v2.0_amd64.tar.gz.asc krakend_v2.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.1/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.1/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_v2.1_amd64_generic-linux.tar.gz.asc krakend_v2.1_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.10/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.10/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.10_amd64_generic-linux.tar.gz.asc krakend_2.10_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.2/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.2/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.2_amd64_generic-linux.tar.gz.asc krakend_2.2_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.3_amd64_generic-linux.tar.gz.asc krakend_2.3_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.4/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.4/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.4_amd64_generic-linux.tar.gz.asc krakend_2.4_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.5/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.5/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.5_amd64_generic-linux.tar.gz.asc krakend_2.5_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.6/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.6/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.6_amd64_generic-linux.tar.gz.asc krakend_2.6_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.7/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.7/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.7_amd64_generic-linux.tar.gz.asc krakend_2.7_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.8/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.8/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.8_amd64_generic-linux.tar.gz.asc krakend_2.8_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.9/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.9/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg --verify krakend_2.9_amd64_generic-linux.tar.gz.asc krakend_2.9_amd64_generic-linux.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can&amp;#39;t check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Contact Sales</title><link>https://www.krakend.io/contact-sales-g2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/contact-sales-g2/</guid><description/></item><item><title>Contact Sales</title><link>https://www.krakend.io/contact-sales/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/contact-sales/</guid><description/></item><item><title>KrakenD Privacy Policy: Your Data Protection</title><link>https://www.krakend.io/contact-open-source-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.krakend.io/contact-open-source-support/</guid><description/></item></channel></rss>