<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KrakenD - Open source API Gateway</title><link>https://www.krakend.io/</link><description>Recent content on KrakenD - Open source API Gateway</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 24 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.krakend.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v1.3/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v1.4/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, spend a few minutes understanding the big pieces of the system, how it works, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very very important) Failing fast is better than succeeding slow (say it one more time!</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/v1.3/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Service Discovery overview</title><link>https://www.krakend.io/docs/v1.4/service-discovery/overview/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/overview/</guid><description>Service discovery enables clients to detect and locate services on your enterprise network automatically. Instead of defining a static list of IPs or hostnames pointing to your backends, you can use a service discovery provider and let KrakenD interact with it to get the hosts dynamically.
Static resolution The static resolution is the default service discovery choice. It uses a list of hosts declared in the configuration file and KrakenD must be able to reach them directly by hostname, DNS or IP.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/enterprise/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>Load balancing</title><link>https://www.krakend.io/docs/throttling/load-balancing/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/load-balancing/</guid><description>The natural placement of an API gateway is between API consumers and your services. When we talk about load balancing, we can refer to both sides of the gateway: ingress traffic (user to gateway) or egress traffic (gateway to services).
The different load balancer placements you can have are illustrated in the image above.
Balancing ingress traffic (to KrakenD) We recommend having a few containers or servers in production to have high availability.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block. Nevertheless you can do customizations to it.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>API Health Check</title><link>https://www.krakend.io/docs/v2.0/service-settings/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/health/</guid><description>The health endpoint (or the ping endpoint) allows you to query KrakenD to find out if it is ready to accept connections or not.
When KrakenD is up and running correctly, it exposes a /__health endpoint returning a 200 HTTP status code. It works automatically and without adding any specific configuration block.
Health check response When you query the /__health endpoint, you should expect a 200 response code or no response at all.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. To start using your own plugins make sure to write them implementing the right interface and compile them respecting the requirements.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins for understanding the different types of plugins you can use. Plugin requirements Plugin binaries are not cross-platform compatible You must compile the plugin with the same architecture/platform where it will be run.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. However, make sure to write them implementing the correct interface and compile them respecting the requirements. In this document, we will see how to do it right.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins to understand the different plugins you can use and choose the one that best adapts to your needs.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v2.0/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/writing-plugins/</guid><description>All different types of plugins let you freely implement your logic without restrictions. To start using your own plugins make sure to write them implementing the right interface and compile them respecting the requirements.
Introduction to plugins Before getting your hands dirty, read the introduction to plugins for understanding the different types of plugins you can use. Plugin requirements Plugin binaries are not cross-platform compatible You must compile the plugin with the same architecture/platform where it will be run.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v1.3/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v1.3/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v1.4/cluster/cluster-overview/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/cluster/cluster-overview/</guid><description>A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over.
A KrakenD cluster runs with the same KrakenD open source software you use today to start a single instance. Consequently no license is needed to operate a sizeable enterprise-grade API gateway.
KrakenD cluster benefits Having a KrakenD cluster provides these immediate benefits:
Increased throughput and capacity: Having more KrakenD nodes expands the number of requests the API can handle.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>High-availability cluster</title><link>https://www.krakend.io/docs/v2.0/deploying/clustering/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/clustering/</guid><description>KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.
A KrakenD cluster consists of multiple KrakenD instances running simultaneously and working together to provide increased reliability, higher throughput, scalability, and fail-over. There is no special software that you need to run a cluster other than KrakenD.</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-c&amp;nbsp;krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json&amp;nbsp;-p&amp;nbsp;8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend&amp;nbsp;run Please,&amp;nbsp;provide&amp;nbsp;the&amp;nbsp;path&amp;nbsp;to&amp;nbsp;your&amp;nbsp;config&amp;nbsp;file Show the help: Run command help&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/v1.3/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-c&amp;nbsp;krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json&amp;nbsp;-p&amp;nbsp;8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend&amp;nbsp;run Please,&amp;nbsp;provide&amp;nbsp;the&amp;nbsp;path&amp;nbsp;to&amp;nbsp;your&amp;nbsp;config&amp;nbsp;file Show the help: Run command help&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-h `7MMF'&amp;nbsp;`YMM'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM"</description></item><item><title>Running KrakenD server. The `krakend run` command</title><link>https://www.krakend.io/docs/v1.4/commands/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/commands/run/</guid><description>To start KrakenD, you need to invoke the run command with the path to the configuration file. You can also specify the port (defaults to 8080)
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-c&amp;nbsp;krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json #&amp;nbsp;or krakend&amp;nbsp;run&amp;nbsp;--config&amp;nbsp;/path/to/krakend.json&amp;nbsp;-p&amp;nbsp;8080 The krakend run command with no flags will remind you that you need the path to the configuration file:
Missing configuration file&amp;nbsp; $krakend&amp;nbsp;run Please,&amp;nbsp;provide&amp;nbsp;the&amp;nbsp;path&amp;nbsp;to&amp;nbsp;your&amp;nbsp;config&amp;nbsp;file Show the help: Run command help&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-h `7MMF'&amp;nbsp;`YMM'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM"</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/injecting-plugins/</guid><description>Your plugin is already developed and ready to use, and now you want to use it. There are two phases:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/injecting-plugins/</guid><description>You have developed your plugin or are in the middle of it. There are two phases to take into account:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Loading and injecting plugins</title><link>https://www.krakend.io/docs/v2.0/extending/injecting-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/injecting-plugins/</guid><description>Your plugin is already developed and ready to use, and now you want to use it. There are two phases:
Loading the plugin Injecting the plugin in a specific place Loading the plugin KrakenD registers plugins during startup according to its plugin configuration:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.so&amp;#34;, &amp;#34;folder&amp;#34;: &amp;#34;/opt/krakend/plugins/&amp;#34; } } Add the plugin keyword at the root of your configuration to let KrakenD know the rules to register plugins.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v2.0/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/data-manipulation/</guid><description>&lt;p>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.&lt;/p></description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
Configuration for the router To change the router behavior, add the namespace router under the global extra_config, and set one or more flags as depicted below:</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
To change the router behavior, add the namespace router under the global extra_config. The following example shows how to return the error to the client:</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
Configuration for the router To change the router behavior, add the namespace router under the global extra_config, and set one or more flags as depicted below:</description></item><item><title>Customizing router behavior</title><link>https://www.krakend.io/docs/v2.0/service-settings/router-options/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/router-options/</guid><description>The optional router configuration allows you to set global flags that change the way KrakenD processes the requests at the router layer.
Generally speaking you don&amp;rsquo;t need this. But in every case there is an exception and you might eventually need to change some value.
To change the router behavior, add the namespace router under the global extra_config. The following example shows how to return the error to the client:</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>HTTP handler plugins</title><link>https://www.krakend.io/docs/v2.0/extending/http-server-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/http-server-plugins/</guid><description>The HTTP server plugins (codenamed as handler plugins) belong to the router layer and let you modify the requests before KrakenD starts processing them or modify the final response back to the user. The HTTP handler plugin lets you write your servers and HTTP middlewares right in KrakenD and enables you to implement anything you can imagine. This plugin type is so powerful that you can use it to implement custom monetization, tracking, tenant control, protocol conversion, and heavy modifications, for example.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Key authentication using RBAC</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) mechanism by reading the Authorization header of incoming requests. For all your desired endpoints, KrakenD rejects requests from users that do not provide a valid key or are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints and private endpoints in the same configuration.</description></item><item><title>API Key authentication with rate limiting</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/api-keys/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/api-keys/</guid><description>The API key authentication enables a Role-Based Access Control (RBAC) and a rate-limiting mechanism based on an API key passed by the client. For the desired endpoints, KrakenD rejects requests from users that do not provide a valid key, are trying to access a resource with insufficient permissions for the user&amp;rsquo;s role, or are exceeding the defined quota.
The authentication is granular and works per-endpoint, meaning that you can combine public endpoints (no API Key needed) and private endpoints in the same configuration.</description></item><item><title>API Analytics</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide krakend-basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Basic endpoint authentication using .htpasswd</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/basic-authentication/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/basic-authentication/</guid><description>The Basic Authentication plugin protects the access to selected endpoints using basic username and password credentials. The functionality works at the router level, and when the authentication fails, the backend is never hit.
How does it work Basic auth functionality is provided by a plugin, meaning that a separate binary needs to be included. To do so, make sure to provide basic-auth.so, and set the configuration as described below.
KrakenD feeds from a regular.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v1.3/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v1.4/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of Extended metrics with the native Influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard.
InfluxDB configuration Notice that this document describes two different implementations of InfluxDB:
Native InfluxDB exporter (recommended) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose?</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v1.3/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v1.4/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/v1.4/service-discovery/dns-srv/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v1.3/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Writing custom plugins</title><link>https://www.krakend.io/docs/v1.4/extending/writing-plugins/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/writing-plugins/</guid><description>KrakenD&amp;rsquo;s modular design allows you to extend its functionality by adding your custom code. As an engineer, it&amp;rsquo;s always tempting to start writing code but the majority of scenarios do not require writing any. Existing modules, middleware, and plugins suffice almost everyone&amp;rsquo;s needs.
It&amp;rsquo;s important to remark, that if you want to do complex business logic checks and transformations, aside from the core functionality, there is specific scripting designed for that without compiling Go code.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>Extended metrics and the `/__stats` endpoint</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/metrics/</guid><description>The metrics middleware collects extended metrics and exposes them in the /__stats/ endpoint. The endpoint runs in a different port than the API, and contains a lot of metrics.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.
Configuration In order to add metrics to your KrakenD installation add the github_com/devopsfaith/krakend-metrics namespace under extra_config in the root of your configuration file, e.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is an encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>JSON Web Tokens overview</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-overview/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-overview/</guid><description>The JSON Web Token specification is an industry standard to represent claims securely between two parties. The JWT is a base64 encoded JSON object that contains key-value pairs of attributes that are signed by a trusted authority.
When JWT shields a specific set of endpoints, requests to the API gateway must provide a token. Verification of the token takes place in every request, including the check of the signature and optionally the assurance that its issuer, roles, and audience are sufficient to access the endpoint.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v1.3/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v1.4/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Rate-limiting backends</title><link>https://www.krakend.io/docs/v2.0/backends/rate-limit/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/rate-limit/</guid><description>No matter what is the amount of activity the users are generating at the router level, you might want to restrict the connections KrakenD makes to your backends. Configuration is similar to the router&amp;rsquo;s one, but it&amp;rsquo;s declared directly in the backend section instead of the endpoint.
This parameter is defined at the krakend.json configuration file as follows: { &amp;#34;endpoint&amp;#34;: &amp;#34;/products/{cat_id}&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;host&amp;#34;: [&amp;#34;http://some.api.com/&amp;#34;], &amp;#34;url_pattern&amp;#34;: &amp;#34;/catalog/category/{cat_id}.rss&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;rss&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;qos/ratelimit/proxy&amp;#34;: { &amp;#34;max_rate&amp;#34;: 0.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure:
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure:
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file. Although the configuration supports formats other than JSON and it can be described by multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v1.3/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file. Although the configuration supports formats other than JSON and it can be described by multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v1.4/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;version&amp;#34;: 2, &amp;#34;endpoints&amp;#34;: [], &amp;#34;extra_config&amp;#34;: {} }</description></item><item><title>Understanding the configuration file</title><link>https://www.krakend.io/docs/v2.0/configuration/structure/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/structure/</guid><description>All KrakenD behavior depends on its configuration file(s). Although the configuration supports formats other than JSON and it can be described using multiple files, you&amp;rsquo;ll find it referenced through all this documentation and for simplicity as the krakend.json. Being familiar with its structure it&amp;rsquo;s essential.
Configuration file structure There are a large number of options you can put in this file. Let&amp;rsquo;s focus now only on the main structure: { &amp;#34;$schema&amp;#34;: &amp;#34;https://www.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>Forwarding query strings and headers</title><link>https://www.krakend.io/docs/v2.0/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway with a zero-trust policy, and when it comes to forward query strings, cookies, and headers, you need to define what is allowed.
Part of the zero-trust policy implies that KrakenD does not forward any unexpected query string, headers, or cookies. See below how to set the forwarding rules.
Configuration to enable parameter forwarding You can change the default behavior according to your needs and define which elements can pass from the client to your backends.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>KrakenD servers requirements</title><link>https://www.krakend.io/docs/v2.0/deploying/server-dimensioning/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/server-dimensioning/</guid><description>When comparing KrakenD with other solutions, a key difference is that its Total Cost of Ownership is actually lower, and you can save a lot of money in infrastructure.
On the hardware side, KrakenD is very light and consumes very low resources. For instance, the consumption pattern of the baseline (we will see this definition below) is around 100-200MB of RAM and can work on production with 0.5 vCPU. This baseline can process thousands of requests per second.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/enterprise/v1.3/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/v1.3/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Setting up a cluster</title><link>https://www.krakend.io/docs/v1.4/cluster/configuration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/cluster/configuration/</guid><description>Hardware can fail at any time, and a Gateway is a piece critical enough to have redundancy of the service. Having a cluster of machines operating the service assures high availability.
KrakenD nodes are stateless and they don&amp;rsquo;t store data or application state to a persistent storage. Instead, any configuration data and application state exist within the configuration file. Nodes are expendable and replaceable at any time, as they do not hold anything.</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend&amp;nbsp;check&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;v1.3.0 Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;active&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;has&amp;nbsp;a&amp;nbsp;valid&amp;nbsp;syntax&amp;nbsp;to&amp;nbsp;run&amp;nbsp;the&amp;nbsp;service. Change&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;by&amp;nbsp;using&amp;nbsp;the&amp;nbsp;--config&amp;nbsp;flag Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;check&amp;nbsp;[flags] Aliases: &amp;nbsp;&amp;nbsp;check,&amp;nbsp;validate Examples: krakend&amp;nbsp;check&amp;nbsp;-d&amp;nbsp;-c&amp;nbsp;config.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;check &amp;nbsp;&amp;nbsp;-t,&amp;nbsp;--test-gin-routes&amp;nbsp;&amp;nbsp;&amp;nbsp;Test&amp;nbsp;the&amp;nbsp;endpoint&amp;nbsp;patterns&amp;nbsp;against&amp;nbsp;a&amp;nbsp;real&amp;nbsp;gin&amp;nbsp;router&amp;nbsp;on&amp;nbsp;selected&amp;nbsp;port Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug Passing a path to the config file is required</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/v1.3/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend&amp;nbsp;check&amp;nbsp;-h `7MMF'&amp;nbsp;`YMM'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM"""Yb. &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;.M'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Yb. &amp;nbsp;&amp;nbsp;MM&amp;nbsp;.d"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7Mb,od8&amp;nbsp;,6"Yb.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;,MP'.gP"Ya&amp;nbsp;`7MMpMMMb.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Mb &amp;nbsp;&amp;nbsp;MMMMM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM'&amp;nbsp;"'8)&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;;Y&amp;nbsp;&amp;nbsp;,M'&amp;nbsp;&amp;nbsp;&amp;nbsp;Yb&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;VMA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,pm9MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM;Mm&amp;nbsp;&amp;nbsp;8M""""""&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,MP &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;`MM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8M&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;`Mb.YM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,dP' .JMML.&amp;nbsp;&amp;nbsp;&amp;nbsp;MMb..JMML.&amp;nbsp;&amp;nbsp;`Moo9^Yo..JMML.&amp;nbsp;YA.`Mbmmd'.JMML&amp;nbsp;&amp;nbsp;JMML..JMMmmmdP' _______________________________________________________________________ Version:&amp;nbsp;1.3 Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;active&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;has&amp;nbsp;a&amp;nbsp;valid&amp;nbsp;syntax&amp;nbsp;to&amp;nbsp;run&amp;nbsp;the&amp;nbsp;service. Change&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;by&amp;nbsp;using&amp;nbsp;the&amp;nbsp;--config&amp;nbsp;flag Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;check&amp;nbsp;[flags] Aliases: &amp;nbsp;&amp;nbsp;check,&amp;nbsp;validate Examples: krakend&amp;nbsp;check&amp;nbsp;-d&amp;nbsp;-c&amp;nbsp;config.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;check &amp;nbsp;&amp;nbsp;-t,&amp;nbsp;--test-gin-routes&amp;nbsp;&amp;nbsp;&amp;nbsp;Test&amp;nbsp;the&amp;nbsp;endpoint&amp;nbsp;patterns&amp;nbsp;against&amp;nbsp;a&amp;nbsp;real&amp;nbsp;gin&amp;nbsp;router&amp;nbsp;on&amp;nbsp;selected&amp;nbsp;port Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug Passing a path to the config file is required</description></item><item><title>Commands - check</title><link>https://www.krakend.io/docs/v1.4/commands/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/commands/check/</guid><description>The krakend check command validates the passed configuration. Since KrakenD does not implement a strict parsing, typos in the config file could be shadowed. In order to validate your config completely, it is recommended to use the --debug flag.
Usage of KrakenD check&amp;nbsp; $./krakend&amp;nbsp;check&amp;nbsp;-h `7MMF'&amp;nbsp;`YMM'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7MM"""Yb. &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;.M'&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Yb. &amp;nbsp;&amp;nbsp;MM&amp;nbsp;.d"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`7Mb,od8&amp;nbsp;,6"Yb.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;,MP'.gP"Ya&amp;nbsp;`7MMpMMMb.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`Mb &amp;nbsp;&amp;nbsp;MMMMM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM'&amp;nbsp;"'8)&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;;Y&amp;nbsp;&amp;nbsp;,M'&amp;nbsp;&amp;nbsp;&amp;nbsp;Yb&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;VMA&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,pm9MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM;Mm&amp;nbsp;&amp;nbsp;8M""""""&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,MP &amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;`MM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8M&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;`Mb.YM.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MM&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,dP' .JMML.&amp;nbsp;&amp;nbsp;&amp;nbsp;MMb..JMML.&amp;nbsp;&amp;nbsp;`Moo9^Yo..JMML.&amp;nbsp;YA.`Mbmmd'.JMML&amp;nbsp;&amp;nbsp;JMML..JMMmmmdP' _______________________________________________________________________ Version:&amp;nbsp;1.4.1 Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;active&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;has&amp;nbsp;a&amp;nbsp;valid&amp;nbsp;syntax&amp;nbsp;to&amp;nbsp;run&amp;nbsp;the&amp;nbsp;service. Change&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;by&amp;nbsp;using&amp;nbsp;the&amp;nbsp;--config&amp;nbsp;flag Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;check&amp;nbsp;[flags] Aliases: &amp;nbsp;&amp;nbsp;check,&amp;nbsp;validate Examples: krakend&amp;nbsp;check&amp;nbsp;-d&amp;nbsp;-c&amp;nbsp;config.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;check &amp;nbsp;&amp;nbsp;-t,&amp;nbsp;--test-gin-routes&amp;nbsp;&amp;nbsp;&amp;nbsp;Test&amp;nbsp;the&amp;nbsp;endpoint&amp;nbsp;patterns&amp;nbsp;against&amp;nbsp;a&amp;nbsp;real&amp;nbsp;gin&amp;nbsp;router&amp;nbsp;on&amp;nbsp;selected&amp;nbsp;port Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug Passing a path to the config file is required</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model&amp;nbsp;MacBook&amp;nbsp;Pro&amp;nbsp;(MacBookPro11,4)&amp;nbsp;-&amp;nbsp;August&amp;nbsp;2015 Processor:&amp;nbsp;Intel&amp;nbsp;Core&amp;nbsp;i7&amp;nbsp;2,2&amp;nbsp;GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/enterprise/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model&amp;nbsp;MacBook&amp;nbsp;Pro&amp;nbsp;(MacBookPro11,4)&amp;nbsp;-&amp;nbsp;August&amp;nbsp;2015 Processor:&amp;nbsp;Intel&amp;nbsp;Core&amp;nbsp;i7&amp;nbsp;2,2&amp;nbsp;GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model&amp;nbsp;MacBook&amp;nbsp;Pro&amp;nbsp;(MacBookPro11,4)&amp;nbsp;-&amp;nbsp;August&amp;nbsp;2015 Processor:&amp;nbsp;Intel&amp;nbsp;Core&amp;nbsp;i7&amp;nbsp;2,2&amp;nbsp;GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v1.3/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v1.4/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>Comparison of KrakenD vs other products in the market (Benchmark)</title><link>https://www.krakend.io/docs/v2.0/benchmarks/api-gateway-benchmark/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/api-gateway-benchmark/</guid><description>We wanted to compare our own product with other similar products in the market. In order to do so we used the same environment and conditions and tested the following products:
Kong Vulcand Tyk KrakenD For the benchmarks, we based the tests on the benchmarking project varnish/api-gateway-benchmarks.
At the time of writing, KrakenD does not support auth features, so we just did the benchmark with test01
Hardware hardware specs&amp;nbsp; $Model&amp;nbsp;MacBook&amp;nbsp;Pro&amp;nbsp;(MacBookPro11,4)&amp;nbsp;-&amp;nbsp;August&amp;nbsp;2015 Processor:&amp;nbsp;Intel&amp;nbsp;Core&amp;nbsp;i7&amp;nbsp;2,2&amp;nbsp;GHz Setup For this test, we stored this configuration at krakend.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v1.3/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v1.4/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>KrakenD Benchmarks on AWS</title><link>https://www.krakend.io/docs/v2.0/benchmarks/aws/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/aws/</guid><description>The following numbers show the execution results for the KrakenD benchmarks on Amazon EC2 machines.
Benchmark Setup This set of benchmarks have been running on different AWS EC2 instances. Each individual test consists of spinning up 3 different machines, being:
A web server: A LWAN web server using an instance c4.xlarge. This is the &amp;ldquo;fake API&amp;rdquo; where KrakenD will take the data The HTTP load generator: The machine actually running the load test.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v1.3/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>Data manipulation</title><link>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/data-manipulation/</guid><description>This page describes the most basic options to manipulate the content you receive from the backend before delivering it to the client.
Filtering When you offer a KrakenD endpoint, you can decide whether to return all the fields from the backend (default behavior) or specify which ones are allowed through an allow or deny list. You might want to use this functionality for many different reasons. Still, we strongly encourage you to consider using it frequently to save the user&amp;rsquo;s bandwidth, provide the client what is needed, and decrease the load and render times.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/dns-srv/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>SD with DNS SRV (e.g., Consul, k8s)</title><link>https://www.krakend.io/docs/v1.3/service-discovery/dns-srv/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/dns-srv/</guid><description>The DNS SRV is a market standard used by systems such as Kubernetes, Mesos, Haproxy, Nginx plus, AWS ECS, Linkerd, and more.
To integrate Consul as the Service Discovery or any other DNS SRV compatible systems you only need to set two keys:
&amp;quot;sd&amp;quot;: &amp;quot;dns&amp;quot;: To set service discovery = DNS SRV &amp;quot;host&amp;quot;: []: The list of all the names providing the resolution These keys need to be added in the backend section of your configuration.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box by adding them to the configuration file. You can also add your own or 3rd parties middleware to extend this behavior.
KrakenD performance tests measure the operations in nanoseconds, and you can find the benchmark for every response manipulation in the benchmarks section
The following manipulations are available by default:
Aggregation and merging When you have more than one backend connected to an endpoint that is not using the no-op encoding, the gateway aggregates and merges the responses from all backends automatically in the final response.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v1.3/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v1.4/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Response manipulation</title><link>https://www.krakend.io/docs/v2.0/endpoints/response-manipulation/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/response-manipulation/</guid><description>KrakenD allows you to perform several manipulations of the responses out of the box, just by adding them to the configuration file. You can also add your own or 3rd parties middlewares to extend this behavior.
KrakenD manipulations are measured in nanoseconds, you can find the benchmark for every response manipulation in the benchmarks
The following manipulations are available by default:
Merging When you create KrakenD endpoints, if a specific endpoint feeds from 2 or more backend sources (APIs), they will be automatically merged in a single response to the client.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/service-discovery/</guid><description>The service discovery (sd) is an optional attribute of the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
Related read You might also want to read the Load Balancer documentation The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/service-discovery/</guid><description>Service discovery (sd) is an attribute in the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Service Discovery</title><link>https://www.krakend.io/docs/v2.0/backends/service-discovery/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/service-discovery/</guid><description>Service discovery (sd) is an attribute in the backend section that enables KrakenD to detect and locate services automatically on your enterprise network.
The chosen service discovery strategy determines how to retrieve (statically or dynamically) the final list of IPs, hostnames, or services pointing to your backends. If your host list is dynamic, you can use an external service discovery provider and let KrakenD interact with it to get the hosts.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set the maximum requests per second (convertible from minutes or hours, too) a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set a number of maximum requests per second a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/v1.3/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Endpoint rate limiting</title><link>https://www.krakend.io/docs/v1.4/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/rate-limit/</guid><description>Limiting endpoints is the responsibility of the router rate and allows you to set the number of maximum requests per second a KrakenD endpoint will accept. By default, there is no limitation on the number of requests an endpoint can handle.
To specify a rate limit, you need to add the configuration in the desired endpoint.
At the router level, you can set the rate limit for endpoints based on:</description></item><item><title>Router Rate-limiting</title><link>https://www.krakend.io/docs/v2.0/endpoints/rate-limit/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/rate-limit/</guid><description>The router rate limit feature allows you to set a number of maximum requests per second a KrakenD endpoint will accept. There are two different strategies to set limits that you can use separately or together:
Endpoint rate-limiting: applies simultaneously to all your customers using the endpoint, sharing the same counter. User rate-limiting: applies to an individual user. Both types keep in-memory an updated counter with the number of requests processed per second in that endpoint.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Understanding the Token Bucket algorithm</title><link>https://www.krakend.io/docs/v2.0/throttling/token-bucket/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/token-bucket/</guid><description>The Token Bucket algorithm helps you to allow or deny requests depending on the levels of traffic you are having. The algorithm is used to offer functionalities like the Spike Arrest and the several Rate Limiting options.
A quick analogy&amp;hellip; If you ever went to a travelling carnival, funfair, or amusement park, to get into the attractions, you probably exchanged money for tokens/tickets at the ticket booth. The tokens help the operator of the carousel, bumper cars, or chance games stand, to collect the payment faster and know who can jump in and who doesn&amp;rsquo;t.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send responses back to the client in a different format than what your services provide.</description></item><item><title>Output encoding</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-types/</guid><description>An important concept to get familiar with is that by default, KrakenD does not work as a reverse proxy (unless you use the no-op encoding). When clients consume upstream services content through KrakenD, it is automatically transformed to the encoding of your choice, and you have the opportunity to manipulate and aggregate data easily.
KrakenD can send responses back to the client in a different format than what your services provide.</description></item><item><title>Advanced manipulation with JMESPath</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Response manipulation with query language</title><link>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/jmespath/</guid><description>If you&amp;rsquo;d like to apply advanced manipulations before you return the API data, the modifier/jmespath allows you to apply JSON query language expressions. Fine-tune the final content delivered to the user, and even add the possibility to add small logic chunks.
The JMESPath query language allows you to select, slice, filter, map, project, flatten, sort, and all sorts of operations. To get familiar with the language, we recommend reading the JMESPath Tutorial and the JMESPath examples.</description></item><item><title>Global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v1.3/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v1.4/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Local Benchmarks</title><link>https://www.krakend.io/docs/v2.0/benchmarks/local/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/benchmarks/local/</guid><description>Hardware Model MacBook Pro (MacBookPro11,4) - August 2015 Processor: Intel Core i7 2,2 GHz Setup For this test, we stored this configuration at krakend.json
{ &amp;quot;version&amp;quot;: 1, &amp;quot;endpoints&amp;quot;: [ { &amp;quot;endpoint&amp;quot;: &amp;quot;/foo&amp;quot;, &amp;quot;method&amp;quot;: &amp;quot;GET&amp;quot;, &amp;quot;backend&amp;quot;: [ { &amp;quot;url_pattern&amp;quot;: &amp;quot;/__debug/bar&amp;quot;, &amp;quot;host&amp;quot;: [ &amp;quot;http://127.0.0.1:8080&amp;quot; ] } ], &amp;quot;concurrent_calls&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;max_rate&amp;quot;: 100000 } ], &amp;quot;oauth&amp;quot;: { &amp;quot;disable&amp;quot;: true }, &amp;quot;cache_ttl&amp;quot;: &amp;quot;5m&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;5s&amp;quot; } And we started the KrakenD with this cmd:</description></item><item><title>Response manipulation with regular expressions</title><link>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/content-replacer/</guid><description>The content replacer plugin allows you to modify the response of your services by doing literal replacements or more sophisticated replacements with regular expressions.
The plugin works both in the endpoint and the backend sections. Depending on what stage of the pipe you want to modify, the content is replaced before it gets to the user (endpoint) or before the merging operation (backend).
The content to replace must be a string and located inside an object or a children object.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>Spike Arrest and Burst</title><link>https://www.krakend.io/docs/v2.0/throttling/spike-arrest/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/spike-arrest/</guid><description>The Spike Arrest policy ensures a minimum time between different requests. KrakenD will enable Spike Arrest after exhausting the burst capacity of the rate-limiting features.
Bursting control The bursting control is the policy that defines what to do when you reach the throttling capacity of the system within a second.
When users consume content with rate-limiting enabled, the capacity of the rate limit defines the bursting they can have. Bursting makes users have a relatively higher number of requests for a short time.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/enterprise/v2.0/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>AMQP driver for Async Agent</title><link>https://www.krakend.io/docs/v2.0/async/amqp/</link><pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/async/amqp/</guid><description>The AMQP driver for Async agents allows you to have KrakenD consuming AMQP queues autonomously. Routines listening to AMQP queues will react by themselves to new events and push data to your backends.
This driver is different from the AMQP backend consumer. As opposed to endpoints, async agents do not require users to request something to trigger an action. Instead, the agents connect to the queue and fire an action when an event is delivered.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Automated KrakenD deployments with CI/CD</title><link>https://www.krakend.io/docs/v2.0/deploying/ci-cd/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/ci-cd/</guid><description>KrakenD operates with its single binary and your associated configuration. Therefore, your build process or CI/CD pipeline only needs to ensure that the configuration file is correct. These are a few recommendations to a safes KrakenD deployment:
Make sure the configuration file is valid. When using Flexible Configuration, generate the final krakend.json using FC_OUT as the final artifact Optional - Generate an immutable docker image Optional - Run integration tests Deploy the new configuration There are several ways to automate KrakenD deployments, but you must always test your configuration before applying it in production.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROMdevopsfaith/krakend:2.1.3COPY krakend.json /etc/krakend/krakend.json# Uncomment with Enterprise image:# COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be:
FROMkrakend/krakend-ee:2.1.1COPY krakend.json /etc/krakend/krakend.json# Uncomment with Enterprise image:# COPY LICENSE /etc/krakend/LICENSE Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be: FROMkrakend/krakend-ee:2.0COPY krakend.json /etc/krakend/krakend.json# Uncomment with Enterprise image:# COPY LICENSE /etc/krakend/LICENSE
Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>Generating a Docker artifact</title><link>https://www.krakend.io/docs/v2.0/deploying/docker/</link><pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/docker/</guid><description>If you use containers, the recommended approach is to write your own Dockerfile and deploy an immutable artifact (embedding the config).
In its simplified form would be: FROMdevopsfaith/krakend:v2.0COPY krakend.json /etc/krakend/krakend.json# Uncomment with Enterprise image:# COPY LICENSE /etc/krakend/LICENSE
Volume or copy? Even though you can use the official container directly and attach the configuration mounting an external volume (or ConfigMap in Kubernetes), a custom image with your configuration copied inside has benefits.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>HTTP Client plugins (proxy layer)</title><link>https://www.krakend.io/docs/v2.0/extending/http-client-plugins/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/http-client-plugins/</guid><description>The HTTP client plugins execute in the proxy layer, this is when KrakenD tries to reach your backends for content. They allow you to intercept, transform, and manipulate the requests before they hit your backend services, and its way back. It is the perfect time to modify the request before it reaches the backend.
HTTP client plugins cannot be chained. You can use up to one plugin per backend connection.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract.</description></item><item><title>Native InfluxDB exporter</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/influxdb/</link><pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/influxdb/</guid><description>KrakenD can expose detailed and extended metrics via the krakend-metrics). The krakend-influx component lets you send these extended KrakenD metrics to InfluxDB.
Notice that there are two different implementations of InfluxDB in KrakenD:
Native InfluxDB exporter (this page) OpenCensus InfluxDB exporter Which InfluxDB implementation should I choose? The native implementation exports data from a collector that is tailor-made for KrakenD, and also richer in content and less abstract.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v2.0/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Google Analytics</title><link>https://www.krakend.io/docs/enterprise/telemetry/google-analytics/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/google-analytics/</guid><description>Google Analytics provides a reliable platform to measure the ROI of your API and track its usage. In addition, the KrakenD GAnalytics integration allows you to generate API Analytics from your API activity, using Google&amp;rsquo;s Analytics platform as the storage backend. The same platform and tools you are using today to track web pages can help you track your API.
This component records the API activity and reports it efficiently and asynchronously in batches to Google Analytics.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://domain-a.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/v1.3/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://domain-a.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/v1.4/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Enabling Cross Origin Resource Sharing (CORS)</title><link>https://www.krakend.io/docs/v2.0/service-settings/cors/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/cors/</guid><description>When KrakenD endpoints are consumed from a browser, you might need to enable the Cross-Origin Resource Sharing (CORS) module as browsers restrict cross-origin HTTP requests initiated from scripts.
When the Cross-Origin Resource Sharing (CORS) configuration is enabled, KrakenD uses additional HTTP headers to tell browsers that they can use resources from a different origin (domain, protocol, or port). For instance, you will need this configuration if your web page is hosted at https://www.</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the license details to use the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the certificates to access the Enterprise content. Docker If you are already familiar with Docker, the easiest way to get started is by pulling our KrakenD image from Azure or AWS.</description></item><item><title>Installing KrakenD Enterprise</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/installing/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/installing/</guid><description>KrakenD Enterprise is delivered in several formats, including Docker, Linux packages (deb, rpm) and generic installation options.
Find your KrakenD License email To download any Enterprise binaries, check your inbox and find our license activation email with the certificates to access the Enterprise content. Don&amp;rsquo;t have one? Ask for a trial version Pre-requisites Part of the private content you will need to run KrakenD Enterprise is stored in AWS or Azure.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of krakend-metrics with the native krakend-influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard can feed from here and provide you a useful.
InfluxDB configuration Notice that there are two different implementations of InfluxDB in KrakenD that are described in this document:</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v2.0/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/influxdb/</guid><description>KrakenD can expose very detailed metrics to provide a monitoring dashboard. One of the richest monitoring solutions at the metrics level is the combination of krakend-metrics with the native krakend-influx exporter. The two components let you send detailed metrics to InfluxDB and draw them later on our preconfigured Grafana dashboard can feed from here and provide you a useful.
InfluxDB configuration Notice that there are two different implementations of InfluxDB in KrakenD that are described in this document:</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/enterprise/v1.3/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/v1.3/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>Plugin and dependencies validator</title><link>https://www.krakend.io/docs/v1.4/extending/plugin-tools/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extending/plugin-tools/</guid><description>The plugin validator is an online tool that allows you to find problems with your plugin dependencies. Go plugins are strict on which versions of libraries you can use, so it&amp;rsquo;s important to make sure that your dependencies are compatible with the selected KrakenD versions.
Access the online plugin validation tools The plugin validator checks your go.sum file to find problems and reports all associated problems. From which Go version is supported, to which individual libraries will conflict during runtime.</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-validation/</guid><description>The component krakend-jose is responsible for the JWT validation and protects endpoints from public usage, requiring end-users to provide a valid token to access its contents.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-validation/</guid><description>The component krakend-jose is responsible for the JWT validation and protects endpoints from public usage, requiring end-users to provide a valid token to access its contents.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JWT Validation</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g.: Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>JSON Web Token Validation</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-validation/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-validation/</guid><description>Protect endpoints from public usage by validating JWT tokens generated by any industry-standard OpenID Connect (OIDC) integration.
Before digging any further, some answers to frequently asked questions:
KrakenD does not generate the tokens itself. Still, you can plug it into any SaaS or self-hosted OpenID Identity Provider (IdP) using industry standards (e.g., Auth0, Azure AD, Google Firebase, Keycloak, etc.)
KrakenD does not need to validate all calls using your IdP.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v2.0/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration file into several pieces for a more natural organization.
When the Flexible Configuration is enabled, KrakenD assumes that your configuration file is a template that needs compilation during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v1.3/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration file into several pieces for a more natural organization.
When the Flexible Configuration is enabled, KrakenD assumes that your configuration file is a template that needs compilation during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.</description></item><item><title>Flexible configuration</title><link>https://www.krakend.io/docs/v1.4/configuration/flexible-config/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/flexible-config/</guid><description>The Flexible Configuration component is included in the KrakenD API Gateway and allows you to split the configuration into multiple files while using variables and templates.
The Flexible Configuration enables template processing. It compiles during start-up time. With this, you have the opportunity to produce a more sophisticated configuration file that utilizes variables and brings content from external files.
A template system gives you full flexibility to work with the configuration file.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>IDE integration</title><link>https://www.krakend.io/docs/v2.0/developer/ide-integration/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/ide-integration/</guid><description>Automatic validation as you type, showing documentation while hovering an attribute, explanation of errors, and autocompletion of properties, are features that you get automatically while working with KrakenD.
For users of Visual Studio Code, Android Studio, JetBrains editors (PHPStorm, PyCharm, GoLand, WebStorm, IntelliJ IDEA&amp;hellip;), Eclipse, and other IDEs that have built-in json schema validation capabilities, there is nothing to install to have these features. Other editors can be used as well, but you will likely need to instal a JSON schema validator.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v1.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v1.3/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v1.4/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. That should be as simple as:
FROM devopsfaith/krakend COPY krakend.json /etc/krakend/krakend.json If you use flexible-configuration you might want to add a previous generation of the krakend.json file using a multi-step Docker.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Validating the configuration with `check`</title><link>https://www.krakend.io/docs/v2.0/configuration/check/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/check/</guid><description>The krakend check command validates KrakenD configuration files written in any of its supported formats.
It&amp;rsquo;s able to perform three things:
Syntax validation - For any format (.yml, .json, .toml, etc) Linting - Besides checking that the file isn&amp;rsquo;t malformed, the linter checks your config exhaustively against KrakenD&amp;rsquo;s official schema to detect wrong types, unknown attributes, or misplaced components. Only available when you work with JSON formats. Testing - It tests a run of the service to catch problems that are not strictly related to linting but to the runtime.</description></item><item><title>Service Discovery with etcd (deprecated)</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/etcd/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/etcd/</guid><description>Deprecated Since KrakenD 1.3.0 etcd is not longer supported. The documentation is left here for reference. The etcd Service Discovery integration allows you to perform the host resolution using your existing etcd setup.
The integration etcd is controlled by the krakend-etcd component and adds client and subscriber capabilities for etcd.
Enabling etcd To enable the integration add in the root of your configuration file the necessary settings:</description></item><item><title>Service Discovery with etcd (deprecated)</title><link>https://www.krakend.io/docs/v1.3/service-discovery/etcd/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/etcd/</guid><description>Deprecated Since KrakenD 1.3.0 etcd is not longer supported. The documentation is left here for reference. The etcd Service Discovery integration allows you to perform the host resolution using your existing etcd setup.
The integration etcd is controlled by the krakend-etcd component and adds client and subscriber capabilities for etcd.
Enabling etcd To enable the integration add in the root of your configuration file the necessary settings:</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v1.3/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/circuit-breaker/</guid><description>To keep KrakenD responsive and resilient, we added a Circuit Breaker middleware on several processing pipe points. Thanks to this component, when KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail. It is also useful for dealing with network and other communication problems by preventing too many requests to fail due to timeouts, etc.</description></item><item><title>The Circuit Breaker</title><link>https://www.krakend.io/docs/v2.0/backends/circuit-breaker/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/circuit-breaker/</guid><description>The Circuit Breaker is a straightforward state machine in the middle of the request and response that monitors all your backend failures. When they reach a configured threshold, the circuit breaker will prevent sending more traffic to a failing backend.
When KrakenD demands more throughput than your actual API stack can deliver properly, the Circuit Breaker mechanism will detect the failures and prevent stressing your servers by not sending requests that are likely to fail.</description></item><item><title>Installing KrakenD</title><link>https://www.krakend.io/docs/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>Installing KrakenD</title><link>https://www.krakend.io/docs/v1.3/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download KrakenD and Generate the configuration file
Just exploring?
Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API. Everything is ready to start playing, just do a docker-compose up!</description></item><item><title>Installing KrakenD</title><link>https://www.krakend.io/docs/v1.4/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download KrakenD and Generate the configuration file
Just exploring?
Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API. Everything is ready to start playing, just do a docker-compose up!</description></item><item><title>Installing KrakenD</title><link>https://www.krakend.io/docs/v2.0/overview/installing/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/installing/</guid><description>KrakenD is a single binary file that does not require any external libraries to work. To install KrakenD choose your operative system in the downloads section or use the Docker image.
Download Generate a config file Installation You can install (or just run) KrakenD using different options. Just exploring? Use the KrakenD Playground if you want to play with KrakenD without configuring it. The Playground comes with several flavors of KrakenD and a mock API.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v1.3/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v1.4/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>KrakenD Status Codes</title><link>https://www.krakend.io/docs/v2.0/endpoints/status-codes/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/status-codes/</guid><description>When consuming content through KrakenD, the status code returned to the client depends on the chosen configuration. Three different approaches impact status codes:
Use KrakenD regular endpoints to get the status codes as designed by KrakenD Return the status code as provided by your backend server (see the no-op encoding) Use custom logic to set specific status codes Default status codes of KrakenD endpoints Unless the no-op encoding is set, the following status codes are the default behavior of any KrakenD endpoint.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command launches the integration tests.
Creating e2e test files In essence, you must create a specs folder and place the test files inside.</description></item><item><title>Automated End-to-End (E2E) tests</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and ensuring that the gateway can start, you can run integration tests to guarantee that all the active software components from beginning to end have the expected flow and that the gateway returns what you planned.
The krakend e2e command launches the integration tests.
Creating e2e test files In essence, all you need to do is create a specs folder and place the test files inside.</description></item><item><title>Automated integration tests</title><link>https://www.krakend.io/docs/v2.0/developer/integration-tests/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/integration-tests/</guid><description>In addition to checking the syntax of your KrakenD configuration and make sure that the gateway can start, you can run integration tests to make sure that the gateway returns the expected content from the consumed backends. to make sure all endpoints are properly connected and that they reply with the expected content. To do that, you can use the library that KrakenD is relying on to run its integration tests, and complement the unit testing battery.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/run/</guid><description>After installing KrakenD, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;2.1.1 KrakenD&amp;nbsp;is&amp;nbsp;a&amp;nbsp;declarative&amp;nbsp;high-performance&amp;nbsp;API&amp;nbsp;gateway&amp;nbsp;that&amp;nbsp;helps&amp;nbsp;you&amp;nbsp;effortlessly&amp;nbsp;adopt&amp;nbsp;microservices Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;[command] Available&amp;nbsp;Commands: &amp;nbsp;&amp;nbsp;check&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;is&amp;nbsp;valid. &amp;nbsp;&amp;nbsp;check-plugin&amp;nbsp;Checks&amp;nbsp;your&amp;nbsp;plugin&amp;nbsp;dependencies&amp;nbsp;are&amp;nbsp;compatible. &amp;nbsp;&amp;nbsp;e2e&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Executes&amp;nbsp;an&amp;nbsp;end&amp;nbsp;to&amp;nbsp;end&amp;nbsp;test&amp;nbsp;for&amp;nbsp;the&amp;nbsp;gateway&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;and&amp;nbsp;a&amp;nbsp;set&amp;nbsp;of&amp;nbsp;specs. &amp;nbsp;&amp;nbsp;generate&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Generates&amp;nbsp;static&amp;nbsp;content&amp;nbsp;for&amp;nbsp;several&amp;nbsp;functionalities.&amp;nbsp;See&amp;nbsp;subcommands. &amp;nbsp;&amp;nbsp;help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Help&amp;nbsp;about&amp;nbsp;any&amp;nbsp;command &amp;nbsp;&amp;nbsp;run&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Runs&amp;nbsp;the&amp;nbsp;KrakenD&amp;nbsp;server. &amp;nbsp;&amp;nbsp;version&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Shows&amp;nbsp;KrakenD&amp;nbsp;version. Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;krakend Use&amp;nbsp;"krakend&amp;nbsp;[command]&amp;nbsp;--help"&amp;nbsp;for&amp;nbsp;more&amp;nbsp;information&amp;nbsp;about&amp;nbsp;a&amp;nbsp;command. To see all the options of a command type krakend help &amp;lt;COMMAND&amp;gt; or krakend &amp;lt;COMMAND&amp;gt; -h.
To start the server, invoke the krakend run command.</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/usage/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/usage/</guid><description>From an operations point of view, KrakenD is very simple to use. It only requires you to pass the path to the configuration file(s) which define behaviors and endpoints.
Make sure KrakenD can find a krakend.json and a LICENSE file. You can create an initial krakend.json with the following content:
Create a minimal configuration file&amp;nbsp; $echo&amp;nbsp;'{&amp;nbsp;"version":&amp;nbsp;2&amp;nbsp;}'&amp;nbsp;&amp;nbsp;krakend.json And then run the container (AWS example):
Running KrakenD using the Docker container&amp;nbsp; $docker&amp;nbsp;run&amp;nbsp;-p&amp;nbsp;8080:8080&amp;nbsp;-v&amp;nbsp;"</description></item><item><title>Running KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/run/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/run/</guid><description>After installing KrakenD, you can start using it by typing krakend help:
The krakend command&amp;nbsp; $krakend ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;v2.0 KrakenD&amp;nbsp;is&amp;nbsp;a&amp;nbsp;declarative&amp;nbsp;high-performance&amp;nbsp;API&amp;nbsp;gateway&amp;nbsp;that&amp;nbsp;helps&amp;nbsp;you&amp;nbsp;effortlessly&amp;nbsp;adopt&amp;nbsp;microservices Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;[command] Available&amp;nbsp;Commands: &amp;nbsp;&amp;nbsp;check&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;is&amp;nbsp;valid. &amp;nbsp;&amp;nbsp;check-plugin&amp;nbsp;Checks&amp;nbsp;your&amp;nbsp;plugin&amp;nbsp;dependencies&amp;nbsp;are&amp;nbsp;compatible. &amp;nbsp;&amp;nbsp;e2e&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Executes&amp;nbsp;an&amp;nbsp;end&amp;nbsp;to&amp;nbsp;end&amp;nbsp;test&amp;nbsp;for&amp;nbsp;the&amp;nbsp;gateway&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;and&amp;nbsp;a&amp;nbsp;set&amp;nbsp;of&amp;nbsp;specs. &amp;nbsp;&amp;nbsp;generate&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Generates&amp;nbsp;static&amp;nbsp;content&amp;nbsp;for&amp;nbsp;several&amp;nbsp;functionalities.&amp;nbsp;See&amp;nbsp;subcommands. &amp;nbsp;&amp;nbsp;help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Help&amp;nbsp;about&amp;nbsp;any&amp;nbsp;command &amp;nbsp;&amp;nbsp;run&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Runs&amp;nbsp;the&amp;nbsp;KrakenD&amp;nbsp;server. Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;krakend Use&amp;nbsp;"krakend&amp;nbsp;[command]&amp;nbsp;--help"&amp;nbsp;for&amp;nbsp;more&amp;nbsp;information&amp;nbsp;about&amp;nbsp;a&amp;nbsp;command. To see all the options of a command type krakend help &amp;lt;COMMAND&amp;gt; or krakend &amp;lt;COMMAND&amp;gt; -h.
To start the server, invoke the krakend run command.</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Request and response modifier plugins</title><link>https://www.krakend.io/docs/v2.0/extending/plugin-modifiers/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/plugin-modifiers/</guid><description>The request and response modifier plugins are a type of KrakenD customization that allow you to code your own business logic directly on requests and responses in a simple and extensible way. These plugins complement the handler plugins, and the client executor plugins and avoid their limitations and extra overload.
The injecting of the modifiers is placed at the beginning of the proxy pipe (just after the router layer) and before the request executor (where the executor plugins are injected).</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v1.3/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/v1.4/extended-metrics/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/extended-metrics/grafana/</guid><description>The Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Configure Grafana Add the following configuration to your krakend.</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/enterprise/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Preconfigured Grafana dashboard</title><link>https://www.krakend.io/docs/telemetry/grafana/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/grafana/</guid><description>The preconfigured Grafana dashboard for KrakenD offers valuable information to understand the performance of your services and detect anomalies in the service.
The dashboard is extensive and offers you metrics like:
Requests from users to KrakenD Requests from KrakenD to your backends Response times Memory usage and details Endpoints and status codes Heatmaps Open connections Throughput Distributions, timers, garbage collection and a long etcetera Importing a Grafana dashboard These are the different Grafana data sources you can use for our dashboards:</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Control of bot traffic</title><link>https://www.krakend.io/docs/v2.0/throttling/botdetector/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/botdetector/</guid><description>The bot detector module checks incoming connections to the gateway to determine if a bot made them, helping you detect and reject bots carrying out scraping, content theft, and form spam.
Bots are detected by inspecting the User-Agent and comparing its value with a set of configuration rules provided by you. The bot detector module does not set any initial rules, meaning that is up to you to decide the best rules for your use case, and choose how restrictive or permissive you are with bots.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Enabling TLS for HTTPS and HTTP/2</title><link>https://www.krakend.io/docs/v2.0/service-settings/tls/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/tls/</guid><description>There are two different strategies when using TLS over KrakenD:
Use TLS for HTTPS and HTTP/2 in KrakenD (this document) Use a balancer with TLS termination in front of KrakenD (e.g., ELB, HAproxy) In case you want to enable TLS in KrakenD you need to add a tls key at service level (configuration&amp;rsquo;s file root) with at least the public key and the private key. When you add TLS, KrakenD listens only using TLS, and no traffic to plain HTTP is accepted.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Generate signed JWT tokens</title><link>https://www.krakend.io/docs/enterprise/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your existing login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity/OAuth server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v1.3/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v1.4/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>JWT Signing</title><link>https://www.krakend.io/docs/v2.0/authorization/jwt-signing/</link><pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/jwt-signing/</guid><description>The JWT signing component creates a wrapper for your login endpoint that signs with your secret key the selected fields of the backend payload right before returning the content to the end-user.
The primary usage for this component is in migrations from monolith to microservices, or in ecosystems where there is no Identity server yet, as it allows the immediate adoption of signed JSON Web Tokens without the need to implement a new service.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/v1.3/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Parameter forwarding</title><link>https://www.krakend.io/docs/v1.4/endpoints/parameter-forwarding/</link><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/parameter-forwarding/</guid><description>KrakenD is an API Gateway, and when it comes to forward query strings, cookies, and headers, it does not behave like a regular proxy by forwarding parameters to the backend.
The default policy for data forwarding works as follows:
No query string parameters are forwarded to the backend No headers are forwarded No cookies are forwarded You can change this behavior according to your needs, and define which elements are allowed to pass.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion:apps/v1kind:Deploymentmetadata:name:krakend-deploymentspec:selector:matchLabels:app:krakendreplicas:2template:metadata:labels:app:krakendspec:containers:- name:krakendimage:YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion:apps/v1kind:Deploymentmetadata:name:krakend-deploymentspec:selector:matchLabels:app:krakendreplicas:2template:metadata:labels:app:krakendspec:containers:- name:krakendimage:YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/enterprise/v2.0/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion:apps/v1kind:Deploymentmetadata:name:krakend-deploymentspec:selector:matchLabels:app:krakendreplicas:2template:metadata:labels:app:krakendspec:containers:- name:krakendimage:YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Deploying to Kubernetes</title><link>https://www.krakend.io/docs/v2.0/deploying/kubernetes/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/deploying/kubernetes/</guid><description>Deploying KrakenD in Kubernetes requires a straightforward configuration.
Create a Dockerfile that includes the configuration of the service. Read how to generate a Docker artifact for detailed instructions. You could also use a ConfigMap, although the recommendation is to use immutable artifacts.
From here you need to create a NodePort and send all the traffic to KrakenD.
Deployment definition YAML The KrakenD deployment definition, in a file called deployment-definition.yaml:
apiVersion:apps/v1kind:Deploymentmetadata:name:krakend-deploymentspec:selector:matchLabels:app:krakendreplicas:2template:metadata:labels:app:krakendspec:containers:- name:krakendimage:YOUR-KRAKEND-IMAGE:1.</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;2.1.3 The&amp;nbsp;API&amp;nbsp;Gateway&amp;nbsp;builder Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;[command] Available&amp;nbsp;Commands: &amp;nbsp;&amp;nbsp;check&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;is&amp;nbsp;valid. &amp;nbsp;&amp;nbsp;check-plugin&amp;nbsp;&amp;nbsp;Check&amp;nbsp;the&amp;nbsp;compatibility&amp;nbsp;with&amp;nbsp;the&amp;nbsp;plugin&amp;nbsp;deps. &amp;nbsp;&amp;nbsp;help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Help&amp;nbsp;about&amp;nbsp;any&amp;nbsp;command &amp;nbsp;&amp;nbsp;run&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Run&amp;nbsp;the&amp;nbsp;KrakenD&amp;nbsp;server. &amp;nbsp;&amp;nbsp;version&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Shows&amp;nbsp;KrakenD&amp;nbsp;version. Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;krakend Use&amp;nbsp;"krakend&amp;nbsp;[command]&amp;nbsp;--help"&amp;nbsp;for&amp;nbsp;more&amp;nbsp;information&amp;nbsp;about&amp;nbsp;a&amp;nbsp;command. You can use the following commands:</description></item><item><title>Running KrakenD server</title><link>https://www.krakend.io/docs/v2.0/overview/run/</link><pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/run/</guid><description>After installing KrakenD, you can start using KrakenD by typing krakend. To see all the options of krakend, type krakend -h or krakend &amp;lt;COMMAND&amp;gt; -h. For instance, the krakend run help is:
Run command help&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;v2.0 The&amp;nbsp;API&amp;nbsp;Gateway&amp;nbsp;builder Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;[command] Available&amp;nbsp;Commands: &amp;nbsp;&amp;nbsp;check&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Validates&amp;nbsp;that&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file&amp;nbsp;is&amp;nbsp;valid. &amp;nbsp;&amp;nbsp;check-plugin&amp;nbsp;&amp;nbsp;Check&amp;nbsp;the&amp;nbsp;compatibility&amp;nbsp;with&amp;nbsp;the&amp;nbsp;plugin&amp;nbsp;deps. &amp;nbsp;&amp;nbsp;help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Help&amp;nbsp;about&amp;nbsp;any&amp;nbsp;command &amp;nbsp;&amp;nbsp;run&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Run&amp;nbsp;the&amp;nbsp;KrakenD&amp;nbsp;server. Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;krakend Use&amp;nbsp;"krakend&amp;nbsp;[command]&amp;nbsp;--help"&amp;nbsp;for&amp;nbsp;more&amp;nbsp;information&amp;nbsp;about&amp;nbsp;a&amp;nbsp;command. To start the server, invoke the krakend run command.</description></item><item><title>Using KrakenD</title><link>https://www.krakend.io/docs/v1.3/overview/usage/</link><pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/usage/</guid><description>From an operations point of view KrakenD, is very simple to use. It only requires you to pass the path the configuration file (which defines behaviors and endpoints). Additionally, you can enable the debug with the -d flag, and that&amp;rsquo;s pretty much everything.
TL;DR Generate a configuration file with your endpoints definition. The easier way to generate it is using the designer Check the syntax of your krakend.json is good Syntax checking&amp;nbsp; $krakend&amp;nbsp;check&amp;nbsp;--config&amp;nbsp;krakend.</description></item><item><title>Using KrakenD</title><link>https://www.krakend.io/docs/v1.4/overview/usage/</link><pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/usage/</guid><description>From an operations point of view KrakenD, is very simple to use. It only requires you to pass the path the configuration file (which defines behaviors and endpoints). Additionally, you can enable the debug with the -d flag, and that&amp;rsquo;s pretty much everything.
TL;DR Generate a configuration file with your endpoints definition. The easier way to generate it is using the designer Check the syntax of your krakend.json is good Syntax checking&amp;nbsp; $krakend&amp;nbsp;check&amp;nbsp;--config&amp;nbsp;krakend.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v1.3/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v1.4/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. When the first backend returns the information, the remaining threads are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more with the same application you are using today is not something rare.
When using concurrent requests, the backend services must be able to handle an additional load.</description></item><item><title>Concurrent Requests</title><link>https://www.krakend.io/docs/v2.0/endpoints/concurrent-requests/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/concurrent-requests/</guid><description>The concurrent requests are an excellent technique to improve the response times and decrease error rates by requesting in parallel the same information multiple times. Yes, you make the same request to several backends instead of asking to just one. When the first backend returns the information, the remaining requests are canceled.
It depends a lot on your configuration, but improving response times by a 75% or more in comparison to direct usage without the gateway is not something rare.</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/v1.3/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>Service Discovery with Eureka</title><link>https://www.krakend.io/docs/v1.4/service-discovery/eureka/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-discovery/eureka/</guid><description>Users of the Netflix&amp;rsquo;s service Eureka have a couple of user contributed integrations available listed in our krakend-contrib repository.
The integrations are not bundled with KrakenD-CE releases but they can be added to the project and make a custom build without difficulties.
schibsted/krakend-eureka: The Eureka client Schibsted has been running in production since 2017. joaoqalves/krakend-eureka: A Eureka client contributed by João Alves</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v1.3/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v1.4/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax (not the logic) with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>KrakenD file supported formats</title><link>https://www.krakend.io/docs/v2.0/configuration/supported-formats/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/supported-formats/</guid><description>The expected configuration file format by default is json, but KrakenD can parse different formats if one of the following is found:
krakend.json krakend.toml krakend.yaml krakend.yml krakend.properties krakend.props krakend.prop krakend.hcl Nevertheless, our recommendation is to choose JSON.
Validate the syntax with krakend check
Why choosing json? You are free to choose YAML, TOML or any of the other formats at your best convenience. But have in mind the following logic when choosing a file format other than json.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will start anyway.
The message you will see when the server starts with an invalid or missing license file is:
Term&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-dec&amp;nbsp;krakend.json Parsing&amp;nbsp;configuration&amp;nbsp;file:&amp;nbsp;krakend.</description></item><item><title>Managing the LICENSE file</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/license-file/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/license-file/</guid><description>To run the Enterprise software with all its capabilities you must provide a valid license. When you get a license from sales, its placement and format must comply with what the binary expects.
When the license file is incorrect, KrakenD warns you about it but the server will start anyway.
The message you will see when the server starts with an invalid or missing license file is:
Term&amp;nbsp; $krakend&amp;nbsp;run&amp;nbsp;-dec&amp;nbsp;krakend.json Parsing&amp;nbsp;configuration&amp;nbsp;file:&amp;nbsp;krakend.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>Enterprise plugins</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/plugins/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/plugins/</guid><description>A great deal of the functionality offered by KrakenD Enterprise is presented as plugins, and other as components. It&amp;rsquo;s important to understand a few concepts and particularities of plugins before you start using them.
What is a plugin? A plugin is a soft-linked library; thus, a separated binary file (.so), that when running in conjunction with KrakenD, can participate in the processing. Plugins and middlewares are close concepts, but while middlewares are part of the KrakenD binary, plugins are not.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag, or when you add the debug_endpoint=true in the configuration.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug` endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/debug-endpoint/</guid><description>The /__debug endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v1.3/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v1.4/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level .
When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>The `/__debug/` endpoint</title><link>https://www.krakend.io/docs/v2.0/endpoints/debug-endpoint/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/debug-endpoint/</guid><description>The /__debug/ endpoint is available when you start the server with the -d flag.
The endpoint can be used as a fake backend and is very useful to see the interaction between the gateway and the backends as its activity is printed in the log using the DEBUG log level. The endpoint returns this content:
{ &amp;#34;message&amp;#34;: &amp;#34;pong&amp;#34; } When developing, add KrakenD itself as another backend using the /__debug/ endpoint so you can see exactly what headers and query string parameters your backends are receiving.</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override some of its values. There are two different ways of injecting environment vars.
Replacing existing values in the configuration Setting new values when using the {{env} function in flexible configuration Value replacement with env vars You can override configuration values with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v1.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables must have the prefix KRAKEND_ and declared in uppercase. The variable name after the prefix must match the property in the configuration value.
For instance, take the following krakend.json configuration as an example:</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override existing values in the configuration. There are two different ways of injecting environment vars.
The key to override must exist in the configuration The environment variables are meant to replace existing attributes in the configuration. Therefore, you cannot set new parameters that do not exist in the configuration. First level properties You can override its value with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v1.3/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables must have the prefix KRAKEND_ and declared in uppercase. The variable name after the prefix must match the property in the configuration value.
For instance, take the following krakend.json configuration as an example:</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v1.4/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables you can inject a value in the configuration when the server starts. There are two different ways of injecting environment vars.
First level properties For each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration), you can override its value with an environment variable.
All configuration environment variables that you want to set using environment variables, pass them with a prefix KRAKEND_.</description></item><item><title>Overriding the configuration with environment vars</title><link>https://www.krakend.io/docs/v2.0/configuration/environment-vars/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/environment-vars/</guid><description>When KrakenD runs, all the behavior is loaded from the configuration file. Through environment variables, you can override existing values in the configuration. There are two different ways of injecting environment vars.
The key to override must exist in the configuration The environment variables are meant to replace existing attributes in the configuration. Therefore, you cannot set new parameters that do not exist in the configuration. First level properties You can override its value with an environment variable for each configuration value that isn&amp;rsquo;t nested (meaning first-level properties of the configuration).</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v1.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/enterprise/v2.0/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires to add two components in the configuration:
telemetry/logging to capture the logs telemetry/gelf to format the logs The configuration you need to add is this, and explained below:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/gelf&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;myGraylogInstance:12201&amp;#34;, &amp;#34;enable_tcp&amp;#34;: false }, &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: false } } } The GELF configuration parameters for telemetry/gelf are:</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v1.3/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v1.4/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Graylog and the GELF format</title><link>https://www.krakend.io/docs/v2.0/logging/graylog-gelf/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/logging/graylog-gelf/</guid><description>KrakenD supports sending structured events in GELF format to your Graylog Cluster thanks to the krakend-gelf integration.
The setup of GELF is straightforward and requires only to set two parameters:
address: The address (including the port) of your Graylog cluster (or any other service that receives GELF inputs). enable_tcp: Set to false (recommended) to use UDP. When using TCP performance might be affected. Enabling GELF Add the krakend-gelf integration in the root level of your krakend.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens:
A user wants to log out from all my devices. An administrator wants to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v1.3/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v1.4/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Revoking valid tokens with a Bloom filter</title><link>https://www.krakend.io/docs/v2.0/authorization/revoking-tokens/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/revoking-tokens/</guid><description>The API Gateway authorizes users that provide valid tokens according to your criteria, but at some point, you might want to change your mind and decide to revoke JWT tokens that are still valid.
When are you going to need this? Examples of situations where you might need to revoke perfectly legit tokens: As a user, I want to log me out of all my devices. As an administrator, I want to kick out someone from the platform.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/timeouts/</guid><description>Being KrakenD, an API Gateway that talks to other services, controlling the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Default timeout The timeout key in the krakend.json at the root level is used to apply a default timeout for those endpoints that do not specify one.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v1.3/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v1.4/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Pipe timeouts Global timeout The timeout key in the krakend.</description></item><item><title>Timeouts</title><link>https://www.krakend.io/docs/v2.0/throttling/timeouts/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/timeouts/</guid><description>Being KrakenD an API Gateway that talks to other services, being able to control the waiting times for different aspects is crucial. KrakenD will allow you to fine-tune these settings.
The timeouts can apply to:
The duration of the whole pipe (from user request to user response) The HTTP request related timeouts Additionally, you can control the number of maximum IDLE connections.
Global timeout The timeout key in the krakend.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>HTTP Security</title><link>https://www.krakend.io/docs/v2.0/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add its namespace security/http at the extra_config in the root level of the configuration.
The following configuration describes all possible options:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;security/http&amp;#34;: { &amp;#34;allowed_hosts&amp;#34;: [ &amp;#34;host.known.com:443&amp;#34; ], &amp;#34;ssl_proxy_headers&amp;#34;: { &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34; }, &amp;#34;host_proxy_headers&amp;#34;:[ &amp;#34;X-Forwarded-Hosts&amp;#34; ], &amp;#34;ssl_redirect&amp;#34;: true, &amp;#34;ssl_host&amp;#34;: &amp;#34;ssl.host.domain&amp;#34;, &amp;#34;sts_seconds&amp;#34;: 300, &amp;#34;sts_include_subdomains&amp;#34;: true, &amp;#34;frame_deny&amp;#34;: true, &amp;#34;referrer_policy&amp;#34;: &amp;#34;same-origin&amp;#34;, &amp;#34;custom_frame_options_value&amp;#34;: &amp;#34;ALLOW-FROM https://example.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/v1.3/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Security</title><link>https://www.krakend.io/docs/v1.4/service-settings/security/</link><pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/service-settings/security/</guid><description>KrakenD has implemented several security strategies, controlled via krakend-httpsecure. To enable them you only need to add the extra_config at service (root) level.
The following example describes the options explained later in this article:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-httpsecure&amp;quot;: { &amp;quot;allowed_hosts&amp;quot;: [ &amp;quot;host.known.com:443&amp;quot; ], &amp;quot;ssl_proxy_headers&amp;quot;: { &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot; }, &amp;quot;ssl_redirect&amp;quot;: true, &amp;quot;ssl_host&amp;quot;: &amp;quot;ssl.host.domain&amp;quot;, &amp;quot;ssl_port&amp;quot;: &amp;quot;443&amp;quot;, &amp;quot;ssl_certificate&amp;quot;: &amp;quot;/path/to/cert&amp;quot;, &amp;quot;ssl_private_key&amp;quot;: &amp;quot;/path/to/key&amp;quot;, &amp;quot;sts_seconds&amp;quot;: 300, &amp;quot;sts_include_subdomains&amp;quot;: true, &amp;quot;frame_deny&amp;quot;: true, &amp;quot;custom_frame_options_value&amp;quot;: &amp;quot;ALLOW-FROM https://example.com&amp;quot;, &amp;quot;hpkp_public_key&amp;quot;: &amp;quot;pin-sha256=\&amp;quot;base64==\&amp;quot;; max-age=expireTime [; includeSubDomains][; report-uri=\&amp;quot;reportURI\&amp;quot;]&amp;quot;, &amp;quot;content_type_nosniff&amp;quot;: true, &amp;quot;browser_xss_filter&amp;quot;: true, &amp;quot;content_security_policy&amp;quot;: &amp;quot;default-src 'self';&amp;quot; } See below the different options described in this configuration file.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json fast-json (Enterprise only) safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v1.3/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Supported backend encodings</title><link>https://www.krakend.io/docs/v2.0/backends/supported-encodings/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/supported-encodings/</guid><description>Setting the encoding is an important part of the backend definition, as it informs KrakenD how to parse the responses of your services.
Each backend can reply with a different encoding and KrakenD does not have any problem working with mixed encodings at the same time. You can use the following encoding in each backend section:
json safejson xml rss string no-op Notice that all values are in lower case.</description></item><item><title>Revoke Server for cluster-wide management of token revocations</title><link>https://www.krakend.io/docs/enterprise/authentication/revoke-server/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/revoke-server/</guid><description>The Revoke Server (a.k.a Revoker) is a standalone server that coordinates token revocation in a KrakenD Cluster. When you start the service, it offers a ping endpoint for all KrakenD instances to self-register and pushes token revocation instructions to all nodes in the cluster.
The Revoker passes the instructions to all instances by connecting to their bloom filter RPC port. It offers centralized management despite the size of your cluster. Using the Revoke Server, you no longer need to know how many KrakenDs are running and interact with them individually.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Validate your plugin compatibility</title><link>https://www.krakend.io/docs/v2.0/extending/check-plugin/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/check-plugin/</guid><description>The krakend check-plugin command helps you validate the compatibility of your custom plugins that will run in conjunction with KrakenD.
The command compares your plugin&amp;rsquo;s go.sum file with the libraries initially used to compile the running binary. If there are any incompatibilities between your plugin and KrakenD, it will show a detailed list.
If you integrate this command as part of your CI/CD pipeline, it will exit with a status code 0 when the libraries of your plugin are compatible with KrakenD and with a status code 1 when they are not.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v1.3/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
cache_ttl string Sets a default Cache-Control: public, max-age=%d header to all endpoints where %d is the conversion to seconds of any duration you write, indicating for how long the client (or CDN) can cache the content of the request.</description></item><item><title>Advanced HTTP Server settings</title><link>https://www.krakend.io/docs/v2.0/service-settings/http-server-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/http-server-settings/</guid><description>KrakenD starts an HTTP server to offer the API Gateway server. You can personalize some of the settings used to start the service and also override the default settings of the underlying Go standard library.
If you want to customize any of the settings below, they must be written at the top level of the configuration.
Setting parameter Type Description port integer The TCP port where KrakenD listens to.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/openapi/</guid><description>The OpenAPI generators are command-line utilities embedded in the KrakenD binary, offering OpenAPI import and export capabilities. The OpenAPI generator allows you to:
Export to OpenAPI: From an existing KrakenD configuration, you can automatically generate the API documentation in OpenAPI format. Import from OpenAPI: From an existing OpenAPI spec, you can generate the initial KrakenD configuration to start working. The OpenAPI-supported version is Swagger v2 (not OAS3) in both functionalities.</description></item><item><title>Generate documentation using OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/openapi/</guid><description>The OpenAPI or Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of API documentation through a static Swagger file.
For an OpenAPI specification with detailed fields of backend responses (an information the gateway does not have), use the OpenAPI generator in the KrakenD Studio as is capable of providing in-depth detail of backend responses in the documentation through inspection of live requests.</description></item><item><title>Import and Export OpenAPI</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/openapi/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/openapi/</guid><description>The OpenAPI generators are command-line utilities embedded in the KrakenD binary, offering OpenAPI import and export capabilities. The OpenAPI generator allows you to:
Export to OpenAPI: From an existing KrakenD configuration, you can automatically generate the API documentation in OpenAPI format. Import from OpenAPI: From an existing OpenAPI spec, you can generate the initial KrakenD configuration to start working. The OpenAPI-supported version is Swagger v2 (not OAS3) in both functionalities.</description></item><item><title>Token validation with multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by multiple Identity Providers.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. There are times when tokens arriving at an endpoint originate in different providers or different tenants. This is especially true in multi-tenant scenarios, or where there is an ongoing migration, or when different systems converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v2.0/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authentication/multiple-identity-providers/</guid><description>The JWK aggregator plugin allows KrakenD to validate tokens issued by multiple Identity Providers.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. There are times when tokens arriving at an endpoint originate in different providers or different tenants. This is especially true in multi-tenant scenarios, or where there is an ongoing migration, or when different systems converge into the gateway.</description></item><item><title>Token validation with multiple Identity Providers</title><link>https://www.krakend.io/docs/enterprise/v1.3/authentication/multiple-identity-providers/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authentication/multiple-identity-providers/</guid><description>This plugin allows KrakenD to validate tokens issued by multiple Identity Providers.
The default behavior of KrakenD allows you to validate JWT tokens using a single Identity Provider or tenant per endpoint. There are times when tokens arriving at an endpoint originate in different providers or different tenants. This is especially true in multi-tenant scenarios, or where there is an ongoing migration, or when different systems converge into the gateway. The KrakenD krakend-jwk-aggregator allows you to alleviate this issue.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA) or be added under the ca_certs list.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.509 authentication certificate. KrakenD relies on the system&amp;rsquo;s CA to validate certificates.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v1.3/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v1.4/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Securing B2B communication with mTLS</title><link>https://www.krakend.io/docs/v2.0/authorization/mutual-authentication/</link><pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/mutual-authentication/</guid><description>Mutual TLS authentication (mTLS) is an authentication mechanism used traditionally in business-to-business (B2B) applications where clients provide a certificate that allows to connect to the KrakenD server.
The certificates must be recognized by your system&amp;rsquo;s Certification Authority (CA). KrakenD relies on the machine where is running.
Configuring mutual authentication From the configuration file perspective, Mutual TLS Authentication is no more than flag at the root level of the configuration.
When mTLS is enabled, all KrakenD endpoints require clients to provide a known client-side X.</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v1.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/enterprise/v2.0/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v1.3/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v1.4/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/logging/logstash/</guid><description>If you want to log using the Logstash standard via stdout, you have to add the krakend-logstash integration in the root level of your krakend.json, inside the extra_config section. The gologging needs to be enabled too.
For instance:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-logstash&amp;quot;: { &amp;quot;enabled&amp;quot;: true } &amp;quot;github_com/devopsfaith/krakend-gologging&amp;quot;: { &amp;quot;level&amp;quot;: &amp;quot;INFO&amp;quot;, &amp;quot;prefix&amp;quot;: &amp;quot;[KRAKEND]&amp;quot;, &amp;quot;syslog&amp;quot;: false, &amp;quot;stdout&amp;quot;: true, &amp;quot;format&amp;quot;: &amp;quot;logstash&amp;quot; } }</description></item><item><title>Logstash</title><link>https://www.krakend.io/docs/v2.0/logging/logstash/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/logging/logstash/</guid><description>The Logstash integration prints KrakenD application logs in JSON format (not access logs) to ingest them and process them later. If you want to log using the Logstash standard via stdout, you need to add the telemetry/logging integration as a dependency.
Configuration The configuration you need to enable logstash is:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/logging&amp;#34;: { &amp;#34;level&amp;#34;: &amp;#34;INFO&amp;#34;, &amp;#34;prefix&amp;#34;: &amp;#34;[KRAKEND]&amp;#34;, &amp;#34;syslog&amp;#34;: false, &amp;#34;stdout&amp;#34;: true, &amp;#34;format&amp;#34;: &amp;#34;logstash&amp;#34; } } } When the format of the logging format is logstash then the output of the application log (not the access log) is printed in JSON format, as follows:</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/v1.3/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials</title><link>https://www.krakend.io/docs/v1.4/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant KrakenD can request to your authorization server an access token to reach protected resources.
The client credentials authorize KrakenD, as the client, to access the protected resources. Do not confuse this with authorizing an end-user (see JWT instead).
Successfully setting the client credentials for a backend means that KrakenD can get the protected content, but the endpoint offered to the end-user is going to be public unless you protect it with JWT.</description></item><item><title>OAuth 2.0 Client Credentials (2-legged flow)</title><link>https://www.krakend.io/docs/v2.0/authorization/client-credentials/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/client-credentials/</guid><description>Through the OAuth 2.0 Client Credentials Grant, KrakenD can do a 2-legged OAuth2 flow, which means that the gateway requests to your authorization server an access token before reaching the backend&amp;rsquo;s protected resources. The token refreshes when needed.
The client credentials authorize KrakenD, as the client, to access the protected resources.
Successfully setting the client credentials for a backend means that KrakenD can get the protected content. Still, the endpoint offered to the end-user will be public unless you protect it with JWT or another end-user authentication mechanism.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/caching/</guid><description>Caching allows you to store backend responses in memory to reduce the number of calls a user sends to the origin, reducing the network traffic and alleviating your services&amp;rsquo; pressure.
KrakenD&amp;rsquo;s caching approach is to store individual backend responses rather than aggregated content. Although it is a minor implementation detail, it is worth noticing that caching applies to traffic between KrakenD and your microservices, not between end-user and KrakenD.
The caching component is practically a flag, requiring you to mark the backends you want to cover by adding the qos/httpcache element in the backend section.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the qos/httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v1.3/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v1.4/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the httpcache middleware.</description></item><item><title>Caching backend responses</title><link>https://www.krakend.io/docs/v2.0/backends/caching/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/caching/</guid><description>Sometimes you might want to reuse a previous response of a backend instead of asking for the same information over the network again. In this cases, it is possible to enable in-memory caching for the desired backend responses.
This caching technique applies to traffic between KrakenD and your microservices endpoints only and is not a caching system for the end-user endpoints. To enable the cache, you only need to add in the configuration file the qos/httpcache middleware.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always return a response in JSON format to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v1.3/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always return a response in JSON format to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v1.4/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client.</description></item><item><title>Response content types</title><link>https://www.krakend.io/docs/v2.0/endpoints/content-types/</link><pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/content-types/</guid><description>KrakenD supports sending responses back to the client using content types other than JSON. The list of supported content types depends on the router package used.
Supported encodings The gateway can work with several content types, even allowing your clients to choose how to consume the content. The following output_encoding strategies are available to choose for every an endpoint:
json: The endpoint always returns a JSON object to the client.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Advanced HTTP Transport settings</title><link>https://www.krakend.io/docs/v2.0/service-settings/http-transport-settings/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/service-settings/http-transport-settings/</guid><description>When KrakenD communicates using http, it implements a concurrent-safe round tripper that supports HTTP, HTTPS, and HTTP proxies, and it caches connections for future re-use. This may leave many open connections when accessing many hosts. You can change the behavior of the transport layer using several settings presented below.
If you want to customize any of the settings below, they must be written at the top level of the configuration.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;2.1.1 Generates&amp;nbsp;the&amp;nbsp;Postman&amp;nbsp;descriptor&amp;nbsp;for&amp;nbsp;the&amp;nbsp;gateway&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file. Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;[flags] Examples: krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-c&amp;nbsp;config.json&amp;nbsp;-o&amp;nbsp;postman.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;postman Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug &amp;nbsp;&amp;nbsp;-o,&amp;nbsp;--out&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;generated&amp;nbsp;result.&amp;nbsp;(default&amp;nbsp;"out.json") When the output file is generated, you can import it from Postman and share it with your peers.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections. The generation of Postman collections is also available in KrakenD Studio.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;v1.3.0 Generates&amp;nbsp;the&amp;nbsp;Postman&amp;nbsp;descriptor&amp;nbsp;for&amp;nbsp;the&amp;nbsp;gateway&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file. Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;[flags] Examples: krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-c&amp;nbsp;config.json&amp;nbsp;-o&amp;nbsp;postman.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;postman Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug &amp;nbsp;&amp;nbsp;-o,&amp;nbsp;--out&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;generated&amp;nbsp;result.</description></item><item><title>Generate Postman collections</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/postman/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/postman/</guid><description>The Postman Swagger generator is a command line utility embedded in the KrakenD binary, offering the automatic generation of Postman collections based on the KrakenD configuration.
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:
Command to start KrakenD&amp;nbsp; $krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-h ╓▄█&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;▄▄▌&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╓██████▄µ ▐███&amp;nbsp;&amp;nbsp;▄███╨▐███▄██H╗██████▄&amp;nbsp;&amp;nbsp;║██▌&amp;nbsp;,▄███╨&amp;nbsp;▄██████▄&amp;nbsp;&amp;nbsp;▓██▌█████▄&amp;nbsp;&amp;nbsp;███▀╙╙▀▀███╕ ▐███▄███▀&amp;nbsp;&amp;nbsp;▐█████▀"╙▀▀"╙▀███&amp;nbsp;║███▄███┘&amp;nbsp;&amp;nbsp;███▀""▀███&amp;nbsp;████▀╙▀███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;╙███ ▐██████▌&amp;nbsp;&amp;nbsp;&amp;nbsp;▐███⌐&amp;nbsp;&amp;nbsp;,▄████████M║██████▄&amp;nbsp;&amp;nbsp;║██████████M███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,███ ▐███╨▀███µ&amp;nbsp;▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;,███M║███╙▀███&amp;nbsp;&amp;nbsp;███▄```▄▄`&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;███,,,╓▄███▀ ▐███&amp;nbsp;&amp;nbsp;╙███▄▐███&amp;nbsp;&amp;nbsp;&amp;nbsp;╙█████████M║██▌&amp;nbsp;&amp;nbsp;╙███▄`▀███████╨&amp;nbsp;███▌&amp;nbsp;&amp;nbsp;&amp;nbsp;███H&amp;nbsp;█████████▀ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;``&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'` Version:&amp;nbsp;v2.0 Generates&amp;nbsp;the&amp;nbsp;Postman&amp;nbsp;descriptor&amp;nbsp;for&amp;nbsp;the&amp;nbsp;gateway&amp;nbsp;based&amp;nbsp;on&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;file. Usage: &amp;nbsp;&amp;nbsp;krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;[flags] Examples: krakend&amp;nbsp;generate&amp;nbsp;postman&amp;nbsp;-c&amp;nbsp;config.json&amp;nbsp;-o&amp;nbsp;postman.json Flags: &amp;nbsp;&amp;nbsp;-h,&amp;nbsp;--help&amp;nbsp;&amp;nbsp;&amp;nbsp;help&amp;nbsp;for&amp;nbsp;postman Global&amp;nbsp;Flags: &amp;nbsp;&amp;nbsp;-c,&amp;nbsp;--config&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;configuration&amp;nbsp;filename &amp;nbsp;&amp;nbsp;-d,&amp;nbsp;--debug&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Enable&amp;nbsp;the&amp;nbsp;debug &amp;nbsp;&amp;nbsp;-o,&amp;nbsp;--out&amp;nbsp;string&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Path&amp;nbsp;to&amp;nbsp;the&amp;nbsp;generated&amp;nbsp;result.&amp;nbsp;(default&amp;nbsp;"out.json") When the output file is generated, you can import it from Postman and share it with your peers.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v1.3/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v1.4/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091 &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } } } Configuration The Opencensus only needs an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Sending out logs, metrics, and traces</title><link>https://www.krakend.io/docs/v2.0/telemetry/opencensus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/opencensus/</guid><description>The Opencensus exporter is a single component that allows you to export data to multiple providers, both open source and privative.
You will be interested in Opencensus when you want to see data in one of its supported exporters. For instance, you might want to send metrics to Prometheus. That would be as easy as adding this snippet in the root level of your krakend.json file:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } Configuration The Opencensus needs at least an exporter to work, although multiple exporters can be added in the same configuration.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is (some additional operations are permitted). Essentially without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is. Without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v1.3/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v1.4/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend as is, and vice-versa.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Proxying directly to the backends with `no-op`</title><link>https://www.krakend.io/docs/v2.0/endpoints/no-op/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/no-op/</guid><description>KrakenD no-op (no-operation), is a special type of encoding that behaves as a proxy by passing the client&amp;rsquo;s request to the backend and returning the response to the client as it is. Without any manipulation or operation.
Using no-op to proxy requests When setting no-op, KrakenD does not inspect the request body or manipulates it in any way. Instead, when a request to a no-op endpoint is received, KrakenD directly forwards it to the backend without doing any operation with it.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chained calls are considered an anti-pattern Making use of sequential calls is considered an anti-pattern.</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v1.3/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v1.4/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Sequential Proxy</title><link>https://www.krakend.io/docs/v2.0/endpoints/sequential-proxy/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/sequential-proxy/</guid><description>The best experience consumers can have with KrakenD API is by letting the system fetch all the data from the different backends concurrently at the same time. However, there are times when you need to delay a backend call until you can inject as input the result of a previous call.
The sequential proxy allows you to chain backend requests.
Chaining the requests All you need to enable the sequential proxy is add in the endpoint definition the following configuration:</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v1.3/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Traffic shadowing or mirroring</title><link>https://www.krakend.io/docs/v2.0/backends/shadow-backends/</link><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/shadow-backends/</guid><description>There are times when you have been working in a new version of your microservice, a complete refactor, a dangerous change, or any other valuable change that needs being careful, and it&amp;rsquo;s too risky to put it live as there might be issues that impact your end users.
The traffic shadowing or traffic mirroring functionality allows you to test new backends in production by sending them copies of the traffic but ignore their responses.</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/enterprise/v1.3/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/v1.3/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.</description></item><item><title>Maximum IDLE connections</title><link>https://www.krakend.io/docs/v1.4/throttling/max-idle-connections/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/throttling/max-idle-connections/</guid><description>Having a high number of IDLE connections to every backend affects directly to the performance of the proxy layer. This is why you can control the number using the max_idle_connections setting. For instance:
{ &amp;quot;version&amp;quot;: 2, &amp;quot;max_idle_connections&amp;quot;: 150, ... } KrakenD will close connections sitting idle in a &amp;ldquo;keep-alive&amp;rdquo; state when max_idle_connections is reached. If no value is set in the configuration file, KrakenD will use 250 by default.</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v1.3/commands/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/commands/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile to immediately render it to a png image.
The following image illustrates an example of a KrakenD configuration:
Generating the Postman collection The command needed to generate the Postman collection is krakend generate postman:</description></item><item><title>Generate graphs from your configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/config2dot/</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/config2dot/</guid><description>The krakend.json file whether it is a single file or the result of using the flexible configuration, it might be a complex file. A generated image of the configuration might help you understand better the running configuration.
The config2dot generator will generate internally an intermediate DOT dile that you can render into a png image with GraphViz or similar software.
The following image illustrates an example of a KrakenD configuration:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you push data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port on which Prometheus is running, the namespace (optional), and Prometheus will start receiving the data.
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } port on which Prometheus is listening namespace sets the domain the metric belongs to.</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data. { &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data.
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v1.3/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you push data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port on which Prometheus is running, the namespace (optional), and Prometheus will start receiving the data.
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;prometheus&amp;quot;: { &amp;quot;port&amp;quot;: 9091, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot; } } } port on which Prometheus is listening namespace sets the domain the metric belongs to.</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v1.4/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus. Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus will start receiving the data. { &amp;#34;version&amp;#34;: 2, &amp;#34;extra_config&amp;#34;: { &amp;#34;github_com/devopsfaith/krakend-opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Exporting metrics to Prometheus</title><link>https://www.krakend.io/docs/v2.0/telemetry/prometheus/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/prometheus/</guid><description>Prometheus is an open-source systems monitoring and alerting toolkit.
The Opencensus exporter allows you to expose data to Prometheus, and publishes a /metrics endpoint in the selected port.
Example: http://localhost:9091/metrics
Enabling it only requires you to include in the root level of your configuration the Opencensus middleware with the prometheus exporter. Specify the port which Prometheus should hit, the namespace (optional), and Prometheus now can pull the data. { &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;prometheus&amp;#34;: { &amp;#34;port&amp;#34;: 9091, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;tag_host&amp;#34;: false, &amp;#34;tag_path&amp;#34;: true, &amp;#34;tag_method&amp;#34;: true, &amp;#34;tag_statuscode&amp;#34;: false } } } } }</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response, although it can be used for objects as well. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response, although it can be used for objects as well. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
Looking for a Query Language manipulation? If you are an Enterprise user, you might want to use Response manipulation with query language instead When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v1.3/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v1.4/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it). While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Array manipulation - flatmap</title><link>https://www.krakend.io/docs/v2.0/backends/flatmap/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/flatmap/</guid><description>The flatmap middleware allows you to manipulate collections (or arrays, or lists, you name it) from the backend response. While the basic manipulation operations allow you to work directly with objects, the collections require a different approach: the flatmap component.
When working with lists, KrakenD needs to flatten and expand array structures to objects to operate with them, and vice versa. This process is automatically done by the flatmap component, letting you concentrate only on the type of operation you want to execute.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v1.3/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v1.4/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Static Proxy - Adding static/stub data</title><link>https://www.krakend.io/docs/v2.0/endpoints/static-proxy/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/static-proxy/</guid><description>The static proxy is an aid to clients dealing with incomplete and other types of degraded responses. When enabled, the static proxy injects static data in the final response when the behavior of a backend falls in the selected strategy.
A typical scenario is when some backend fails and the endpoint becomes incomplete, but you prefer to provide a stub response for that part instead. When your application cannot handle well the degraded response, the static data comes handy.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; }, } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v1.3/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; } } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>Exporting metrics and events to InfluxDB</title><link>https://www.krakend.io/docs/v1.4/telemetry/influxdb/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/influxdb/</guid><description>InfluxDB is a time series database designed to handle high write and query loads.
The Opencensus exporter allows you export data to InfluxDB for monitoring metrics and events. Enabling it only requires you to add the influxdb exporter in the opencensus module.
The following configuration snippet sends data to your InfluxDB:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;influxdb&amp;quot;: { &amp;quot;address&amp;quot;: &amp;quot;http://192.168.99.100:8086&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;timeout&amp;quot;: &amp;quot;1s&amp;quot;, &amp;quot;username&amp;quot;: &amp;quot;your-influxdb-user&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;your-influxdb-password&amp;quot; } } } address is the URL (including port) where your InfluxDB is installed.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/v1.3/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Checking requests and responses with the Common Expression Language (CEL)</title><link>https://www.krakend.io/docs/v1.4/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to include additional logic in the gateway to decide if a request has to be fulfilled or not.
The Common Expression Language (CEL) middleware enables Google&amp;rsquo;s CEL spec which implements common semantics for expression evaluation, and is a very simple and powerful option to have full control during requests and responses.
When the CEL component is enabled, any amount of expressions to check both requests and responses can be set.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in hitting your backend(s).
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user, but rather return an error.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in adding more traffic to your backends.
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user.</description></item><item><title>Conditional requests and responses with CEL</title><link>https://www.krakend.io/docs/v2.0/endpoints/common-expression-language-cel/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/common-expression-language-cel/</guid><description>There are times when you might want to incorporate additional logic to check if the gateway has to skip the backend call. For example, maybe the request from the user is undoubtedly wrong, and there is no point in adding more traffic to your backends.
There are other times that you might need to skip returning the response because after parsing it you realize that it is not worth showing it to the user.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/enterprise/v2.0/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Hot reloading the configuration</title><link>https://www.krakend.io/docs/v2.0/developer/hot-reload/</link><pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/developer/hot-reload/</guid><description>When you want to restart KrakenD automatically after saving or changing files inside the configuration folder, the Docker image with the tag :watch can do this automatically for you.
It works whether you use flexible configuration or a single file (krakend.json or any other supported format).
The difference between the :watch image and :latest is that the KrakenD service wraps in a reflex watcher. When it detects that the configuration has changed, it restarts the service again, applying the changes.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v1.3/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v1.4/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the request of the end-user and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out the gateway.</description></item><item><title>Modify requests and responses with Martian</title><link>https://www.krakend.io/docs/v2.0/backends/martian/</link><pubDate>Thu, 24 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/martian/</guid><description>The krakend-martian component allows you to transform requests and responses through a simple DSL definition in the configuration file. Martian works perfectly in combination with CEL verifications.
Use Martian when you want to intercept the end-user&amp;rsquo;s request and make modifications before passing the content to the backends. Also, the other way around, transform the backends response before passing it to the user.
Martian is mighty and gives you endless possibilities to control what is going in and out of the gateway.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } }</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v1.3/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v1.4/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/datadog/</guid><description>Datadog is a monitoring and security platform for developers, IT operations teams and business in the cloud.
Datadog configuration The Opencensus exporter allows you export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog:
&amp;quot;extra_config&amp;quot;: { &amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;datadog&amp;quot;: { &amp;quot;tags&amp;quot;: [ &amp;quot;gw&amp;quot; ], &amp;quot;global_tags&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;prod&amp;quot; }, &amp;quot;disable_count_per_buckets&amp;quot;: true, &amp;quot;trace_address&amp;quot;: &amp;quot;localhost:8126&amp;quot;, &amp;quot;stats_address&amp;quot;: &amp;quot;localhost:8125&amp;quot;, &amp;quot;namespace&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;service&amp;quot;: &amp;quot;gateway&amp;quot; } } } } tags (list) specifies a set of global tags to attach to each metric global_tags (object) GlobalTags holds a set of tags (key/value) that will automatically be applied to all exported spans.</description></item><item><title>Exporting traces to Datadog</title><link>https://www.krakend.io/docs/v2.0/telemetry/datadog/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/datadog/</guid><description>Datadog is a cloud monitoring and security platform for developers, IT operations teams, and businesses.
Datadog configuration The Opencensus exporter allows you to export data to Datadog. Enabling it only requires you to add the datadog exporter in the opencensus module.
The following configuration snippet sends data to your Datadog: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;datadog&amp;#34;: { &amp;#34;tags&amp;#34;: [ &amp;#34;gw&amp;#34; ], &amp;#34;global_tags&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;prod&amp;#34; }, &amp;#34;disable_count_per_buckets&amp;#34;: true, &amp;#34;trace_address&amp;#34;: &amp;#34;localhost:8126&amp;#34;, &amp;#34;stats_address&amp;#34;: &amp;#34;localhost:8125&amp;#34;, &amp;#34;namespace&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;service&amp;#34;: &amp;#34;gateway&amp;#34; } } } } }</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/v1.3/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Transformations using Lua scripting</title><link>https://www.krakend.io/docs/v1.4/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/lua/</guid><description>Scripting with Lua is an additional choice to extend your business logic, and is compatible with the rest of options such as CEL, Martian, or other Go plugins and middlewares.
If you are more familiar with Lua than Go, this module can help you solve exceptional cases that need solution using a little bit of scripting. The introduction of Lua scripts in your Gateway does not require to recompile KrakenD, but unlike Go, Lua scripts are interpreted in real-time.</description></item><item><title>Lua scripting</title><link>https://www.krakend.io/docs/v2.0/endpoints/lua/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/lua/</guid><description>Scripting with Lua allows you to extend your business logic and make transformations on requests and responses. The Lua module is compatible with the rest of components such as CEL, Martian, or other Go plugins and middlewares.
The introduction of Lua scripts in your Gateway does not require recompiling KrakenD, but unlike Go, Lua scripts are interpreted in real-time. If you are new to Lua, see Lua Documentation.
Lua vs Go Plugins A Go plugin delivers much more speed and power than a Lua script for performance-first seeking users, but requires a little bit more work as you need to compile your plugins and side-load them on KrakenD.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } }
collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v1.3/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v1.4/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;zipkin&amp;quot;: { &amp;quot;collector_url&amp;quot;: &amp;quot;http://192.168.99.100:9411/api/v2/spans&amp;quot;, &amp;quot;service_name&amp;quot;: &amp;quot;krakend&amp;quot; }, } } collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Zipkin</title><link>https://www.krakend.io/docs/v2.0/telemetry/zipkin/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/zipkin/</guid><description>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures.
The Opencensus exporter allows you export data to Zipkin. Enabling it only requires you to add the zipkin exporter in the opencensus module.
The following configuration snippet sends data to your Zipkin: { &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;zipkin&amp;#34;: { &amp;#34;collector_url&amp;#34;: &amp;#34;http://192.168.99.100:9411/api/v2/spans&amp;#34;, &amp;#34;service_name&amp;#34;: &amp;#34;krakend&amp;#34; } } } } }
collector_url is the URL (including port and path) where your Zipkin is accepting the spans service_name the service name registered in Zipkin See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/v1.3/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>API Gateway integration with AMQP messaging</title><link>https://www.krakend.io/docs/v1.4/backends/amqp/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/amqp/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces github.com/devopsfaith/krakend-amqp/consume or github.com/devopsfaith/krakend-amqp/produce.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ consumers</title><link>https://www.krakend.io/docs/v2.0/backends/amqp-consumer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/amqp-consumer/</guid><description>The AMQP component allows to send and receive messages to and from a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespaces backend/amqp/consumer or backend/amqp/producer.
To create Async agents that consume messages asynchronously and without requiring a user request, see Async Agents.
The parameters of this integration follow the AMQP specification.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>Gateway integration with RabbitMQ producers</title><link>https://www.krakend.io/docs/v2.0/backends/amqp-producer/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/amqp-producer/</guid><description>The AMQP producer component allows to send messages to a queue through the API Gateway.
The configuration of the queue is a straightforward process. To connect the endpoints to the messaging system you only need to include the extra_config key with the namespace backend/amqp/producer.
The parameters of this integration follow the AMQP specification. To understand what are the implications of a certain parameter, see the AMQP Complete Reference Guide.
KrakenD creates both the exchange and the queue for you.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/enterprise/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>ELK Stack dashboard</title><link>https://www.krakend.io/docs/logging/elk-integration/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/logging/elk-integration/</guid><description>KrakenD can push logs to external services; a good example is an integration with the ELK Stack (Elastic + Logstash + Kibana). The ELK integration allows you to have KrakenD pushing logs to your Elastic server and visualize them through a Kibana dashboard.
The Kibana dashboard lets you monitor the logging activity of the gateway and identify problems quickly. The included dashboard is a starting point that provides typical graphs and metrics, but you can extend it as per your needs and add other metrics to watch.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Stateless rate-limiting on clusters</title><link>https://www.krakend.io/docs/v2.0/throttling/cluster/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/throttling/cluster/</guid><description>The stateless rate-limiting is the recommended approach for almost all scenarios. As the API Gateway does not have any centralization, the limits apply individually to each running instance of KrakenD.
Global rate limit If you prefer not to use a stateless rate limit, the KrakenD Enterprise edition has a stateful Redis-backed rate limit where counters are shared amongst all nodes. Working in a cluster implies applying the limits taking into account the deployment size.</description></item><item><title>Service rate limit (stateless)</title><link>https://www.krakend.io/docs/enterprise/service-settings/service-rate-limit/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/service-rate-limit/</guid><description>The service rate limit feature allows you to set the maximum requests per second a user or group of users can do to KrakenD and works analogously to the endpoint rate limit. There are two different strategies to set limits that you can use, simultaneously or individually:
Service rate-limit: Defines the rate-limit that all users of your API can do together, sharing the same counter. For instance, you might want to limit the interaction from users to KrakenD to 10,000 requests/second to avoid a possible DDoS propagating to your backend services.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/wildcard/</guid><description>The krakend-wildcard plugin allows you that URLs starting with known patterns are forwarded to a common endpoint, without needing to declare all possible routes. For instance, you want to forward all traffic to /foo/* (with any nesting levels) to a specific backend.
Adding wildcard routes Let&amp;rsquo;s say you define the wildcard pattern /foo. It could match with URLs like the ones below:
/foo /foo/a?x=1 /foo/a/b/c/d /foo/* Wildcard paths are not regexp patterns, but literal matches of an URL and all its subresources.</description></item><item><title>Wildcard routes</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/wildcard/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/wildcard/</guid><description>The wildcard plugin allows you that URLs starting with known patterns forward to a common endpoint without declaring all possible routes. For instance, you want to forward all traffic to /foo/* (plus any nesting levels) to a specific backend.
Let&amp;rsquo;s say you define the wildcard pattern /foo. It will react to URLs like /foo, /foo/a?x=1, /foo/a/b/c/d, /foo/*, etc. But /foobar won&amp;rsquo;t work as /foobar is not a subresource of /foo.</description></item><item><title>Serving or using static content</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/serve-static-content/</guid><description>The krakend-static-live plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http server handler, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http client executor, the KrakenD endpoints use static content as if it were a backend.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Load static content from disk</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/serve-static-content/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/serve-static-content/</guid><description>The static-filesystem plugin allows you to fetch and serve static content in two different use cases. When the plugin is used as an http-server, the static content is for your end-users, giving them CSS, JS, images, or JSON files, to name a few examples. On the other side, when the plugin is used as an http-client, the KrakenD endpoints use static content as if it were a backend. You can use it to mock data.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } }</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v2.0/telemetry/jaeger/</link><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;jaeger&amp;#34;: { &amp;#34;endpoint&amp;#34;: &amp;#34;http://192.168.99.100:14268/api/traces&amp;#34;, &amp;#34;service_name&amp;#34;:&amp;#34;krakend&amp;#34;, &amp;#34;buffer_max_count&amp;#34;: 1000 } } } } }</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v1.3/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting traces to Jaeger</title><link>https://www.krakend.io/docs/v1.4/telemetry/jaeger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/jaeger/</guid><description>Jaeger is an open source, end-to-end distributed tracing system that allows you to monitor and troubleshoot transactions in complex distributed systems.
The Opencensus exporter allows you export data to Jaeger. Enabling it only requires you to add the jaeger exporter in the opencensus module.
The following configuration snippet sends data to your Jaeger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;jaeger&amp;quot;: { &amp;quot;endpoint&amp;quot;: &amp;quot;http://192.168.99.100:14268/api/traces&amp;quot;, &amp;quot;service_name&amp;quot;:&amp;quot;krakend&amp;quot; }, } } endpoint is the URL (including port) where your Jaeger is service_name the service name registered in Jaeger See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v1.3/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v1.4/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/pubsub/</guid><description>Since KrakenD 1.0 you can connect an endpoint to multiple publish/subscribe backends, helping you integrate with event driven architectures. For instance, a frontend client can push events to a queue using a REST interface. Or a client could consume a REST endpoint that is plugged to the last events pushed in a backend. You can even validate messages and formats as all the KrakenD available middleware can be used. The list of supported backend technologies is:</description></item><item><title>Using publisher/subscribe as backends</title><link>https://www.krakend.io/docs/v2.0/backends/pubsub/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/pubsub/</guid><description>&lt;p>You can connect an endpoint to multiple publish/subscribe backends, helping you integrate with &lt;strong>event driven architectures&lt;/strong>.&lt;/p></description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v1.3/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v1.4/overview/krakend-vs-krakend-ce/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/krakend-vs-krakend-ce/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a set of libraries. KrakenD is our open-source API Gateway ready to use KrakenD Enterprise is our commercial version, including services to businesses Lura Project The Lura Project is our original KrakenD framework that we donated to The Linux Foundation on 2021.</description></item><item><title>Lura vs. KrakenD</title><link>https://www.krakend.io/docs/v2.0/overview/lura-vs-krakend/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/lura-vs-krakend/</guid><description>If you had a quick look at our git repositories or the documentation, you might be confused at first, as there is something called the Lura Project and also KrakenD.
TL;DR; Difference between Lura, KrakenD, and Enterprise Lura is the KrakenD&amp;rsquo;s engine. Formerly known as &amp;ldquo;KrakenD framework&amp;rdquo; until we donated it to The Linux Foundation on 2021. It is not a product itself but a toolkit/set of libraries to build API gateways.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v1.3/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v1.4/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Protecting APIs using the Auth0 integration</title><link>https://www.krakend.io/docs/v2.0/authorization/auth0/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/auth0/</guid><description>Let&amp;rsquo;s start with the elephant in the room: when you face the challenge of creating a modern API that has to be scalable, secure, performant, and resilient, it might look like a daunting task.
The good news is that combining products like Auth0 and KrakenD helps you solve this exact problem with an implementation that is straightforward.
Auth0 can authenticate users and machines, and KrakenD knows your business APIs and validate them in a very efficient and convenient way.</description></item><item><title>Global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>Redis-based global rate limit (stateful)</title><link>https://www.krakend.io/docs/enterprise/throttling/global-rate-limit/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/global-rate-limit/</guid><description>The global rate limit functionality enables a Redis database store to centralize all KrakenD node counters. Instead of having each KrakenD node count its hits, the counters are global and stored in the database.
Default rate limit (stateless) vs. Global rate limit (stateful) It&amp;rsquo;s essential to understand the differences between these two antagonistic approaches, so let&amp;rsquo;s put an example.
Let&amp;rsquo;s say you have four different KrakenD nodes running in a cluster, and you want to limit a specific set of users to 100 requests per second.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (payment and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration.
Configuration for GeoIP Add the following extra_config in the root to your configuration file:
{ &amp;#34;version&amp;#34;: 2, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;:&amp;#34;.</description></item><item><title>GeoIP integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/geoip/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/geoip/</guid><description>The GeoIP integration allows you load Maxmind&amp;rsquo;s GeoIP2 City database (both commercial and free versions) and enrich all KrakenD calls to your backends with geo data.
To add GeoIP information to your backends, copy the Maxmind&amp;rsquo;s database file into the filesystem (it has to be a city DB) and specify its location in the configuration. Downloading the database requires signing up to MaxMind&amp;rsquo;s website.
Download the commercial or free GeoIP2 City</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } version (string): The version of the running application that is reporting data.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v1.3/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v1.4/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;xray&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;latest&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;eu-west-1&amp;quot;, &amp;quot;use_env&amp;quot;: false, &amp;quot;access_key_id&amp;quot;: &amp;quot;myaccesskey&amp;quot;, &amp;quot;secret_access_key&amp;quot;: &amp;quot;mysecretkey&amp;quot; }, } } version: The version of the AWS X-Ray service to use.</description></item><item><title>Exporting traces to AWS X-Ray</title><link>https://www.krakend.io/docs/v2.0/telemetry/xray/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/xray/</guid><description>AWS X-Ray is a service offered by Amazon that provides an end-to-end view of requests as they travel through your application, and shows a map of your application’s underlying components.
The Opencensus exporter allows you export data to AWS X-Ray. Enabling it only requires you to add the xray exporter in the opencensus module.
The following configuration snippet sends data to your X-Ray:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;xray&amp;#34;: { &amp;#34;version&amp;#34;: &amp;#34;latest&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;eu-west-1&amp;#34;, &amp;#34;use_env&amp;#34;: false, &amp;#34;access_key_id&amp;#34;: &amp;#34;myaccesskey&amp;#34;, &amp;#34;secret_access_key&amp;#34;: &amp;#34;mysecretkey&amp;#34; } } } } } version (string): The version of the running application that is reporting data.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v1.3/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v1.4/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the parameters of the request. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>Integration with AWS Lambda functions</title><link>https://www.krakend.io/docs/v2.0/backends/lambda/</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/lambda/</guid><description>The Lambda integration allows you to invoke Amazon Lambda functions on a KrakenD endpoint call. The content returned by the lambda function can be treated and manipulated as any other backend.
The payload that is sent to the Lambda function comes from the request and depends on the method used by the endpoint:
Method GET: The payload contains all the request parameters. Non-GET methods: The payload is defined by the content of the body in the request.</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Enterprise Playground</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/playground/</guid><description>The KrakenD Enterprise Playground is a Docker Compose demonstration environment that puts together the necessary pieces to get you started with our API Gateway, using example use-cases.
As KrakenD is an API gateway, we have added surrounding services:
Internal and third-party services that feed the gateway Authentication/authorization examples, including JWT token-based authentication with Auth0 integration, a JWT token revoker, API-Key-based authentication, and basic authentication. Static assets to test the by KrakenD Static Server based on disk content Integrations with Grafana+Influx (metrics), ELK (log storing and visualization), and Jaeger (tracing).</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v1.3/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v1.4/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>The KrakenD Playground</title><link>https://www.krakend.io/docs/v2.0/overview/playground/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/playground/</guid><description>If you are new to KrakenD, a quick way to get started is to make use of the KrakenD Playground.
The KrakenD Playground is a Docker Compose environment that puts together the necessary pieces to let you play with KrakenD in a working environment.
As KrakenD is an API gateway, we have also added to the environment an API (backend) to feed the gateway and a website to make use of the data.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/enterprise/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/enterprise/v2.0/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/v1.4/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Protecting APIs using Keycloak</title><link>https://www.krakend.io/docs/v2.0/authorization/keycloak/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/authorization/keycloak/</guid><description>The Keycloak integration allows one of the many possible OpenID Connect different security options available in KrakenD.
Keycloak is an Open Source Identity and Access Management project, sponsored by RedHat. The KrakenD configuration for Keycloak relies internally on the JWT validation component.
Keycloak integration JSON web tokens (JWT) are an open standard (RFC 7519) that define a way for securely transmitting information between parties. JWT tokens are compact, secure (digitally signed), and have become an industry-standard used at internet scale.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the no-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like a 301 with the following configuration, highlighting relevant sections:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;: &amp;#34;.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the krakend-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like 301 with the following configuration in your backend section:
{ &amp;#34;endpoint&amp;#34;: &amp;#34;/redirect&amp;#34;, &amp;#34;output_encoding&amp;#34;: &amp;#34;no-op&amp;#34;, &amp;#34;backend&amp;#34;: [ { &amp;#34;url_pattern&amp;#34;: &amp;#34;/__debug&amp;#34;, &amp;#34;encoding&amp;#34;: &amp;#34;no-op&amp;#34;, &amp;#34;extra_config&amp;#34;: { &amp;#34;github.</description></item><item><title>Client redirects</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/client-redirect/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/client-redirect/</guid><description>When a backend returns a redirect, the default behaviour of KrakenD is to follow the redirection and serve the final content to the user. When this behaviour needs to be prevented and let the end-client follow the redirect itself, then you need to enable the no-redirect plugin.
Client redirect configuration You can stop KrakenD from following redirections like a 301 with the following configuration, highlighting relevant sections:
{ &amp;#34;version&amp;#34;: 3, &amp;#34;plugin&amp;#34;: { &amp;#34;pattern&amp;#34;: &amp;#34;.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>URL Rewrite</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/url-rewrite/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/url-rewrite/</guid><description>The url-rewrite plugin allows you to define a set of URLs or regular expressions that are handled by an endpoint of your choice. In other words, this plugin allows you to declare additional URLs other than the ones defined under the endpoints configuration, used as aliases of existing endpoints.
Extendind router capabilities This plugin allows you to overcome some of the routing capabilities of KrakenD, such as declaring endpoints that would be conflicting or unaccepted by the KrakenD core.</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/enterprise/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics and traces to Google Cloud's operations suite</title><link>https://www.krakend.io/docs/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/stackdriver/</guid><description>Google Cloud&amp;rsquo;s operation suite (formerly Stackdriver) aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you to export metrics and traces to Google Cloud. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;sample_rate&amp;#34;: 100, &amp;#34;reporting_period&amp;#34;: 60, &amp;#34;enabled_layers&amp;#34;: { &amp;#34;backend&amp;#34;: true, &amp;#34;router&amp;#34;: true, &amp;#34;pipe&amp;#34;: true }, &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metric_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metrics_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v1.3/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v1.4/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;stackdriver&amp;quot;: { &amp;quot;project_id&amp;quot;: &amp;quot;my-krakend-project&amp;quot;, &amp;quot;metrics_prefix&amp;quot;: &amp;quot;krakend&amp;quot;, &amp;quot;default_labels&amp;quot;: { &amp;quot;env&amp;quot;: &amp;quot;production&amp;quot; } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Exporting metrics, logs and events to Google Stackdriver</title><link>https://www.krakend.io/docs/v2.0/telemetry/stackdriver/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/stackdriver/</guid><description>Google Stackdriver aggregates metrics, logs, and events from infrastructure, giving developers and operators a rich set of observable signals that speed root-cause analysis and reduce mean time to resolution (MTTR).
The Opencensus exporter allows you export data to Google Stackdriver. Enabling it only requires you to add the stackdriver exporter in the opencensus module.
The following configuration snippet sends the data:
{ &amp;#34;extra_config&amp;#34;: { &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;stackdriver&amp;#34;: { &amp;#34;project_id&amp;#34;: &amp;#34;my-krakend-project&amp;#34;, &amp;#34;metrics_prefix&amp;#34;: &amp;#34;krakend&amp;#34;, &amp;#34;default_labels&amp;#34;: { &amp;#34;env&amp;#34;: &amp;#34;production&amp;#34; } } } } } } project_id: The identifier of your Google Cloud project.</description></item><item><title>Validating the responses with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/response-schema-validator/</guid><description>The response schema validator plugin adds a schema validation before the gateway returns the response to the end-user or before it&amp;rsquo;s merged in the endpoint with the rest of the backends.
Before returning the response, you can define the minimum response fields and their characteristics through JSON schema syntax (drafts 04, 06, and 07 supported).
To validate requests using JSON schema see validation/json-schema instead.
You can use this plugin in conjunction with other components and perform validations, and you can insert it either in the endpoint section or the backend section.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. To enable it add the ocagent exporter.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. To enable it add the ocagent exporter.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v1.3/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v1.4/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Exporting metrics, logs and events to Azure Monitor</title><link>https://www.krakend.io/docs/v2.0/telemetry/azure/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/azure/</guid><description>Azure Monitor collect, analyzes, and acts on telemetry data from your Azure and on-premises environments. Azure Monitor helps you maximize performance and availability of your applications and proactively identify problems in seconds.
The Opencensus exporter allows you export data to Azure Monitor. Enabling it only requires you to add the ocagent exporter in the opencensus module, see how to configure the OpenCensus Agent.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the requests with JSON Schema</title><link>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v1.3/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v1.4/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Validating the body with the JSON Schema integration</title><link>https://www.krakend.io/docs/v2.0/endpoints/json-schema/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/endpoints/json-schema/</guid><description>KrakenD endpoints receiving a JSON object in its body can apply automatic validations using the JSON Schema vocabulary before the content passes to the backends. The json schema component allows you to define validation rules on the body, type definition, or even validate the fields&amp;rsquo; values.
When the validation fails, KrakenD returns to the user a status code 400 (Bad Request), and only if it succeeds, the backend receives the request.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/enterprise/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/enterprise/v1.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v1.3/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>Returning the details of backend errors</title><link>https://www.krakend.io/docs/v2.0/backends/detailed-errors/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/detailed-errors/</guid><description>When you are willing to manipulate or aggregate data, KrakenD&amp;rsquo;s policy regarding errors and status codes is to hide from the client any backend details. The philosophy behind this is that clients have to be decoupled from its underlying services.
If in the other hand, your endpoint connects to a single backend with no manipulation, use the no-op encoding which returns the response to the client as is, preserving its form: body, headers, status codes and such.</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>IP based access</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/ipfilter/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/ipfilter/</guid><description>The ip-filter plugin allows you to restrict the traffic to a specific or all endpoints based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
See its configuration here</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/endpoints/openapi/</guid><description>The OpenAPI or Swagger documentation is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command (see Exporting to OpenAPI).
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user, it is common to all endpoints.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/openapi/</guid><description>The OpenAPI or Swagger generator is a component provided by the KrakenD Studio, offering the automatic generation of API documentation through a static Swagger file. Even KrakenD is the gateway and lacks all the knowledge of your API backends, KrakenD Studio is capable of providing in-depth detail of backend responses in the documentation documentation:inspection of live requests.
Generating the OpenAPI spec When you run the KrakenD configuration through KrakenD Studio you can enable the Swagger generation from the UI, or by adding the configuration snippet in your krakend.</description></item><item><title>OpenAPI/Swagger Generation</title><link>https://www.krakend.io/docs/enterprise/v2.0/endpoints/openapi/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/endpoints/openapi/</guid><description>The OpenAPI or Swagger documentation is automatically generated by the KrakenD Enterprise binary when you use the krakend generate openapi command.
OpenAPI configuration The OpenAPI documentation configuration has two different placements that you can use:
service level: Defines the general business information and metadata that provides context about your company and how to get in touch with you as an end-user. endpoint level: Defines the documentation for a specific endpoint.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v1.3/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v1.4/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>Exporting metrics, logs, and events to the OpenCensus Agent</title><link>https://www.krakend.io/docs/v2.0/telemetry/ocagent/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/ocagent/</guid><description>The ocagent exporter sends OpenCensus Stats and Traces to the OpenCensus Agent, instead of pushing data to backends’ exporters.
For instance, you can enable ocagent to upload data to the OpenCensus Agent, and from there, the agent is simply scraped by a Prometheus.
You can integrate the OpenCensus Agent with Azure Monitor, Jaeger, or Prometheus to name a few examples.
Enabling it only requires you to add the ocagent exporter in the opencensus module.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>IP Filtering</title><link>https://www.krakend.io/docs/enterprise/v2.0/throttling/ipfilter/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/throttling/ipfilter/</guid><description>The IP filtering plugin allows you to restrict the traffic to your API gateway based on the IP address. It works in two different modes (allow or deny) where you define the list of IPs (CIDR blocks) that are authorized to use the API, or that are denied from using the API.
The filtering applies globally to all endpoints, or to only specific endpoints depending on the placement of the configuration.</description></item><item><title>Handling WebSockets connections</title><link>https://www.krakend.io/docs/enterprise/v1.3/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end-client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/v2.0/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>WebSockets</title><link>https://www.krakend.io/docs/enterprise/websockets/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/websockets/</guid><description>KrakenD Enterprise supports communications using the WebSocket Protocol (RFC-6455) to enable two-way communication between a client to a backend host through the API gateway. This technology aims to provide a mechanism for browser-based applications that need two-way communication with servers that do not rely on opening multiple HTTP connections.
KrakenD has the capability of multiplexing. Each individual end client (e.g., Desktop, Mobile device) establishes a connection with the gateway directly, and KrakenD opens a single channel with the backend host to handle all its connected clients.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>GraphQL gateway</title><link>https://www.krakend.io/docs/v2.0/backends/graphql/</link><pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/backends/graphql/</guid><description>The GraphQL integration allows you to work in two different modes:
Apply gateway functionality in the middle of a GraphQL client and its GraphQL servers (just proxy) Convert REST endpoints to GraphQL calls (adapter/transformer). KrakenD offers a simple yet powerful way of consuming GraphQL content from your distributed graphs. The main benefits of using KrakenD as a GraphQL Gateway are:
Simple GraphQL Federation: chop your monolithic GraphQL server into different services and aggregate them in the gateway.</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>API Dashboard with Instana</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/instana/</link><pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/instana/</guid><description>Instana is a fully automated Application Performance Management (APM) solution designed specifically for the challenges of managing microservice and cloud-native applications.
With Instana you:
Gain instant visibility with zero effort Quickly make sense of chaotic modern environments Identify and solve performance issues in seconds Instana configuration The Instana exporter allows you export data to Instana. Enabling it only requires you to add the instana namespace with a few seetings as follows:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/enterprise/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>Exporting to the logger with OpenCensus</title><link>https://www.krakend.io/docs/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter. This is not the standard KrakenD Logging, and you should not enable both.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
{ &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } } As with all OpenCensus exporters, you can add optional settings in the telemetry/opencensus level:</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:</description></item><item><title>New Relic integration</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/newrelic/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/newrelic/</guid><description>The New Relic integration lets you push KrakenD metrics and distributed traces to your New Relic dashboard. It uses internally the official New Relic SDK and brings its features to your APM dashboard.
Examples of the data you can see on New Relic:
New Relic configuration To add KrakenD telemetry reporting to New Relic, you only need add the following configuration with your API Key:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration On KrakenD EE the virtual host plugin usually lives inside the /plugins folder.</description></item><item><title>Virtual Hosts</title><link>https://www.krakend.io/docs/enterprise/v2.0/service-settings/virtual-hosts/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/service-settings/virtual-hosts/</guid><description>The Virtual Host plugin allows you to run different configurations of KrakenD endpoints based on the host accessing the server.
For instance, you can declare an endpoint /foo that behaves entirely differently when KrakenD is accessed through a host-a.tld or a host-b.tld. For instance, the same /foo path can have different rate limits or authorization endpoints depending on the called host.
Virtual host configuration To add virtual hosts add the plugin entry that registers Enterprise plugins and the plugin/http-server with the name virtualhost, as depicted below:</description></item><item><title>HTTP Logger: Dump backend requests and responses</title><link>https://www.krakend.io/docs/enterprise/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>HTTP Logger: Dump backend requests and responses</title><link>https://www.krakend.io/docs/enterprise/v2.0/backends/http-logger/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/backends/http-logger/</guid><description>The HTTP logger is a response dumper that allows you to write the backend request and its response into a file, to help you debug your processes during development.
A development tool Although it works, we discourage you from using this plugin in production for the following reasons:
Performance: The throughput of the filesystem is usually slower than the network. This plugin writes two files on the disk for each request (consuming your disk space and I/O).</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v1.3/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v1.4/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @Microsoft) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Tutorials and Guides</title><link>https://www.krakend.io/docs/v2.0/overview/guides/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/guides/</guid><description>The documentation in this site covers all the functionality of KrakenD API Gateway, but over time we have received from KrakenD users all kinds of tutorials, guides and other resources that illustrate how to do a specific thing. We have included below a few links, but you can share yours.
User-contributed resources Getting started with KrakenD on Kubernetes / AKS by Christian Dennig (Cloud Solution Architect @ Microsoft) Build and Deploy with Kubernetes, Helm, and Skaffold by Fabijan Bajo (Technical Lead, DevOps / Cloud Infrastructure @ IBM) Microservices with Micronaut, KrakenD and Consul by Piotr Minkowski (Solution Architect @ Red Hat) How to Successfully Set Up KrakenD on GKE: A Step by Step Guide by Vijay Savanth on Hackernoon Writing Plugins using Golang by Ilya Nemtsev on Eventslooped Building Micro Services with .</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/enterprise/v1.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } }
stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v1.3/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v1.4/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger:
&amp;quot;github_com/devopsfaith/krakend-opencensus&amp;quot;: { &amp;quot;exporters&amp;quot;: { &amp;quot;logger&amp;quot;: { &amp;quot;stats&amp;quot;: true, &amp;quot;spans&amp;quot;: true } } } stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Exporting to the logger</title><link>https://www.krakend.io/docs/v2.0/telemetry/logger/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/logger/</guid><description>Opencensus can export data to the system logger as another exporter.
Enabling it only requires you to add the logger exporter in the opencensus module.
The following configuration snippet enables the logger: { &amp;#34;extra_config&amp;#34;:{ &amp;#34;telemetry/opencensus&amp;#34;: { &amp;#34;exporters&amp;#34;: { &amp;#34;logger&amp;#34;: { &amp;#34;stats&amp;#34;: true, &amp;#34;spans&amp;#34;: true } } } }
stats: Whether to log the statistics or not spans: Whether to log the spans or not See also the additional settings of the Opencensus module that can be declared.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/enterprise/v2.0/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Extended metrics</title><link>https://www.krakend.io/docs/v2.0/telemetry/extended-metrics/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/telemetry/extended-metrics/</guid><description>Collect extended metrics to push them to InfluxDB or expose them in the /__stats/ endpoint. The /__stats/ endpoint runs in a different port and contains a lot of metrics. This component is the richest in terms of metric data that you can use.
Through the extended metrics you can create new tools or integrate with existing ones. For instance, combining the metrics with the InfluxDB extended metrics you can have a Grafana dashboard.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/enterprise/v2.0/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.</description></item><item><title>Migrating config from KrakenD 1.x or 0.x</title><link>https://www.krakend.io/docs/v2.0/configuration/migrating/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/configuration/migrating/</guid><description>The KrakenD 2.0 release is a major version that simplifies the configuration of v1.x and standardizes field names that were using different criteria to declare the attributes.
This migration allows you to:
Migrate from KrakenD 0.x to 2.x Migrate from KrakenD 1.0 to 2.x Migrate from KrakenD 1.2 to 2.x Migrate from KrakenD 1.3 to 2.x Migrate from KrakenD 1.4 to 2.x Download migration tool Migrating to KrakenD 2.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat&amp;nbsp;krakend.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/v1.3/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat&amp;nbsp;krakend.</description></item><item><title>The health endpoint</title><link>https://www.krakend.io/docs/v1.4/endpoints/health/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/endpoints/health/</guid><description>If you place a balancer in front of KrakenD, such as an ELB, you can check KrakenD health using a TCP port check. If, on the other hand, you need an HTTP endpoint in systems like Kubernetes, use the internal endpoint /__health.
The /__health endpoint The health endpoint, or the ping endpoint, works without any specific configuration as KrakenD automatically adds it.
For instance, see the simplest possible krakend.json:
Simplest configuration file&amp;nbsp; $cat&amp;nbsp;krakend.</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/enterprise/v2.0/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, you should spend a few minutes understanding the big pieces of the system, how they work, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very, very important) Failing fast is better than succeeding slow The simpler, the better Everything is pluggable Each request must be processed in its request-scoped context KrakenD internal states When you start KrakenD, the system goes through two different internal states: building and working.</description></item><item><title>Extending KrakenD, the big picture.</title><link>https://www.krakend.io/docs/v2.0/extending/the-big-picture/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/extending/the-big-picture/</guid><description>Before starting to dive into the KrakenD code, you should spend a few minutes understanding the big pieces of the system, how they work, and the philosophy behind it.
The KrakenD rules Let&amp;rsquo;s start with the rules followed to code KrakenD (shared with The Lura Project), as they answer to architectural design questions:
Reactive is key Reactive is key (yes, it is very, very important) Failing fast is better than succeeding slow The simpler, the better Everything is pluggable Each request must be processed in its request-scoped context KrakenD internal states When you start KrakenD, the system goes through two different internal states: building and working.</description></item><item><title>KrakenD 2.1.1 EE (patch version) released</title><link>https://www.krakend.io/blog/krakend-ee-2.1.1-release-notes/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.1.1-release-notes/</guid><description>The new KrakenD Enterprise version 2.1.1 is already available for install or upgrade. This patch version does not bring new API Gateway functionality but adds support for ARM64 and other improvements.
What&amp;rsquo;s changed in EE v2.1.1 vs EE 2.1.0 This version includes the following changes:
New flag --log (or -l) on the krakend e2e to define where the output of the integration tests are saved. Architectures: Now officially supporting ARM64 architectures, releasing new Docker containers and packages.</description></item><item><title>KrakenD 2.1.3 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.3-release-notes/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.3-release-notes/</guid><description>The new KrakenD version 2.1.3 is now available. This patch version does not bring new API Gateway functionality but adds support for ARM64 and other improvements.
What&amp;rsquo;s changed in v2.1.3 vs 2.1.2 This version includes the following changes:
Architectures: Now officially supporting ARM64 architectures, releasing new Docker containers and packages. A new flag, hide_version_header, placed in the router settings, allows obfuscating the X-Krakend-Version header. Performance improvement on Lambda usage Bugfix: Return a 400 status code when the body is empty or a malformed JSON (thanks to @efcasado Bugfix: Reject requests with special chars in the params (@Lura)</description></item><item><title>KrakenD Enterprise 2.1 released</title><link>https://www.krakend.io/blog/krakend-ee-2.1-release-notes/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD Enterprise 2.1, already available for install or upgrade.
KrakenD EE 2.1 brings a lot of new functionality, including advanced manipulation with a JSON Query language, a Revoke Server to manage tokens in clusters, new Kibana and Grafana dashboards, faster encoding, a rewritten and richer NewRelic exporter, Websockets balancing, and much more. Apologies because we have added so much that the summary is not going to be short this time :)</description></item><item><title>KrakenD becomes a CNA (CVE Numbering Authority)</title><link>https://www.krakend.io/blog/krakend-becomes-a-cna/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-becomes-a-cna/</guid><description>The Spanish National Cybersecurity Institute (INCIBE) announces today the addition of KrakenD as a CNA (CVE Numbering Authority). KrakenD assumes as its own, from this date, the best practices of this program.
KrakenD is now authorized by the CVE Program to assign CVE identifiers within its scope and its corresponding publication in the CNA section. Information technology and cybersecurity professionals use CVE Records to ensure they are discussing the same issue, and to coordinate their efforts to prioritize and address the vulnerabilities.</description></item><item><title>KrakenD 2.1.2 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.2-release-notes/</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.2-release-notes/</guid><description>A new patch version KrakenD 2.1.2 is available to download page. This release fixes a bug while parsing placeholders in endpoint.
What&amp;rsquo;s changed in v2.1.2 vs 2.1.1 This patch version includes the following changes:
Bugfix: Some requests sent to backend don&amp;rsquo;t have the parameters replaced from the client URL</description></item><item><title>KrakenD 2.1.1 (patch version) released</title><link>https://www.krakend.io/blog/krakend-2.1.1-release-notes/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1.1-release-notes/</guid><description>A new patch version KrakenD 2.1.1 is available to download page. In addition to the patch, we have created a new plugin-builder Docker image for those who compile custom plugins.
What&amp;rsquo;s changed in v2.1.1 vs 2.1.0 This patch version includes the following changes:
Bot detector: Avoid aborting with an error by @taik0 (changelog) krakend check: Configs should be able to have 0 endpoints. by @taik0 (changelog) Influx: Logs normalized by @kpacha (changelog) Json Schema: validate schema definitions and reuse schema by @moritzploss (changelog) JOSE: Add cacheDuration by @mguay22 JOSE: use a sempahore to orchestrate the concurrent warm up of the JWK caches by @kpacha (changelog) Lambda: AWS SDK version update by @boris154 (changelog) Lua: deps updated so error messages can contain the : char by @kpacha (changelog) Martian: Replace the header.</description></item><item><title>KrakenD 2.1 released!</title><link>https://www.krakend.io/blog/krakend-2.1-release-notes/</link><pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 2.1. You can get it packaged from the download page.
KrakenD 2.1 brings a new ready-to-use Kibana dashboard, an updated Grafana Dashboard for InfluxDB v2 and more features and bugfixes described below:
New features:
Added a krakend version command that outputs the KrakenD, Go, and Glibc versions. Added allow_insecure_connections flag to ease development stages that use self-signed certificates. Easier logging to disk or remote server logging via the configurable syslog facility Customizable response body for 404 and 405 errors Added context propagation between Handler plugins and KrakenD Client plugins (router gin 1.</description></item><item><title>Case Study - Child Rescue Coalition</title><link>https://www.krakend.io/case-study/child-rescue-coalition/</link><pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/child-rescue-coalition/</guid><description>The technology CRC develops is designed to monitor areas of the internet not owned by a corporate entity but primarily driven by computers that are connected to a network. Since there is no corporate ownership of this technology, there is no consistent or easy way to report abuse. CRC has trained more than 12,000 investigators across 98 countries on their technology which has led to the arrest of 14,000 individuals and the rescue of more than 3,200 children.</description></item><item><title>KrakenD partners with Child Rescue Coalition</title><link>https://www.krakend.io/blog/krakend-child-rescue-coalition-partnership/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-child-rescue-coalition-partnership/</guid><description>Barcelona, September 19th 2022.- KrakenD announces today the partnership with Child Rescue Coalition. Child Rescue Coalition (CRC) is a nonprofit organization whose mission is to rescue children from sexual abuse by building technology for law enforcement to track, arrest and prosecute child predators. KrakenD has donated an unlimited commercial license (KrakenD Enterprise) to CRC to help them build and scale their APIs-oriented technological platform.
CRC has contributed to rescuing more than 3,200 children from sexual exploitation and abuse.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>KrakenD Execution Flow</title><link>https://www.krakend.io/docs/enterprise/design/execution-flow/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/design/execution-flow/</guid><description>To truly master KrakenD, you should get familiar with the concept of &amp;ldquo;pipes&amp;rdquo; and how these pipes define the execution flow of KrakenD from request to response.
A recurring question we hear from developers: Is the configuration X executed before the configuration Y?. If you are unfamiliar with KrakenD, it&amp;rsquo;s hard to tell, as the declaration order does not matter (with a few sequential exceptions). Instead, each piece acts in a specific part(s) of the request and response journey.</description></item><item><title>IBM proposes KrakenD as an alternative to their IBM Cloud API Gateway</title><link>https://www.krakend.io/blog/krakend-alternative-ibm-api-cloud/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-alternative-ibm-api-cloud/</guid><description>The IBM Cloud API Gateway service provided traffic limiting, splitting, and authentication for Cloud Functions and Cloud Foundry users. Unfortunately, IBM&amp;rsquo;s API Gateway service was deprecated and shut down on August 31st, 2022. Existing endpoints will no longer route to their respective functions or apps.
A blog post by IBM Cloud published on June 8th provided some tips and recommendations for IBM Cloud API Gateway users. For those users who still require an API Gateway as part of their platform architecture, KrakenD has been suggested as an alternative.</description></item><item><title>CVE-2022-1561: Crafted backend urls</title><link>https://www.krakend.io/blog/cve-2022-1561-crafted-backend-urls/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/cve-2022-1561-crafted-backend-urls/</guid><description>&lt;p>There is a new vulnerability in the &lt;a href="https://luraproject.org/">Lura Project&lt;/a> software (which is the KrakenD&amp;rsquo;s engine). We have immediately corrected the problem in the subsequent release after its report. Please upgrade to the latest version.&lt;/p></description></item><item><title>Security Policy</title><link>https://www.krakend.io/security-policy/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/security-policy/</guid><description>KrakenD takes cybersecurity seriously.
We craft our software without taking shortcuts, making it solid and reliable and free of practices that might introduce future security problems.
This document describes our security policy and how you can help us make a better software if you find problems.
KrakenD is a CVE Numbering Authority (CNA) How do we apply fixes How to report a vulnerability Credits and rewards KrakenD is a CVE Numbering Authority (CNA) KrakenD is a recognized CVE Numbering Authority (CNA) worldwide for software distribution and open-source projects, you can find us in the Partners List.</description></item><item><title>Case study - Rappi</title><link>https://www.krakend.io/case-study/rappi/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/rappi/</guid><description>Rappi is an application that helps users with their everyday shopping needs. From restaurants, supermarkets, pharmacies, spirits, travel, delivery, fintech products, and more.
Scenario At the technical level, Rappi is a large e-commerce platform and one of the top 100 AWS resource consumers worldwide, running over 7000 EC2 servers and over 1800 nodes on EKS.
Their stack runs on Amazon on a dual combination of ECS and Kubernetes. +750 developers of all sorts are allowed to choose their coding language, and the Infra team (Cloud Engineering - 70 people) provides the necessary tools to make it a reality.</description></item><item><title>Case study - Pretty Technical</title><link>https://www.krakend.io/case-study/pretty-technical/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/pretty-technical/</guid><description>Pretty Technical has specialists providing consultancy and services for the finance and gaming industries.
Pretty Technical has a focus on simplicity and automation, and at the same time, they develop their business tools using microservices, separating concerns. Yet, all the applications need to combine all these services, which is where KrakenD fits like a glove.
Results, Return on Investment and Future Plans After researching the best tool for the job, Pretty Technical adopted KrakenD in the early stages of development in 2021.</description></item><item><title>KrakenD Enterprise 2.0 released!</title><link>https://www.krakend.io/blog/krakend-ee-2.0-release-notes/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-2.0-release-notes/</guid><description>The KrakenD team is pleased to announce KrakenD Enterprise 2.0, already available for install or upgrade today.
KrakenD 2.0 is the awaited new major version of KrakenD bringing a lot of improvements to the API Gateway, including all the features and improvements of open source releases between v1.4 and v2.0.4.
KrakenD Enterprise adds API Analytics, IP Filtering, GraphQL, OpenAPI importers and exporters, integration tests, specific request/modifier plugins, Async Agents, backend response logging (dumper) and improves the existing WebSockets, API Keys, configuration syntax, New Relic reporting, logging, and router to put a few examples.</description></item><item><title>KrakenD API Gateway Now Available in the Microsoft Azure Marketplace</title><link>https://www.krakend.io/blog/krakend-partners-with-microsoft/</link><pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-partners-with-microsoft/</guid><description>BARCELONA, Spain — April 7, 2022
KrakenD today announced the availability of KrakenD API Gateway in the Microsoft Azure Marketplace, an online store providing applications and services for use on Microsoft Azure. KrakenD customers can now take advantage of the scalability, high availability, and security of Azure, with streamlined deployment and management.
The KrakenD API Gateway serves as a unified interface for managing incoming API requests and connecting to the correct destination, while supporting functionalities across security, authorization, traffic management, observability, and load balancing, among other services.</description></item><item><title>KrakenD 2.0 released!</title><link>https://www.krakend.io/blog/krakend-2.0-release-notes/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-2.0-release-notes/</guid><description>The KrakenD team is pleased to announce the major release KrakenD 2.0. You can get it packaged from the download page.
KrakenD 2.0 is the new major version of KrakenD bringing a lot of improvements to the API Gateway. GraphQL, specific request/modifier plugins, async agents, easier configuration, better logging, and a more flexible router to put a few examples.
Migration guide If you are an existing KrakenD user read &amp;ldquo;Migrating from KrakenD 1.</description></item><item><title>KrakenD unnaffected by Log4j</title><link>https://www.krakend.io/blog/log4j-vulnerability/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/log4j-vulnerability/</guid><description>The year 2021 ended with terrible news for Java developers who saw how the Log4J vulnerabilities exposed their systems.
KrakenD is a Go application and not a Java application. Therefore, it is not affected by this vulnerability in any way. As a result, we didn&amp;rsquo;t want to add more noise to the chain of emails you could have probably received.
Nevertheless, during the past month, we had questions from customers who have Java systems behind KrakenD that could be vulnerable and other users that weren&amp;rsquo;t sure if KrakenD was impacted or not.</description></item><item><title>Case study - Afosto</title><link>https://www.krakend.io/case-study/afosto/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/afosto/</guid><description>Afosto is one of the main software (SaaS) solutions empowering omnichannel commerce for retailers in The Netherlands. Our software empowers over 150 store owners with selling on- and offline. Two years ago we started the transition towards an API-first development paradigm, currently powered by over 90 cloud-native microservices. KrakenD has enabled us to make this shift naturally.
Challenges KrakenD helps solve Commerce is always challenging. We have to deal with sudden spikes in traffic, payments, ever-changing regulations, and large amounts of data for analytics.</description></item><item><title>Traffic mirroring: test your APIs automatically, without writing tests</title><link>https://www.krakend.io/blog/krakend-shadow-testing/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-shadow-testing/</guid><description>Integration and load testing are in the list of best practices in our sector, but synthesizing good inputs for such tests and analyzing the results are usually two hard things to achieve. This post will show you how we suggest our customers set up a shadow testing system with minimal impact on the production environment and proper harness.
Quick overview As pointed out at https://cloud.google.com/architecture/application-deployment-and-testing-strategies
Testing new backend features by using the production load.</description></item><item><title>Case study - 4data</title><link>https://www.krakend.io/case-study/4data/</link><pubDate>Sat, 19 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/4data/</guid><description>4data provides tailored cloud services to solve specific problems without mandating customers to increase their local infrastructure footprint. All these services can be managed remotely via our management application running in the browser only and communicating via REST APIs. This is where KrakenD joins the game to protect our backend REST API endpoints, both internal and external.
The main challenge was to protect endpoints from unauthenticated access. Wherever required, KrakenD applies JWT validation to ensure only authenticated requests are reaching the backend services.</description></item><item><title>KrakenD Now Available on Auth0 Marketplace</title><link>https://www.krakend.io/blog/krakend-auth0-announcement/</link><pubDate>Tue, 15 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-auth0-announcement/</guid><description>Barcelona – 15th June 2020 – KrakenD today announced the availability of its API Gateway on Auth0 Marketplace, a catalog of trusted technology integrations to extend the functionality of Auth0’s identity management platform. KrakenD offers an ultra-performant API Gateway that allows companies to effortlessly adopt a microservices architecture through a powerful engine that can transform, aggregate, and remove data from their own or third-party services.
The KrakenD API Gateway serves as a unified interface for managing incoming API requests and connecting to the correct destination, while supporting functionalities across security, authorization, traffic management, observability, and load balancing, among others.</description></item><item><title>KrakenD 1.4.0 released</title><link>https://www.krakend.io/blog/krakend-1.4-release-notes/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.4-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.4.0. You can get it packaged from the download page.
KrakenD 1.4 is the last version of the 1.x family and primarily replaces the KrakenD Framework with the Lura Project and includes minor bug fixing and an extended flexible configuration. The next release with the new functionality will be 2.0.
Changes in KrakenD All dependencies for the framework moved to Lura json-collection added as a valid output encoding for collections Changes in Flexible Configuration For those using the flexible configuration, there are over 70 Sprig functions that have been added to the templating system:</description></item><item><title>Terms and Conditions</title><link>https://www.krakend.io/terms/</link><pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/terms/</guid><description>Last update: 24 May 2021
These terms and conditions govern your access to and use of the krakend.io website (hereinafter referred to as &amp;ldquo;KrakenD.io&amp;rdquo; or the &amp;ldquo;Website&amp;rdquo;).”).
1.- LEGAL INFORMATION Website owner KRAKEND S.L ID B06933832 Address Plaça Universitat 3, 6º, CP 08007, Barcelona E-mail hello@krakend.io Register Registro Mercantil de Barcelona; T 47888, F 124 H 565484 2.</description></item><item><title>KrakenD Enterprise 1.3.0 released</title><link>https://www.krakend.io/blog/krakend-ee-1.3-release-notes/</link><pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-ee-1.3-release-notes/</guid><description>We are glad to announce that KrakenD Enterprise 1.3.0 is out. The new release comes with the following new features.
New CLI commands The KrakenD binary comes with new generator commands, thought to be integrated into automated CI/CD pipelines.
generate postman: Creates a Postman collection that imports all KrakenD endpoints into Postman. It&amp;rsquo;s no longer necessary to use the KrakenD Studio to generate this content. generate openapi: Automatic generation of API documentation through a static Swagger file.</description></item><item><title>KrakenD framework becomes a Linux Foundation project</title><link>https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/</link><pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-framework-joins-the-linux-foundation/</guid><description>Today, together with the Linux Foundation, we are announcing that the KrakenD framework, our core engine, has been donated to the Linux Foundation and is now the &amp;ldquo;Lura Project.&amp;rdquo;
The Lura Project&amp;rsquo;s mission is to offer an extendable, simple, and stateless high-performance API Gateway framework designed for cloud-native and on-prem setups. Rather than solving a specific use case, Lura provides a library of components, a framework for assembling them into custom API gateway systems like a Lego set.</description></item><item><title>Albert Garcia to expand KrakenD business.</title><link>https://www.krakend.io/blog/albert-garcia-expand-krakend-business/</link><pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/albert-garcia-expand-krakend-business/</guid><description>Today, we are announcing that Albert Garcia recently joined KrakenD as Director of Business Development and member of the Board.
In his role, he will identify and develop new business opportunities to help expand even more the presence of KrakenD. Garcia will spearhead new markets and emerging trends, sales, and client relationship management, to name a few.
Having worked previously with him for more than 15 years, we know that Garcia is the right person at the right time for KrakenD.</description></item><item><title>Case study - Xiachufang (下厨房)</title><link>https://www.krakend.io/case-study/xiachufang/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/xiachufang/</guid><description>With around 70 million unique users, Xiachufang is the biggest cuisine community in China, making it possible for its users to share home recipes easily, watch video courses made by experts, and shop ingredients or kitchenware.
Xiachufang&amp;rsquo;s requirements at the beginning of its API gateway research were:
Being able to efficiently distribute the requests A simple and stateless approach to API gateway Strong customization capabilities An efficient and programmatic way to define rules Supporting monitoring and alarms Support the traffic and scalability needs of the company Xiachufang started with a small subset of live services (small as in nearly 2,000 requests per second) before starting moving more services to KrakenD:</description></item><item><title>How we built our telemetry service</title><link>https://www.krakend.io/blog/building-a-telemetry-service/</link><pubDate>Mon, 15 Mar 2021 09:40:25 +0200</pubDate><guid>https://www.krakend.io/blog/building-a-telemetry-service/</guid><description>​ We have run our telemetry system live for the past three years now. In this article, we&amp;rsquo;ll share code and outline some of the things you&amp;rsquo;ll need to keep in mind if you want to build an anonymous usage reporting system for an open-source project as we did (at a ridiculous cost).
We will show you how to use our reporting client and the details of our actual reporting servers in case you are thinking in implementing a cost-efficient solution with high scalability.</description></item><item><title>KrakenD 1.3.0 released</title><link>https://www.krakend.io/blog/krakend-1.3-release-notes/</link><pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.3-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.3.0. You can get it packaged from the download page.
KrakenD 1.3.0 makes focus on completing the RBAC system regarding JWT. The main highlights are:
JWT: Complete the RBAC system and flexibility improvements:
Scopes validation (thanks to @chrisdennig) Extract and forward claims as headers (thanks to @chrisdennig) Support for Oracle Identity Cloud Service by allowing key identifers other than kid such as x5t or kid_x5t (contribution from Oracle) Allow loading of local JWK files Integration with secret providers such as: Amazon KMS Azure&amp;rsquo;s Key Vault Google Cloud KMS Hashicorp&amp;rsquo;s Vault Encrypted or plain base64 file Other features:</description></item><item><title>KrakenD 1.2.0 released</title><link>https://www.krakend.io/blog/krakend-1.2-release-notes/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.2-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.2. You can get it packaged from the download page.
Some of the highlights include:
Added a /__health endpoint Removed the wording whitelist and blacklist from all our products (#BlackLivesMatter) Datadog integration Array manipulation available after merging multiple backends KRAKEND_-like environment vars to override configuration A lot of small features and bugfixes KrakenD framework Summary of the most significant changes:</description></item><item><title>Hepsiburada - KrakenD Case Study</title><link>https://www.krakend.io/case-study/hepsiburada/</link><pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/hepsiburada/</guid><description>Hepsiburada is the largest and fastest-growing e-commerce platform in Turkey and the top 5 in Europe. With over 150 million monthly visits and over 50 million product variations in mobile phones, cosmetics, consumer goods, fashion, and more, Hepsiburada is a business and technology leader in Turkey.
Hepsiburada challenges A company of such dimensions as Hepsiburada had several challenges before choosing KrakenD as their API gateway solution:
Operating 500 microservices and 40+ autonomous product development teams has many complex issues.</description></item><item><title>KrakenD Usage Stats - March 2020</title><link>https://www.krakend.io/blog/usage-stats-march-2020/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/usage-stats-march-2020/</guid><description>KrakenD servers with telemetry enabled help us to understand the usage of KrakenD in production. Last month we witnessed 356K running instances, and we wanted to share some data with you. 👇
From mid-March, we have seen an exciting increase in the number of KrakenD instances seen per day: x12! The trend is just beautiful, including the cumulative.
According to our internal definition, an instance is every time a KrakenD is started.</description></item><item><title>KrakenD 1.1 with Kafka integration released</title><link>https://www.krakend.io/blog/krakend-1.1-release-notes/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-1.1-release-notes/</guid><description>The KrakenD team is pleased to announce the release of KrakenD 1.1. You can get it packaged from the download page.
Some of the highlights include:
Kafka integration Extended Docker image Added Telemetry for Azure Monitor More performance improvements Kafka integration From now on, users of Apache Kafka can publish and subscribe from KrakenD. The Kafka integration saves you from writing application logic to interact with the streaming platform and let the gateway be an active player in the event architecture pattern.</description></item><item><title>Case Study - Perx</title><link>https://www.krakend.io/case-study/perx/</link><pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/perx/</guid><description>Perx is developing a data management platform called Hoop built on microservices and an architecture that makes use of extensive internal and external communications through REST APIs and asynchronous NATS channels.
KrakenD API Gateway offers robust functionality to control the traffic between external API clients and services. It aggregates microservices responses together into one unified API and thus provides flexible options for request/response manipulation to meet customers&amp;rsquo; needs.
Using KrakenD provides secure external connections with OAuth.</description></item><item><title>Case study - Privalia</title><link>https://www.krakend.io/case-study/privalia/</link><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/privalia/</guid><description>Veepee is the European flash sales leader with 72M of members, and Privalia its strategic brand for Spain, Italy, Brazil, and Mexico.
Privalia, with +13M members, evolved their customer care solution from an in-house solution to a Salesforce integration with their internal systems.
Before KrakenD, the main challenge of Veepee was to integrate Salesforce with multiple microservices and handle authorization, security, and aggregation in the middle layers.
KrakenD solved this challenge with out of the box features, keeping Privalia&amp;rsquo;s logic separated, and decoupled from Salesforce.</description></item><item><title>KrakenD 1.0 announcement</title><link>https://www.krakend.io/blog/announcing-krakend-1.0/</link><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/announcing-krakend-1.0/</guid><description>In November 2016, we released KrakenD framework to the public. Today, after three years serving traffic around the world, and a lot of lessons learned on the way, KrakenD 1.0 is out 🎉🎉🎉
KrakenD 1.0 is our announcement to the world that our libraries are now fully established and with the solid commitment of keeping backward compatibility. In the last twelve months, we have seen 120,000+ clusters in the world and 1M+ docker pulls, but as we always did (since 0.</description></item><item><title>Case Study - i2S by GFI</title><link>https://www.krakend.io/case-study/i2s/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/i2s/</guid><description>GFI is one of the most high-performing IT and digital service companies in the market. Their insurance branch i2S has software solutions installed in nearly 50 insurance companies (Life and Non-life) and several pension fund management societies.
KrakenD is the entry point to consume all the micro-services in a controlled way and helps create an insurance-related product, covering many aspects, from legal to finance and actuarial.
KrakenD unifies and aggregates the responses of all the underlying Java microservices, and injects custom middleware for insurance&amp;rsquo;s particular use case.</description></item><item><title>Case study - Open Room Inc</title><link>https://www.krakend.io/case-study/openroom/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/openroom/</guid><description>Open Room Inc. uses KrakenD to expose easily and safely various Real Estate applications, to help agents in their daily work and end-users to find the home they are looking for.
Open Room uses image processing, character recognition, document analysis, and machine learning.
KrakenD API Gateway helped Open Room to reduce the latency of all queries by grouping backend queries by frontend use-case, and allowed Open Room to build their API simply and coherently.</description></item><item><title>Case Study - Adevinta Spain</title><link>https://www.krakend.io/case-study/adevinta/</link><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/adevinta/</guid><description>Adevinta Spain handles a vast amount of traffic, as it operates marketplaces with 18 million active users. The adoption of KrakenD&amp;rsquo;s technology in production started in early 2017 and has been running since then.
Adevinta was investigating how to get more performance in their company-wide solution, and how to provide autonomy to non backend teams.
After several weeks of research, stress-tests and benchmarking several products in the market, Adevinta decided to choose KrakenD as the api gateway engine.</description></item><item><title>Case Study - Delivery Club (Mail.ru group)</title><link>https://www.krakend.io/case-study/mailru/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/mailru/</guid><description>Delivery Club, a Mail.ru brand, is the largest online food delivery platform in Russia, moving food from thousands of restaurants to homes in more than 100 cities.
Delivery Club processes +30,000 orders per day, 72% of which are made from mobile devices.
The technology is built using a modernized microservices architecture with around 20 services, including KrakenD API Gateway that sits between end users and Delivery Club&amp;rsquo;s services.
KrakenD&amp;rsquo;s main duty is processing ingoing and outgoing traffic making sure that user sessions are properly authorized when needed, and discarding malicious activity and hacking attempts.</description></item><item><title>Case Study - Dusdusan.com (Indonesia)</title><link>https://www.krakend.io/case-study/dusdusan/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/dusdusan/</guid><description>Established in the Jakarta City of Indonesia in November 2015, PT. Dusdusan Dotcom Indonesia is a mobile Internet company engaged in the research, development, and operation of E-business platform.
As a leader of membership E-business in Indonesia, Dusdusan.com, together with many domestic and foreign top brands and quality emerging brands, has integrated into the life of thousands of Indonesian families.
As the business developed rapidly, Dusdusan.com needs to keep improving its platform.</description></item><item><title>Case Study - Letgo</title><link>https://www.krakend.io/case-study/letgo/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/letgo/</guid><description>Letgo is the biggest and fastest-growing app for buying and selling locally.
Letgo is a desktop application (SPA) and a mobile application with native implementations for every operating system. As Letgo&amp;rsquo;s organization is large, the UI experience of each client (Android, iOS, web&amp;hellip;) is handled by a different team.
Letgo uses different clusters and configurations of KrakenD API Gateway per client, allowing each team to have its customized views of merged data.</description></item><item><title>Case Study - Pearson Education</title><link>https://www.krakend.io/case-study/pearson/</link><pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/case-study/pearson/</guid><description>Pearson Central Europe has trusted KrakenD as its API Gateway solution for the Parent App, which provides parents with a wide range of resources, including podcasts, infographics, quizzes, and checklists, to support their children&amp;rsquo;s progress in learning.
KrakenD API Gateway offers the endpoints to the Parent App and sits between end-users and the Pearson services, which provide all the data that KrakenD aggregates to supply the use case.
KrakenD handles OAuth with HMAC security and implements minor custom middlewares to fit the desired end-user consumption of the services.</description></item><item><title>gRPC-gateway as a KrakenD plugin</title><link>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</link><pubDate>Sun, 09 Jun 2019 18:26:10 +0100</pubDate><guid>https://www.krakend.io/blog/krakend-grpc-gateway-plugin/</guid><description>The gRPC protocol is becoming trendy in the era of microservices. Its compactness and backward-compatibility make it very attractive. However, it requires custom code to work with it. In this article, we&amp;rsquo;ll show you how to get all the benefits from the gRPC protocol and the gRPC-gateway without coding any business logic to use your gRPC services as regular backends. Moreover, avoiding the extra network hop!</description></item><item><title>Doing housekeeping on your KrakenD configuration file</title><link>https://www.krakend.io/blog/housekeeping-configuration-file/</link><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/housekeeping-configuration-file/</guid><description>Starting your krakend.json configuration from scratch and writing every attribute in a blank editor might be a difficult and time consuming task, and that&amp;rsquo;s why we have the KrakenDesigner.
KrakenDesigner is an aid tool to generate KrakenD configurations for the uninitiated audience. It produces a verbose output of the configuration file and explicitly writes unneeded attributes to let you see that a specific configuration option exists. These attributes I am mentioning are not necessary because they contain default values and the server is not going to alter its behavior.</description></item><item><title>KrakenD 0.9 released</title><link>https://www.krakend.io/blog/krakend-0.9-release-notes/</link><pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.9-release-notes/</guid><description>It&amp;rsquo;s been only one month since we released KrakenD 0.8, and although we have been releasing new versions approximately every 3 months, we have very interesting features that can&amp;rsquo;t wait! KrakenD 0.9 comes with a series of very demanded features. Let&amp;rsquo;s get started!
Integration with AMQP The AMQP integration allows you to send and receive messages to and from a queue through the KrakenD API Gateway. This feature enables the gateway to become in both a subscriber and a consumer of messages for asynchronous processing and opens the doors to very different implementations we were seeing.</description></item><item><title>KrakenD 0.8 released</title><link>https://www.krakend.io/blog/krakend-0.8-release-notes/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.8-release-notes/</guid><description>KrakenD 0.8 is a significant release as it brings numerous code changes and functionality. The framework brings +100 commits, the gateway +50 commits and even more changes in the components. A lot of refactoring and component updates has taken place. The big picture is a move from a single binary application to become a package with several internal binaries.
See the details below.
KrakenD framework The KrakenD framework brings +100 commits compared to 0.</description></item><item><title>How we run KrakenD on Javascript with WebAssembly</title><link>https://www.krakend.io/blog/krakend-wasm/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-wasm/</guid><description>KrakenD is an API Gateway written in Go that uses a single configuration file to define its whole behavior. As the configuration file might be complicated, the KrakenDesigner is a javascript-based user interface to edit this file, and we were missing the capability of reproducing directly on javascript the existing gateway pipes so that users could run manual tests over the editing configuration.
In this post, we are going to explain how we included KrakenD framework components in a .</description></item><item><title>KrakenD Team</title><link>https://www.krakend.io/team/</link><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/team/</guid><description/></item><item><title>KrakenD 0.7 released</title><link>https://www.krakend.io/blog/krakend-0.7-release-notes/</link><pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate><guid>https://www.krakend.io/blog/krakend-0.7-release-notes/</guid><description>The most relevant features for the 0.7 release are increased metrics and tracing options, and functionality that has been requested by many, the sequential proxy merger. During this release, we also updated the KrakenD brand with a new logo, and we added more documentation.
On the metrics side, we can now send structured events using GELF to your Graylog Cluster. Opencensus middleware adds new functionality to push metrics to your Google StackDriver account.</description></item><item><title>Case study - iContainers</title><link>https://www.krakend.io/case-study/icontainers/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/case-study/icontainers/</guid><description>iContainers is an ocean freight forwarder that allows you to compare, book, manage, and track maritime shipments in real-time without intermediaries.
As importers and exporters combine more than 500,000 rates and maritime transport routes from different providers, KrakenD plays the role of a Backend for Frontend in several SPAs. Some examples are the back-office, the partners portal, or the pricing API.
KrakenD&amp;rsquo;s primary duty in all these cases is to provide a reliable way to fetch data from multiple providers and APIs and merge the results of all the services into useful endpoints.</description></item><item><title>KrakenD Enterprise</title><link>https://www.krakend.io/enterprise/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/enterprise/</guid><description/></item><item><title>KrakenD Partners</title><link>https://www.krakend.io/partners/</link><pubDate>Fri, 05 Oct 2018 17:23:05 +0200</pubDate><guid>https://www.krakend.io/partners/</guid><description/></item><item><title>Krakend 0.6.1 release notes</title><link>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</link><pubDate>Thu, 04 Oct 2018 09:15:49 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.6.1-release-notes/</guid><description>The 0.6.1 release adds TLS and enables HTTP2 and HTTPS.
TL;DR This release brings HTTP2 and HTTPS to KrakenD. It also upgrades Go from 1.10 to 1.11 and fixes forwarded query string parameters to backends that are using arrays and repeated variables.
The KrakenDesigner (UI) is also updated to reflect these changes.
KrakenD framework The KrakenD framework has the following relevant changes:
NEW: Added support for HTTP2/HTTPS FIX: query string parameters works now with arrays and repeated variables (e.</description></item><item><title>Privacy Policy</title><link>https://www.krakend.io/privacy-policy/</link><pubDate>Fri, 14 Sep 2018 20:11:05 +0200</pubDate><guid>https://www.krakend.io/privacy-policy/</guid><description>In accordance with Regulation (EU) 2016/679 of the European Parliament and of the Council of 27 April 2016 on the protection of natural persons with regard to the processing of personal data and on the free movement of such data (General Data Protection Regulation, GDPR), and the provisions of the Organic Law 3/2018, of 5 December, of Personal Data Protection and Guarantee of Digital Rights, as well as any other applicable data protection regulations, we provide you with further information on the processing of your personal data in this privacy policy (hereinafter the &amp;ldquo;Privacy Policy&amp;rdquo;).</description></item><item><title>KrakenD 0.6 autumn release</title><link>https://www.krakend.io/blog/krakend-0.6-release-notes/</link><pubDate>Fri, 07 Sep 2018 09:18:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.6-release-notes/</guid><description>As if we were an agrarian society, our releases keep revolving around the weather calendar seasons. Autumn is around the corner (northern hemisphere), so our release is ready for a cool autumn.
TL;DR This release adds two interesting components: the JOSE component responsible for the JWT signing and validation, and the Cross-origin resource sharing (CORS) component. There is also a Consul client available.
The Krakend Playground and the KrakenDesigner (UI) is also updated.</description></item><item><title>Reloading the Krakend configuration with Reflex and Docker</title><link>https://www.krakend.io/blog/reloading-the-krakend-configuration/</link><pubDate>Fri, 22 Jun 2018 11:06:53 +0200</pubDate><guid>https://www.krakend.io/blog/reloading-the-krakend-configuration/</guid><description>Read the new documentation This is an article from 2018. You might want to see the Hot reload documentation. A recurrent question when we go around is if KrakenD configuration can be hot-reloaded, this is changing endpoints, backends, or any other configuration of the gateway while it&amp;rsquo;s running. The short answer is: No, you can&amp;rsquo;t. You must restart the server. And although we might have something to alleviate this, let us explain first why we don&amp;rsquo;t support such a feature:</description></item><item><title>KrakenD 0.5 summer release</title><link>https://www.krakend.io/blog/krakend-0.5-release-notes/</link><pubDate>Fri, 08 Jun 2018 14:50:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.5-release-notes/</guid><description>KrakenD 0.5 is out and we want to share some of the cool stuff this release is bringing.
This release focuses heavily on metrics and its export options to different backend systems such as Zipkin, InfluxDB, Prometheus or Jaeger. It also adds the NoOp logger and exposes all the advanced settings of the http client and server, giving all the power to the user. On the middleware side it extends even more the ecosystem with multiple components.</description></item><item><title>Running the KrakenD API Gateway on Kubernetes</title><link>https://www.krakend.io/blog/krakend-on-kubernetes/</link><pubDate>Wed, 06 Jun 2018 18:47:03 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-kubernetes/</guid><description>In this article we are going to show how to configure and deploy the KrakenD API Gateway in a kubernetes environment.
We will use for the demonstration Minikube so you cant test it in your own local machine.
Let&amp;rsquo;s get started!
Setting up a local Kubernetes We will run Kubernetes locally thanks to Minikube. Just follow the README in the project for the installation and the Quickstart section. Installing minikube it&amp;rsquo;s quick and easy.</description></item><item><title>Website development as a sysadmin</title><link>https://www.krakend.io/blog/website-development-as-a-sysadmin/</link><pubDate>Thu, 10 May 2018 16:18:25 +0200</pubDate><guid>https://www.krakend.io/blog/website-development-as-a-sysadmin/</guid><description>As a systems administrator for the past 15 years, I&amp;rsquo;m not very used to web development as this kind of work has been usually done by other colleagues in every company I&amp;rsquo;ve worked for. I wanted to create a web application myself using an external API, as an exercise to go out my comfort zone.
Some time ago I found that Marvel Comics has a REST API where you can get a lot of information about comics, characters, authors and other interesting information.</description></item><item><title>Edge computing - A story of buses, raspberries, IoT and API gateways</title><link>https://www.krakend.io/blog/krakend-on-raspberry/</link><pubDate>Tue, 01 May 2018 21:25:00 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-on-raspberry/</guid><description>The IoT industry has been running for some years now adding millions of devices into the network. The range of devices and capabilities is very wide and heterogeneous, from small devices powered with a 9-volt battery to track the location of freight shippings traveling the oceans (using platforms like Sigfox) to permanently plugged devices with more powerful computing like a Raspberry Pi where computation cycles are not a problem.
Generally speaking, all these devices collect raw data and send it to the cloud where big data centers process it.</description></item><item><title>How to work with Golang plugins and KrakenD</title><link>https://www.krakend.io/blog/krakend-golang-plugins/</link><pubDate>Thu, 12 Apr 2018 22:07:03 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-golang-plugins/</guid><description>The release of golang 1.8 more than a year ago opened the door to loading dynamic linked components in run time, and we were keen to find out if we could include this great feature in our KrakenD toolbox.
We&amp;rsquo;d like to share our experience and details on how we enhanced our products to support golang plugins.
Why would anyone use plugins in Go? The plugin concept is widely known and supported in several programming languages and environments.</description></item><item><title>Deploying and versioning an API Gateway</title><link>https://www.krakend.io/blog/deploying-an-api-gateway/</link><pubDate>Fri, 06 Apr 2018 23:46:25 +0200</pubDate><guid>https://www.krakend.io/blog/deploying-an-api-gateway/</guid><description>When it comes to maintaining and deploying an API Gateway within an organization, you should always be aware of best practice. A gateway is an extra step between the client and the servers with the power to define a whole new interface, yet it&amp;rsquo;s so flexible and easy to implement that you might be tempted to start creating API interfaces without thinking about it - and end up creating problems for the future.</description></item><item><title>KrakenD 0.4 release notes</title><link>https://www.krakend.io/blog/krakend-0.4-release-notes/</link><pubDate>Sun, 21 Jan 2018 14:50:53 +0200</pubDate><guid>https://www.krakend.io/blog/krakend-0.4-release-notes/</guid><description>KrakenD 0.4 materializes the announcement we did 3 months ago by going full open source and public releasing the former enterprise-only components.
This release note comprehends both the KrakenD framework and the KrakenD Community Edition binary distribution.
KrakenD framework The KrakenD framework, engine of the KrakenD API Gateway. The summary of changes introduced in the 0.4 are:
Removed ALL external dependencies and placed to krakend-contrib repositories Decoder and Service Discovery register system Response metadata Response decoder and formatter exposed Custom status code handler Minor handler optimizations Config version upgraded Server configuration extended (with timeouts and limits) Now non strict REST urls are allowed Request and response manipulation optimized func version for all the interfaces Link to 0.</description></item><item><title>An API Gateway is not the new Unicorn</title><link>https://www.krakend.io/blog/what-is-an-api-gateway/</link><pubDate>Fri, 19 Jan 2018 10:10:53 +0200</pubDate><guid>https://www.krakend.io/blog/what-is-an-api-gateway/</guid><description>The more we talk to people about API gateways, the more we have come to realize that the term means different things to different people, and more specifically we see a growing trend where developers (but mostly managers) expect an API gateway to be able to perform miracles, usually a long way away from its intended use.
It&amp;rsquo;s as if the API Gateway is the new unicorn that will solve all problems and make everything wonderful in the microservices scene.</description></item><item><title>Road to KrakenD 0.4</title><link>https://www.krakend.io/blog/road-to-0.4/</link><pubDate>Sun, 12 Nov 2017 12:10:53 +0200</pubDate><guid>https://www.krakend.io/blog/road-to-0.4/</guid><description>The next iteration of KrakenD is right around the corner and the Devops Faith team and the rest of the community we are working together to launch the 0.4 release before end of year. The jump from the 0.3.9 of the binary and the 0.3 of the framework to the 0.4 will bring a lot of interesting stuff but we also need to do a remarkable change in the code for a brighter future: kill external dependencies with fire.</description></item><item><title>How we automated our RPM and DEB packaging with Docker</title><link>https://www.krakend.io/blog/automating-linux-packaging/</link><pubDate>Mon, 06 Nov 2017 12:43:33 +0200</pubDate><guid>https://www.krakend.io/blog/automating-linux-packaging/</guid><description>Everyone loves reaching the maximum number of available platforms for their software but this usually comes at a cost. In this article we will explain how we generated our packaging for Linux in an automated fashion, being faithful to our DevOps dogma.
Dockerize all the things! Our team uses both Ubuntu and MacOS X in desktop machines and KrakenD has been running and behaving in the same way in all the platforms because from day one we decided to run everything on Docker.</description></item><item><title>Open sourcing all enterprise components</title><link>https://www.krakend.io/blog/open-sourcing-enterprise-features/</link><pubDate>Sun, 22 Oct 2017 19:01:33 +0200</pubDate><guid>https://www.krakend.io/blog/open-sourcing-enterprise-features/</guid><description>What are known today as the KrakenD Enterprise components will be disclosed in the form of open source repositories in the following weeks, and the action has already started, don&amp;rsquo;t miss it! In this post we will explain the reasons behind this decision that might sound crazy from a business perspective in the first place. Why anyone would publish the paid software increment bits of an existing free software?
A look back&amp;hellip; If you are reading this post chances are that you know this already, in short KrakenD is the fastest API Gateway in the market.</description></item><item><title>Download KrakenD</title><link>https://www.krakend.io/download/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/download/</guid><description/></item><item><title>Enterprise subscription</title><link>https://www.krakend.io/checkout/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/checkout/</guid><description/></item><item><title>Failed to process the payment</title><link>https://www.krakend.io/checkout-cancelled/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/checkout-cancelled/</guid><description/></item><item><title>KrakenD Open Source</title><link>https://www.krakend.io/open-source/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/open-source/</guid><description/></item><item><title>KrakenD support - Have questions?</title><link>https://www.krakend.io/support/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/support/</guid><description/></item><item><title>Subscription registered!</title><link>https://www.krakend.io/checkout-success/</link><pubDate>Wed, 26 Oct 2016 18:23:05 +0200</pubDate><guid>https://www.krakend.io/checkout-success/</guid><description/></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/enterprise/v1.3/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/v1.3/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Frequently Asked Questions</title><link>https://www.krakend.io/docs/v1.4/faq/</link><pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/faq/</guid><description>I am getting a 200 status when the backend returns a 201 E.g:
2017/01/19 - 10:31:27 | 200 | 1.134431ms | ::1 | POST /users Explanation By default, the gateway will always send an HTTP status 200 if the backend returns a 200 or a 201. You can inject your own HTTPStatusHandler implementation if you need a different behavior. Check this issue comment for more details.
I am getting a 500 status when the backend returns anything but 200, 201 or redirects E.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg&amp;nbsp;--verify&amp;nbsp;krakend_2.1.1_amd64_generic-linux.tar.gz.asc&amp;nbsp;krakend_2.1.1_amd64_generic-linux.tar.gz gpg:&amp;nbsp;Signature&amp;nbsp;made&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;10&amp;nbsp;18:17:18&amp;nbsp;2019&amp;nbsp;UTC&amp;nbsp;using&amp;nbsp;RSA&amp;nbsp;key&amp;nbsp;ID&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;Can't&amp;nbsp;check&amp;nbsp;signature:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;not&amp;nbsp;found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.
Term&amp;nbsp; $gpg&amp;nbsp;--keyserver&amp;nbsp;keyserver.ubuntu.com&amp;nbsp;--recv-key&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;requesting&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2&amp;nbsp;from&amp;nbsp;hkp&amp;nbsp;server&amp;nbsp;keyserver.ubuntu.com gpg:&amp;nbsp;trustdb&amp;nbsp;created gpg:&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;"Devops&amp;nbsp;Faith&amp;nbsp;Package&amp;nbsp;Manager&amp;nbsp;"&amp;nbsp;imported gpg:&amp;nbsp;Total&amp;nbsp;number&amp;nbsp;processed:&amp;nbsp;1 gpg:&amp;nbsp;imported:&amp;nbsp;1 (RSA:&amp;nbsp;1) Now you can verify the signature of the package:</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v1.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v1.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.3.0_amd64.tar.gz.asc krakend_1.3.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/enterprise/v2.0/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/enterprise/v2.0/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg&amp;nbsp;--verify&amp;nbsp;krakend_v2.0_amd64.tar.gz.asc&amp;nbsp;krakend_v2.0_amd64.tar.gz gpg:&amp;nbsp;Signature&amp;nbsp;made&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;10&amp;nbsp;18:17:18&amp;nbsp;2019&amp;nbsp;UTC&amp;nbsp;using&amp;nbsp;RSA&amp;nbsp;key&amp;nbsp;ID&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;Can't&amp;nbsp;check&amp;nbsp;signature:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;not&amp;nbsp;found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.
Term&amp;nbsp; $gpg&amp;nbsp;--keyserver&amp;nbsp;keyserver.ubuntu.com&amp;nbsp;--recv-key&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;requesting&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2&amp;nbsp;from&amp;nbsp;hkp&amp;nbsp;server&amp;nbsp;keyserver.ubuntu.com gpg:&amp;nbsp;trustdb&amp;nbsp;created gpg:&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;"Devops&amp;nbsp;Faith&amp;nbsp;Package&amp;nbsp;Manager&amp;nbsp;"&amp;nbsp;imported gpg:&amp;nbsp;Total&amp;nbsp;number&amp;nbsp;processed:&amp;nbsp;1 gpg:&amp;nbsp;imported:&amp;nbsp;1 (RSA:&amp;nbsp;1) Now you can verify the signature of the package:</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg&amp;nbsp;--verify&amp;nbsp;krakend_2.1.3_amd64_generic-linux.tar.gz.asc&amp;nbsp;krakend_2.1.3_amd64_generic-linux.tar.gz gpg:&amp;nbsp;Signature&amp;nbsp;made&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;10&amp;nbsp;18:17:18&amp;nbsp;2019&amp;nbsp;UTC&amp;nbsp;using&amp;nbsp;RSA&amp;nbsp;key&amp;nbsp;ID&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;Can't&amp;nbsp;check&amp;nbsp;signature:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;not&amp;nbsp;found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.
Term&amp;nbsp; $gpg&amp;nbsp;--keyserver&amp;nbsp;keyserver.ubuntu.com&amp;nbsp;--recv-key&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;requesting&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2&amp;nbsp;from&amp;nbsp;hkp&amp;nbsp;server&amp;nbsp;keyserver.ubuntu.com gpg:&amp;nbsp;trustdb&amp;nbsp;created gpg:&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;"Devops&amp;nbsp;Faith&amp;nbsp;Package&amp;nbsp;Manager&amp;nbsp;"&amp;nbsp;imported gpg:&amp;nbsp;Total&amp;nbsp;number&amp;nbsp;processed:&amp;nbsp;1 gpg:&amp;nbsp;imported:&amp;nbsp;1 (RSA:&amp;nbsp;1) Now you can verify the signature of the package:</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v1.3/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.3/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.3.0_amd64.tar.gz.asc krakend_1.3.0_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v1.4/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v1.4/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
$ gpg --verify krakend_1.4.1_amd64.tar.gz.asc krakend_1.4.1_amd64.tar.gz gpg: Signature made Sun Mar 10 18:17:18 2019 UTC using RSA key ID 5DE6FD698AD6FDD2 gpg: Can't check signature: public key not found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.</description></item><item><title>Verifying packages (PGP and SHA256)</title><link>https://www.krakend.io/docs/v2.0/overview/verifying-packages/</link><pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate><guid>https://www.krakend.io/docs/v2.0/overview/verifying-packages/</guid><description>How to make sure what you are downloading is legit.
PGP We will check the detached signature PGP against our package KrakenD.
Term&amp;nbsp; $gpg&amp;nbsp;--verify&amp;nbsp;krakend_v2.0_amd64.tar.gz.asc&amp;nbsp;krakend_v2.0_amd64.tar.gz gpg:&amp;nbsp;Signature&amp;nbsp;made&amp;nbsp;Sun&amp;nbsp;Mar&amp;nbsp;10&amp;nbsp;18:17:18&amp;nbsp;2019&amp;nbsp;UTC&amp;nbsp;using&amp;nbsp;RSA&amp;nbsp;key&amp;nbsp;ID&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;Can't&amp;nbsp;check&amp;nbsp;signature:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;not&amp;nbsp;found We don&amp;rsquo;t have the packager public key (AB39BEA1) in our system. You need to retrieve the public key from a key server.
Term&amp;nbsp; $gpg&amp;nbsp;--keyserver&amp;nbsp;keyserver.ubuntu.com&amp;nbsp;--recv-key&amp;nbsp;5DE6FD698AD6FDD2 gpg:&amp;nbsp;requesting&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2&amp;nbsp;from&amp;nbsp;hkp&amp;nbsp;server&amp;nbsp;keyserver.ubuntu.com gpg:&amp;nbsp;trustdb&amp;nbsp;created gpg:&amp;nbsp;key&amp;nbsp;5DE6FD698AD6FDD2:&amp;nbsp;public&amp;nbsp;key&amp;nbsp;"Devops&amp;nbsp;Faith&amp;nbsp;Package&amp;nbsp;Manager&amp;nbsp;"&amp;nbsp;imported gpg:&amp;nbsp;Total&amp;nbsp;number&amp;nbsp;processed:&amp;nbsp;1 gpg:&amp;nbsp;imported:&amp;nbsp;1 (RSA:&amp;nbsp;1) Now you can verify the signature of the package:</description></item></channel></rss>